---
title: "Trial Simulation"
bibliography: vignettes.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Trial Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(tidyverse)
library(kableExtra)
```

> The `tidy()` methods used in this vignette follow the pattern established by the `broom` package and turn objects of various classes into tibbles.  Currently, they are defined in a code chunk within this tibble that is not displayed, but will be added to the main `crmpack` package at a later date.

```{r function-definitions, echo=FALSE}
library(broom)

setMethod(
  f = "tidy",
  signature = signature(x = "Samples"),
  def = function(x, data = NULL, ...) {
    rv <- lapply(
      names(x@data),
      function(col) {
        tibble(!! as.symbol(col) := x@data[[col]])
      }
    ) %>% bind_cols()
    
    if (!is.null(data)) {
      rv <- rv %>% 
        expand(!!!x@data, Dose = data@doseGrid) %>% 
        mutate(
          Z = exp(alpha0 + alpha1 * log(Dose / 56)), 
          Prob = Z/(1 + Z)
        )
    }
    rv
  }
)
```
## Introduction

This vignette contains an example of a very basic and superficial examination of the oerating characteristics of a basic CRM trial.  The design uses a 2-parameter logistic regression model with a log normal prior distribution,
and custom rules for choosing the cohort size, deciding whether to stop or continue the trial, defining the maximum permitted increment and selecting the dose for the nest study.

The first step is to define the trial design in `crmPack`...

## Study definition

```{r example, message = FALSE}
library(crmPack)

# Define the dose grid and an empty data object
dose_grid <- c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100)
empty_data <- Data(doseGrid = dose_grid)

# Initialize the CRM model.
initial_model <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 56
)

# Choose the rule for selecting the next dose.
next_best <- NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
)

# Choose the rule for the cohort size.
cohort_size1 <- CohortSizeRange(
  intervals = c(0, 30),
  cohort_size = c(1, 3)
)
cohort_size2 <- CohortSizeDLT(
  dlt_intervals = c(0, 1),
  cohort_size = c(1, 3)
)
cohort_size <- maxSize(cohort_size1, cohort_size2)

# Choose the rule for stopping.
stopping_success1 <- StoppingMinCohorts(nCohorts = 3)
stopping_success2 <- StoppingTargetProb(
  target = c(0.2, 0.35),
  prob = 0.5
)
stopping_futility <- StoppingMinPatients(nPatients = 20)
stopping_trial <- (stopping_success1 & stopping_success2) | stopping_futility

# Choose the rule for dose increments.
increment_rule <- IncrementsRelative(
  intervals = c(0, 20),
  increments = c(1, 0.33)
)

# Initialize the design.
design <- Design(
  model = initial_model,
  nextBest = next_best,
  stopping = stopping_trial,
  increments = increment_rule,
  cohortSize = cohort_size,
  data = empty_data,
  startingDose = 3
)
```

## Basic sanity checking: incoherence and rigidity

The `examine` function lists the dose recommendations made by CRM design after the first DLT is reported.  The output shows, for each dose and number of DLTs reported, the dose recommendation (`nextBest` dose) made by the model on the assumption that no earlier DLTs were reported at lower doses.

```{r}
examine(design) %>% kable()
```

Cheung [@dfcrm2013] (p146) describes a CRM trial as *rigid* if there exists a dose from which escalation is not possible regardless of the number of participants who do not experience when treated at that dose.  He then (p164) defines a CRM trial as *incoherent* if, among other criteria, it recommends a dose escalation immediately following the first report of a DLT.

The output from `examine` shows that our initial design is not incoherent (because there is no recommendation to increase the dose used in the next cohort following the first report of a DLT), but it is rigid.  It is rigid because, even when no toxicities are reported at 25 mg, the model is unable to recommend escalation before the trial's futility stopping rule (defined by `stopping_futility` above) is satisfied.

This is clearly unsatisfactory.  The problem lies with the increments rule, which allows a maximum escalation of 33% between one dose and the next for doses above 20 mg.  The dose grid being used is `r empty_data@doseGrid`.  The ratio between 20 and 25 is `r 25/20`, but between 25 and 40 is `r 40/25`.  We can confirm this by checking the behaviour of `maxDose` with artificial data:

```{r}
no_tox_below_25_data <- Data(
  doseGrid = dose_grid,
  x = c(1, 3, 5, 10, 15, 20, 25),
  y = rep(0, 7),
  ID = 1L:7L,
  cohort = 1L:7L
)

next_dose <- maxDose(increment_rule, no_tox_below_25_data)
next_dose
```


Thus, the initial dose rule permanently prevents escalation above 25 mg because the highest permitted dose above 25 mg is `r next_dose` but the lowest such dose in the dose grid is 40.  The problem can be solved in at least two ways: we can either relax the increments rule or we can introduce one or more intermediate doses.  (We could, of course, do both.)  We choose to relax the increments rule and check that, ceteris paribus, this permits escalation from every dose:

```{r}
revised_increment_rule <- IncrementsRelative(
  intervals = c(0, 20, 80),
  increments = c(1, 0.67, 0.33)
)
tibble(
  HighestDoseUsed = dose_grid,
  MaxPermittedDose = c(NA, 
    sapply(
      1:length(dose_grid[-1]),
      function(n) {
        tmp <- dose_grid[-1]
        d <- Data(
          doseGrid = dose_grid,
          x = tmp[1:n],
          y = rep(0, n),
          ID = as.integer(1:n),
          cohort = as.integer(1:n)
        )
        maxDose(revised_increment_rule, d)
      }
    )
  )
) %>% 
mutate(EscalationPermitted = lead(HighestDoseUsed < MaxPermittedDose)) %>% 
kable()

```

Yes, it does.  So we update the design:
```{r}
revised_design <- Design(
  model = initial_model,
  nextBest = next_best,
  stopping = stopping_trial,
  increments = revised_increment_rule,
  cohortSize = cohort_size,
  data = empty_data,
  startingDose = 3
)
examine(revised_design) %>% 
  kable()
```

Hmmm. We now appear to be stuck at 50 mg.  Why is this?  Let's examine the state of the model after escalation to 50 mg without toxicity...

```{r}
no_tox_below_50_data <- Data(
  doseGrid = dose_grid,
  x = c(1, 3, 5, 10, 15, 20, 25, 40, 40, 40, 50, 50, 50),
  y = rep(0, 13),
  ID = 1L:13L,
  cohort = c(1L:7L, rep(8L:9L, each = 3))
)

default_mcmc_options <- McmcOptions(burnin=1000, step=2, samples=1000)
no_tox_50_samples <- mcmc(no_tox_below_50_data, initial_model, default_mcmc_options)
recommended_dose <- nextBest(
  next_best,
  doselimit = Inf,
  samples = no_tox_50_samples,
  model = initial_model,
  data = no_tox_below_50_data
)
recommended_dose$value
recommended_dose$probs

maxDose(revised_increment_rule, no_tox_below_50_data)
```

Whilst the increments rule allows escalation to 83.5 mg, the toxicity estimates provided by the model do not: the current estimate of toxicity at 80 mg is `r recommended_dose$probs[10, 3]`, well above the limit of 0.25 defined in the dose recommendation rule (`next_best`).

Again, we have several options.  We can introduce intermediate doses, thus slowing escalation and allowing the prior model more time to adapt (but probably requiring a larger trial), or we can modify the prior so that it allows faster, but still reasonable, escalation.  Let's try creating a minimally informative prior that is consistent with our first attempt.

```{r}
# min_inf_model <- MinimalInformative(
#   dose_grid,
#   56,
#   threshmin = 0.1,
#   threshmax = 0.4,
#   probmin = 0.05,
#   probmax = 0.05
# )
# 
# as_tibble(min_inf_model$required) %>% 
#   add_column(Dose=dose_grid) %>% 
#   add_column(Type = "Required") %>% 
#   bind_rows(
#     as_tibble(min_inf_model$quantiles) %>% 
#       add_column(Dose=dose_grid) %>% 
#       add_column(Type = "Fitted")
#   ) %>% 
#   ggplot() +
#     geom_line(aes(x = Dose, y=median, colour = Type), linetype="solid") +
#     geom_line(aes(x = Dose, y=lower, colour = Type), linetype = "dotted") +
#     geom_line(aes(x = Dose, y=upper, colour = Type), linetype = "dotted")
```

The current prior model is a logistic logNormal model with a reference dose of 56, a mean intercept of -0.85 and a mean slope of 1.  What sort of a dose toxicity curve does this create?

```{r, fig.width=7}
tibble(
  Dose=1:100,
  Alpha0=-0.85,
  Alpha1=1,
  Z = exp(Alpha0 + Alpha1 * log(Dose / 56)),
  Prob = Z / (1  + Z)
) %>% 
ggplot() +
  geom_line(aes(x = Dose, y = Prob)) +
  labs(title = "Plug-in estimate of the prior dose toxicity curve")
```
```{r, fig.width=7, eval=FALSE}
no_tox_data <- Data(
  doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),
  x = c(rep(c(1, 3, 5, 10, 15, 20), each=2), rep(25, 8)),
  y = rep(0, 20),
  cohort = as.integer(rep(1:10, each=2)),
  ID = as.integer(1:20)
)

no_tox_samples <- mcmc(no_tox_data, initial_model, default_mcmc_options)
plot(no_tox_samples, initial_model, no_tox_data)
no_tox_samples %>% 
  tidy(no_tox_data) %>% 
  group_by(Dose) %>% 
  summarise(
    Mean=mean(Prob),
    Q05=quantile(Prob, probs=0.05, na.rm = TRUE),
    Q10=quantile(Prob, probs=0.10, na.rm = TRUE),
    Median=quantile(Prob, probs=0.50, na.rm = TRUE),
    Q90=quantile(Prob, probs=0.90, na.rm = TRUE),
    Q95=quantile(Prob, probs=0.95, na.rm = TRUE),
    ProbMTD=mean(Prob >= 0.2 & Prob < 0.35, na.rm = TRUE),
    ProbOverdose=mean(Prob >= 0.35, na.rm = TRUE)
  ) %>% 
  kable()

recommended_dose <- nextBest(
  next_best,
  doselimit = Inf,
  samples = no_tox_samples,
  model = initial_model,
  data = no_tox_data
)
recommended_dose

stopTrial(stopping_trial, recommended_dose$value, no_tox_samples, initial_model, no_tox_data)
```

```{r, eval=FALSE}

# Define the true function.
my_truth <- function(dose) {
  alpha0 <- 7
  alpha1 <- 8
  ref_dose <- 56
  stand_log_dose <- log(dose / ref_dose)
  plogis(alpha0 + alpha1 * stand_log_dose)
}

# Run the simulation on the desired design.
# We only generate 1 trial outcome here for illustration, for the actual study
# this should be increased of course.
options <- McmcOptions(
  burnin = 100,
  step = 1,
  samples = 2000
)
time <- system.time(my_sims <- simulate(design,
  args = NULL,
  truth = my_truth,
  nsim = 1,
  seed = 819,
  mcmcOptions = options,
  parallel = FALSE
))[3]
```

## References
