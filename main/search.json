[{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Model-based dose escalation designs gained increasing interest due need efficient informative Phase trials. wide-spread implementation designs hindered need either licensing specialized commercial software programming design simulations scratch project. R-package crmPack provides simple unified object-oriented framework model-based dose escalation designs. enables standard use designs, able flexibly adapt extend . framework comprises classes methods data structure including dose grid, statistical models including prior specification, rules maximum increments, next best dose, adaptive stopping cohort sizes. addition multiple modified classic continual reassessment method escalation overdose control designs possibly advanced prior specifications (e.g., minimal informative mixture priors), crmPack currently features dual-endpoint (safety biomarker) designs two-part designs. Optional assignment small number patients cohort placebo instead treatment enables use trials outside Oncology. Keywords: continual reassessment method, model based dose escalation, dual-endpoint design, R, object oriented.","code":""},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Phase trials testing new investigational agents humans first time escalate low high doses sequential fashion. dose escalation design necessary order reduce risk high therefore toxic doses probands. can either healthy volunteers (e.g., neurology) patients (e.g., oncology), henceforth use latter ease presentation. higher doses agents usually expected deliver stronger pharmacodynamic effects hence improved efficacy, higher doses also usually cause severe adverse events patients. order simplify decision making usually binary dose-limiting toxicities (DLTs) defined (e.g., adverse events reaching specific severity levels) starting trial. maximum tolerated dose (MTD) defined dose certain probability DLTs (either using single value, e.g., 33%, range, e.g., 20 35%). Historically, patients treated dose cohorts three, dose next cohort determined number DLTs observed current cohort. Algorithmic designs like simple 3+3 design (Carter 1973) disadvantages recognized statistics community, see e.g., (Paoletti, Ezzalfani, Le Tourneau 2015). Fundamentally, escalation rules 3+3 design statistical justification (Storer 1989) terms estimating MTD. Moreover, extended address today’s Phase trials, extension cohorts, dose escalation drug combinations optimal biological dose determination, naming just prominent challenges. Hence model-based dose escalation designs like continual reassessment method (CRM) (O’Quigley, Pepe, Fisher 1990) gained increasing interest due need efficient informative Phase trials. designs based statistical inference, dose-toxicity regression models backbone, therefore flexible adaptation various complex trial designs. Importantly, avoid fixing dose levels advance. wider comparison algorithmic model based designs see e.g., (Jaki, Clive, Weir 2013). However, wide-spread implementation designs hindered need either licensing specialized commercial software (thus losing flexibility) programming design simulations scratch project (thus losing efficiency). models underlying model-based dose escalation procedures can easily fit standard software capability fit generalized linear models, e.g., PROC MIXED SAS ( Institute Inc. 2003), glm Stata (StataCorp 2015) R ( Core Team 2016), still software solutions available dedicated dose escalation studies. commercial packages East (Cytel Inc. 2016) ADDPLAN (ICON Plc 2016) offer extensions basic design software dose escalation studies (ESCALATE East df ADDPLAN) implementing algorithmic 3+3 design various versions CRM. Similarly FACTS (FACTS Development Team 2015) also offers different common dose escalation methods. Due commercial nature implementations , however, limitation much designs can tailored towards individual needs study. Similarly static implementations methods dose escalation available Stata module crm (Mander 2013) implements CRM dfcrm package (K. Cheung 2013) R additionally implements time--event CRM (TITE-CRM) (Y. K. Cheung Chappell 2000). Several R-packages extensions available. bcrm package (M. Sweeting, Mander, Sabin 2013) implements variety one two parameter models, facilitates different ways specify prior distributions, escalation stopping rules. ordcrm package (Dressler Huang 2016) implements ordinal proportional odds continuation ratio models CRMs. dfpk package (Toumazi, Ursino, Zohar 2017) uses pharmacokinetic data dose escalation. paper introduce R-package crmPack (Sabanes Bove et al. 2018) dose escalation studies, publicly available CRAN. package’s name pays tribute original CRM first model-based dose escalation design, package’s functionality differs existing implementations three fundamental ways. Firstly, written using S4 classes methods (Chambers 2008), allows customized methodology added package still able use existing backbone functionalities. Secondly, methods studies placebo group (e.g., healthy volunteer studies) readily implemented. Thirdly, dual endpoint dose escalation methods incorporate safety efficacy allow determination optimal biological dose already available.","code":""},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"framework","dir":"Articles","previous_headings":"","what":"Framework","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"describing framework package adapt general notation early phase trials (Thall 2010). Figure @ref(fig:schematic) summarizes framework schematic. Schematic framework Separate design features implemented classes (shown gray boxes) bundled together overarching Design object. can processed various methods (blue text) run dose escalation trial produce results (blue boxes). example, Data GeneralModel objects can processed mcmc method order obtain posterior samples model parameters, given sample size dose next cohort, updated Data closes dose escalation loop. higher level, designs can investigated examine simulate methods obtain hypothetical trial courses operating characteristics, respectively. Note individual model classes methods shown clarity, please refer package documentation details, e.g., calling crmPackHelp().’ Data Let \\(x\\) denote one specific treatment, chosen set possible treatments \\({\\cal X}\\). one specific dose, also generally vector, containing example doses multiple drugs combination trial. giving treatment \\(x\\) patient, outcome \\(y\\) observed, typically safety endpoint e.g., binary DLT \\(y \\\\{0, 1\\}\\). Grouping together \\(n_{j}\\) patients cohort \\(j\\), generating cohort \\(j\\) data \\({\\cal C}_{j} = \\{(x_{j}, y_{j,1}), \\dotsc, (x_{j}, y_{j,n_{j}})\\}\\), can denote data generated first \\(N\\) cohorts \\({\\cal D}_{N}= {\\cal C}_{1} \\cup \\dotsb \\cup {\\cal C}_{N}\\). crmPack S4 class GeneralData encapsulates notion subclasses implement concrete data structures. Model core model-based dose escalation designs underlying statistical model. Taking Bayesian approach inference, model crmPack consists firstly likelihood, either probability density function \\[ f(y | x, \\theta)\\] probability mass function \\[ Prob(Y=y | x, \\theta)\\] \\(y\\) patient receives treatment \\(x\\) assuming parameter (vector) \\(\\theta\\), (likelihood \\(\\theta\\)) secondly prior \\[ p(\\theta | \\xi)\\] \\(\\theta\\) given fixed hyperparameters \\(\\xi\\). crmPack virtual S4 class GeneralModel encapsulates notion subclasses implement concrete models. example, class LogisticLogNormal implements logistic regression model (Neuenschwander, Branson, Gsponer 2008) \\[\\begin{equation} \\label{eq:LogisticLogNormal} \\mathrm{logit}(Prob(Y=1 | x,\\theta)) \\equiv \\mathrm{logit}(\\pi(x,\\theta)) = \\alpha_{0} + \\alpha_{1} \\log\\left(\\frac{x}{x^*}\\right), \\end{equation}\\] parameter vector \\(\\theta = (\\alpha_{0},\\alpha_{1})\\), dose \\(x > 0\\) specified reference dose \\(x^{*}\\). prior \\(p(\\theta | \\xi)\\) specified via bivariate normal distribution transformation \\(\\theta\\) ensure \\(\\alpha_{1} > 0\\): \\[\\begin{equation}   \\label{eq:bivariateNormal}   (\\alpha_{0}, \\log(\\alpha_{1})) | \\xi \\sim \\mathcal{N}_{2} (\\mu, \\Sigma) \\end{equation}\\] hyperparameters \\(\\xi = (\\mu, \\Sigma)\\) consisting prior mean vector \\(\\mu\\) prior covariance matrix \\(\\Sigma\\). Decision making next dose Another core element dose escalation design concerns decision making next dose \\(x_{N+1}\\) tested next cohort \\(N+1\\). (Thall 2010) notation, function \\(\\alpha\\) mapping currently accumulated data \\(\\mathcal{D}_{N}\\) dose space \\(\\mathcal{X}\\) (dose \\(0\\), meaning stop trial doses toxic): \\[\\begin{equation} \\alpha: {\\cal D}_{N} \\rightarrow \\mathcal{X} \\cup \\{0\\} \\end{equation}\\] mapping commonly specified via combination two elements: first element function \\(\\tau\\) maximum increments dose levels, can calculate current data \\(\\mathcal{D}_{N}\\) (including current dose \\(x_{N}\\)) maximum possible next dose \\(t_{N+1}=\\tau(\\mathcal{D}_{N})\\) next cohort. second element rule \\(\\nu\\) indirectly acting current data posterior distribution \\(p(\\theta | \\mathcal{D}_{N})\\) maximum possible dose \\(t_{N+1}\\) finally give next dose \\(x_{N+1} = \\nu(p(\\theta | \\mathcal{D}_{N}), t_{N+1})\\). crmPack maximum increments specified subclasses Increments, next best dose rule subclasses NextBest. design class Additional features design concern adaptive sizing next cohort adaptive stopping trial. implemented subclasses CohortSize Stopping, respectively. Moreover, starting dose \\(x_{1}\\) also feature design. Finally, overall dose escalation design bundling described features together dedicated class typically inheriting Design. noted (Thall 2010), operating characteristics complex dose escalation design can evaluated simulations. can done using simulate methods design classes, recommended performed multitude different scenarios order stress-test design convince oneself properties. particular, operating characteristics reveal whether MTD can estimated well designs. addition, examine method evaluates hypothetical trial outcomes lists resulting trial decisions (dose next cohort trial end). order illustrate use object-oriented framework, next section contains practical examples use existing functionality well example creating new extensions.","code":"knitr::include_graphics(\"./schematic.png\")"},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"using-crmpack","dir":"Articles","previous_headings":"","what":"Using crmPack","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"consider trial Type II diabetes carried Hoffmann-La Roche Ltd. order illustrate functionality package. patient, observed binary safety (DLT) continuous efficacy outcome. Implementing CRM trial show implement CRM design dose escalation based safety endpoint , Dose escalation safety efficacy also efficacy endpoint considered. Extending crmPack functionality gives example extending crmPack functionality. start, install subsequently load package R: indicated startup message, try crmPackHelp() crmPackExample() open help page package vignette.","code":"library(\"crmPack\") ## Loading required package: ggplot2 ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example"},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"implementing-a-crm-trial","dir":"Articles","previous_headings":"Using crmPack","what":"Implementing a CRM trial","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Suppose 12 dose levels ranging 25 300 mg 25 mg increments novel agent available addition placebo, defining dose grid \\(\\mathcal{X} = \\{0.001,25, 50,\\dotsc, 300\\}\\), \\(x_{1} = 0.001\\) mg representing placebo \\(x_{2} = 25\\) starting dose. Note used small dose instead zero \\(x_{1}\\), since consider regression model @eqref(eq:LogisticLogNormal) log transformation dose \\(x\\) (\\(x^{*} = 100\\) chosen reference dose). Minimally informative prior assume limited prior information available dose-toxicity relationship, hence like use minimally informative prior (Neuenschwander, Branson, Gsponer 2008) can easily obtained function MinimalInformative. Since stochastic optimization used internally, setting seed required reproducibility. Furthermore, recommended specify coarse dose grid across original dose range (excluding placebo dose) avoid long computation time: resulting model (object class LogisticLogNormal) prior parameters \\[\\mu = (0.0720313, 2)\\] \\[\\Sigma= \\left(\\begin{smallmatrix}    1.51 & 0.18 \\\\    0.18 & 0.21 \\end{smallmatrix}\\right)\\] approximately 5% probability DLT rate exceed 10% (threshmin argument) 25 mg dose 20% (threshmax) 300 mg dose. Data object definition visualization simple case univariate dose \\(x\\) resulting binary DLT observations \\(y\\), S4 class Data can used. Objects class can created calling accompanying initialization function name (general convention crmPack): argument x takes doses \\(x_{1}=0.001, x_{2}=25, x_{3} = 50, x_{4} = 100\\) (note repetition match outcome variables \\(y_{j,k}\\)) doseGrid captures set \\({\\cal X}\\) possible doses, y takes binary DLTs (\\(y_{3, 3} = 1\\) denotes DLT observed 3rd patient 3rd cohort), cohort groups patients together cohorts (\\(N=3\\)). option placebo used specify placebo controlled study, placebo patients included cohort. lowest dose \\(x_{1}\\) interpreted internally placebo dose. Patient IDs can given optionally ID argument. data can visualized simply applying plot function object, also allows produce blinded plot (hiding patient IDs placebo/treatment assignment) option blind, see Figure @ref(fig:plot-data): Open blinded data plots Sampling prior posterior Now model data place, can use MCMC sampling obtaining posterior distribution model parameters \\(\\theta\\), hence DLT rates \\(Prob(Y=1 | x,\\theta)\\), various doses \\(x\\). MCMC sampling can controlled object class McmcOptions, provided mcmc function, together data model objects: posterior mean curve 95% equi-tailed credible interval curves DLT rates can obtained supplying samples, model data generic plot function. Similarly can also produce similar plot without data, giving prior, see Figure @ref(fig:plot-model-fit): Posterior prior regression model fits illustrated , plots can customized using ggplot2(Wickham 2009) functionality. can see posterior mean estimate (left panel, continuous line) slightly steeper prior mean estimate curve (right panel, continuous line), posterior uncertainty reduced due data (smaller credible intervals, dashed lines). Decision making next dose determine dose administer next (cohort ) patients begin specifying maximum increments function \\(\\tau\\). example maximum increase 100% doses 100 mg, 50% doses range 100 mg 200 mg, 33% doses equal 200 mg specified using class IncrementsRelative: specific rule \\(\\tau\\) can evaluated current dataset \\({\\cal D}_{N}\\) maxDose function obtain maximum next dose \\(t_{N+1} = \\tau({\\cal D}_{N})\\): define function \\(\\nu\\) selecting dose next cohort. case like select dose maximizes probability DLT rate target toxicity range 20% 35%, probability overdosing exceeding 25% (Neuenschwander, Branson, Gsponer 2008), using NextBestNCRM class: rule can evaluated function NextBest obtain next dose \\(x_{N+1}=\\nu({\\cal D}_{N}, t_{N+1})\\): returned list also contains accompanying plot (nextDoseRes$plot), see Figure @ref(fig:nextBest-ncrm). Adaptive stopping trial like stop dose escalation adaptively maximum sample size \\(n=30\\) patients reached already, sufficient precision MTD estimate. can specify latter condition follows: probability next dose \\(x_{N+1}\\) target toxicity range 50%, least 9 patients already dosed within +/- 20% range \\(x_{N+1}\\). corresponding Stopping class object constructed combining atomic rules logical operators follows: , specific rule can evaluated function, called stopTrial, specific situation: result FALSE means yet stop trial, attribute message giving results atomic stopping rules. Examine dose escalation design last topic section, want show assess performance given CRM design. first need specify design creating object class Design. contains model, rules dose escalation (Increments, NextBest, Stopping CohortSize), dose grid (example object emptydata) starting dose (see also Figure @ref(fig:schematic). case use fixed cohort size 3 patients active 1 patient placebo (``3+1’’) throughout study: can start looking single trial operating characteristics dose escalation design function examine, generates data frame showing beginning several hypothetical trial courses design. Assuming DLTs seen certain dose, consequences different number DLTs observed dose shown. example, observe 3 DLTs starting dose 25 mg, need stop trial, enroll another cohort dose level case 2 DLTs. last rows output see DLTs observed 250 mg cohort, maximum considered dose 300 mg dose can reached next cohort also DLTs observed 250 mg. 1, 2 3 DLTs observed, next dose recommended 225, 175 150 mg, respectively. Simulating operating characteristics many trials operating characteristics, first define true scenarios, data arise. case, requires function computes probability DLT given dose. example use function contained slot prob object model: %, dose-toxicity curve shown . Note possible R-function returning vector probabilities upon input dose vector can used. particular, trivially possible directly specify probability DLT dose order examine operating characteristics based statistical model. example, assume 5 doses 1–5 probabilities DLT 0.01, 0.02, 0.04, 0.06, 0.09, following code used: Now can proceed simulations using function simulate: number simulated trials depends required accuracy results. argument parallel can set TRUE one wishes run iterations parallel processors computer, can yield meaningful speedup. needed 170 seconds 100 simulated trials Intel Core i5-6300U CPU 2.4 GHz. result object class Simulations containing multiple slots, e.g., data slot containing list simulated trials. slots doses stopReasons contain information final MTD stopping reason trial. can e.g., investigate number patients MTD end third simulated trial: Furthermore, can plot Simulations object calling plot method , see Figure @ref(fig:sim-plot). can select plots changing type argument plot, default type = c(\"trajectory\", \"dosesTried\"). Second, can summarize simulation results, obtain textual description results: plot summary results can also produced, see Figure @ref(fig:sim-summary-plot).","code":"coarseGrid <- c(25, 50, 100, 200, 300) model <- MinimalInformative(   dosegrid = coarseGrid, refDose = 100,   logNormal = TRUE, threshmin = 0.1,   threshmax = 0.2, seed = 432,   control = list(max.time = 30) )$model PL <- 0.001 data <- Data(   x = c(PL, 25, 25, 25, PL, 50, 50, 50, PL, 100, 100, 100),   y = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),   doseGrid = c(PL, seq(25, 300, 25)),   ID = 1:12,   placebo = TRUE ) plot(data) plot(data, blind = TRUE) options <- McmcOptions(burnin = 1000, step = 2, samples = 10000) set.seed(94) samples <- mcmc(data, model, options) plot(samples, model, data) + ggtitle(\"Posterior\")  emptydata <- Data(doseGrid = data@doseGrid, placebo = TRUE) priorsamples <- mcmc(emptydata, model, options) plot(priorsamples, model, emptydata) + ggtitle(\"Prior\") myIncrements <- IncrementsRelative(   intervals = c(0, 100, 200),   increments = c(1, 0.5, 0.33) ) (nextMaxDose <- maxDose(myIncrements, data)) ## [1] 150 myNextBest <- NextBestNCRM(   target = c(0.2, 0.35), overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) nextDoseRes <- nextBest(myNextBest, nextMaxDose, samples, model, data) (nextDoseVal <- nextDoseRes$value) ## [1] 100 ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] myStopping1 <- StoppingMinPatients(nPatients = 30) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingPatientsNearDose(nPatients = 9, percentage = 20) myStopping <- myStopping1 | (myStopping2 & myStopping3) stopTrial(myStopping, nextDoseVal, samples, model, data) ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Number of patients is 12 and thus below the prespecified minimum number 30\" ##  ## attr(,\"message\")[[2]] ## attr(,\"message\")[[2]][[1]] ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ##  ## attr(,\"message\")[[2]][[2]] ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ##  ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Number of patients is 12 and thus below the prespecified minimum number 30\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ##  ## attr(,\"message\")[[2]] ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"report_label\") ## [1] NA mySize <- CohortSizeConst(3) mySizePL <- CohortSizeConst(1)  design <- Design(   model = model, nextBest = myNextBest,   stopping = myStopping, increments = myIncrements,   cohort_size = mySize, pl_cohort_size = mySizePL,   data = emptydata, startingDose = 25 ) set.seed(23) examine(design, mcmcOptions = options) ##    dose DLTs nextDose  stop increment ## 1    25    0       50 FALSE       100 ## 2    25    1       50 FALSE       100 ## 3    25    2       25 FALSE         0 ## 4    25    3       NA FALSE        NA ## 5    50    0      100 FALSE       100 ## 6    50    1       75 FALSE        50 ## 7    50    2       50 FALSE         0 ## 8    50    3       25 FALSE       -50 ## 9   100    0      125 FALSE        25 ## 10  100    1      100 FALSE         0 ## 11  100    2       75 FALSE       -25 ## 12  100    3       50 FALSE       -50 ## 13  125    0      175 FALSE        40 ## 14  125    1      125 FALSE         0 ## 15  125    2      100 FALSE       -20 ## 16  125    3       75 FALSE       -40 ## 17  175    0      250 FALSE        43 ## 18  175    1      150 FALSE       -14 ## 19  175    2      125 FALSE       -29 ## 20  175    3      100 FALSE       -43 ## 21  250    0      300 FALSE        20 ## 22  250    1      225 FALSE       -10 ## 23  250    2      175 FALSE       -30 ## 24  250    3      150 FALSE       -40 myTruth <- probFunction(model, alpha0 = 4.5, alpha1 = 8) doseProbMatrix <- cbind(c(1, 2, 3, 4, 5), c(0.01, 0.02, 0.04, 0.06, 0.09)) myTruthMatrix <-   function(dose) {     doseProbMatrix[match(dose, doseProbMatrix[, 1]), 2]   } mySimsTime <-   system.time(mySims <- simulate(design,     truth = myTruth, nsim = 100,     seed = 819, mcmcOptions = options,     parallel = FALSE   ))[3] mySims@data[[3]]@nObs ## [1] 32 mySims@doses[3] ## [1] 25 ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] simSum <- summary(mySims, truth = myTruth) simSum ## Summary of 100 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 47.9, 52.7  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients on placebo : mean 7 (6, 8)  ## Number of patients on active : mean 22 (18, 24)  ## Number of patients overall : mean 30 (24, 32)  ## Number of patients treated above target tox interval : mean 3 (0, 3)  ## Proportions of DLTs in the trials for patients on placebo : mean 0 % (0 %, 0 %)  ## Proportions of DLTs in the trials for patients on active : mean 28 % (21 %, 34 %)  ## Mean toxicity risks for the patients on active : mean 27 % (18 %, 33 %)  ## Doses selected as MTD : mean 46 (25, 50)  ## True toxicity at doses selected : mean 22 % (0 %, 26 %)  ## Proportion of trials selecting target MTD: 84 % ## Dose most often selected as MTD: 50  ## Observed toxicity rate at dose most often selected: 27 % ## Fitted toxicity rate at dose most often selected : mean 23 % (16 %, 29 %) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"dose-escalation-with-safety-and-efficacy","dir":"Articles","previous_headings":"Using crmPack","what":"Dose escalation with safety and efficacy","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"section, dose escalation designs incorporating safety (binary DLT) efficacy endpoints (continuous response) introduced. Dual endpoint datasets implemented DualData class, illustrate addition efficacy data w previous dataset: endpoints can modelled jointly separately. joint modelling derived (Bekele Shen 2005), please see package vignette DualEndpoint class. following section describe separate modelling, proposed (Yeung et al. 2015). show dual endpoint design can help estimate optimal dose level represents best trade-safety efficacy. Methodology Briefly introducing methodology current notation, assume dose grid \\(\\cal{X}\\) contains \\(k\\) dose levels, logistic regression model @\\(\\eqref{eq:LogisticLogNormal}\\) \\(x^{*}=1\\) used safety endpoint \\(y\\). continuous efficacy endpoint \\(w\\), linear log-log model can used, conditional \\(y=0\\) (DLT): \\[\\begin{equation}\\label{eq:loglog} E(w(x)) = \\gamma + \\delta \\log\\{\\log(x + c)\\} \\end{equation}\\] \\(w(x) \\sim N(E(w(x)), \\sigma^2)\\) \\(c \\geq 0\\) constant. Usually default value \\(c=0\\) can used, case choose \\(c=2\\) allow placebo dose \\(x=0.001\\) close 0. safety efficacy models, prior expressed form imaginary pseudo data see (Yeung et al. 2015) details. Prior posterior modal estimates model parameters can obtained maximum likelihood estimates data set combining pseudo data observed data (Whitehead 2006). variance \\(\\sigma^{2}\\) can fixed assigned inverse gamma prior distribution. Model classes ModelPseudo class contains model classes priors specified terms pseudo data, subclasses safety (ModelTox) efficacy (ModelEff). Coming back example study, pseudo data safety prior assumes 3 subjects treated lowest (25 mg) highest (300 mg) dose level, 1.05 1.8 DLTs observed two dose levels, respectively. corresponds prior means 0.35 0.6 DLT probabilities. implement model @\\(\\eqref{eq:LogisticLogNormal}\\) pseudo data prior follows: efficacy model can similarly specified argument Eff takes vector pseudo efficacy responses two fixed dose levels, assuming one subject treated dose levels. argument nu specifies Gamma prior distribution shape 1 rate 0.025 precision parameter pseudo efficacy responses. Decision making next dose gain function used quantify trade-efficacy safety, next dose maximize estimated gain modulo safety constraints. define gain expected efficacy response, convention DLT automatically lead zero efficacy response: \\[\\begin{equation} \\label{eq:gainfunction} G(x)=Prob(Y=0 | x, \\theta)E(w(x)) \\end{equation}\\] Note gain function depends safety parameter vector \\(\\theta\\) efficacy parameters \\(\\gamma\\) \\(\\delta\\), estimated posterior modal estimates using update method: crmPack can implement next best dose recommendation based maximizing gain function follows: prob_target_drt specifies maximum estimated DLT rate tolerated study prob_target_eot maximum estimated DLT rate tolerated end study. Implementing CRM trial rule \\(\\nu\\) can evaluated using NextBest obtain \\(x_{N+1}\\), evaluating maximum increments rule \\(\\tau\\) using maxDose obtain \\(t_{N+1}\\): plot next dose allocation contained doseRecGain$plot shown Figure @ref(fig:doseRecommendation). \\begin{figure} Dose recommendation plot dual endpoint design. red, blue green curves correspond (posterior modal) estimated curves safety, efficacy gain, respectively. vertical red line plot shows maximum possible dose \\(t_{N+1} = 150\\) mg vertical violet line shows next dose \\(x_{N+1} = 25\\) mg. circle, square triangle symbols mark estimated doses target toxicity (100 mg 35% DLT probability trial 75 mg 30% DLT probability end trial) estimated dose maximum gain, 25 mg. numbers can obtained doseRecGain list. Stopping rules addition simple stopping rule based maximum number patients trial, can use another one relating precision dose optimum gain: stops trial 30 patients reached, ratio upper lower confidence interval bounds around dose recommendation less  5. Simulations simulate operating characteristics, first design built: Note additional slot efficacy model included design class. can specify scenario simulation, defining true DLT efficacy curves using: Please note parameter names phi1, phi2, theta1 theta2 correspond \\(\\alpha_0, \\alpha_1, \\gamma\\) \\(\\delta\\), respectively. Simulations produced simulate function: Note fixed precision nu \\(1/\\sigma^{2}\\) specified instead variance \\(\\sigma^{2}\\). % results simulation can plotted summarized shown .","code":"data2 <- DataDual(   x = data@x, y = data@y, placebo = TRUE,   w = c(     0.02, 0.42, 0.59, 0.45, 0.03, 0.7, 0.6, 0.52,     0.01, 0.71, 0.54, 0.45   ), cohort = data@cohort,   doseGrid = data@doseGrid, ID = data@ID ) DLTmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8), DLEweights = c(3, 3),   DLEdose = c(25, 300), data = emptydata ) emptydata2 <- DataDual(doseGrid = emptydata@doseGrid, placebo = TRUE) Effmodel <- Effloglog(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025), data = emptydata2, c = 2 ) newDLTmodel <- update(object = DLTmodel, data = data2) newEffmodel <- update(object = Effmodel, data = data2) GainNextBest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) (nextMaxDose <- maxDose(myIncrements, data2)) ## [1] 150 doseRecGain <- nextBest(GainNextBest,   doselimit = nextMaxDose,   model = newDLTmodel, model_eff = newEffmodel,   data = data2 ) (nextDoseVal <- doseRecGain$next_dose) ## [1] 25 myStopping4 <- StoppingMaxGainCIRatio(   target_ratio = 5,   prob_target = GainNextBest@prob_target_eot ) myStoppingDual <- myStopping1 | myStopping4 design2 <- DualResponsesDesign(   nextBest = GainNextBest, model = DLTmodel,   eff_model = Effmodel, data = emptydata2,   stopping = myStoppingDual,   increments = myIncrements,   cohort_size = mySize, startingDose = 25 ) myTruthDLT <- probFunction(DLTmodel, phi1 = -53, phi2 = 10) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.8, theta2 = 3.7) myTruthGain <- function(dose) {   myTruthEff(dose) * (1 - myTruthDLT(dose)) } Sim1 <- simulate(   object = design2, args = NULL, trueDLE = myTruthDLT,   trueEff = myTruthEff, trueNu = 1 / 0.025, nsim = 20,   seed = 819, parallel = FALSE )"},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"extending-crmpack-functionality","dir":"Articles","previous_headings":"Using crmPack","what":"Extending crmPack functionality","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"One big advantages crmPack existing R implementations flexible framework based S4 classes methods system (Chambers 2008) JAGS (Plummer 2003) Bayesian computations. therefore illustrate users can extend existing functionality easily specific needs study. Objective example implement version one-parameter CRM (O’Quigley, Pepe, Fisher 1990), currently (yet) included package. based one-parameter power model describe relationship binary DLT responses \\(Y\\) corresponding dose levels \\(x\\): \\[\\begin{equation} \\label{eq:oneparameter} \\pi(x, \\theta) = Prob(Y=1 | x, \\theta) = f(x)^{\\theta} \\end{equation}\\] \\(0 < f(x) < 1\\) monotonically increasing \\(x\\) specified investigator upfront. sequence \\(f(x_{1}), \\dotsc, f(x_{k})\\) along dose grid often called ``skeleton’’ CRM. exponential distribution parameter \\(\\lambda\\) imposed prior distribution unknown parameter \\(\\theta\\). next dose chosen distance posterior mean estimated DLT probability predefined target toxicity level minimized. Creating new model implement one-parameter model @\\(\\eqref{eq:oneparameter}\\) crmPack first need define appropriate S4 class inheriting general model class GeneralModel: specify new class called OneParExp contains three additional slots containing resulting skeleton prior probabilities, dose grid, prior parameter \\(\\lambda\\). Second create convenient initialization function, specifies likelihood prior distributions underlying GeneralModel JAGS. choose let user supply just skeleton probabilities along intended dose grid use. likelihood power model specified datamodel uses Data slots specified datanames. prior defined priormodel. Model parameters passed JAGS via modelspecs. init slot contains function giving starting values MCMC sampler, sample defines parameter samples returned: Finally, create dose prob methods. prob method based (skeleton) function interpolation dose grid points order obtain probability DLT. dose, hand, uses inverse (skeleton) function \\[\\begin{equation} \\label{eq:oneparameterInverse} \\pi^{-1}(p, \\theta) = f^{-1}(p^{1/\\theta}) \\end{equation}\\] maps probability \\(p\\) dose \\(x\\). Now can already use model, example following specify skeleton probabilities via dose grid use standard exponential prior \\(\\theta\\). resulting posterior fit can plotted usual, see Figure @ref(fig:OneParExp-model-example). Model fit one parameter power model Creating new dose recommendation rule second step like create new dose recommendation rule, proposes dose estimated DLT probability closest target. start class, now inheriting NextBest: Note keep convention separate class definition initialization function, although technical need case. order make usable need define NextBest method new rule. Note specialize method first argument, rule also used models. method definition, can use fit function order obtain estimated DLT rates. need return list method, since required generic function definition. advantage also include plot supporting information return value. Immediately can now use rule order obtain next dose recommendation, e.g., specifying target dose 30%: using CRM, escalate 150 mg, instead just 100 mg . Using new functionality necessary additions code needed implement one-parameter CRM greedy next best dose rule - now can use new classes way classes already contained crmPack! example, can create corresponding new Design object, examine hypothetical trial course run simulations. particular, placebo convention automatically carries .","code":".OneParExp <- setClass(   Class = \"OneParExp\",   contains = \"GeneralModel\",   slots = c(     skeleton_probs = \"numeric\",     dose_grid = \"numeric\",     lambda = \"numeric\"   ) ) OneParExp <- function(skeleton_probs, dose_grid, lambda) {   .OneParExp(     skeleton_probs = skeleton_probs,     dose_grid = dose_grid,     lambda = lambda,     datamodel = function() {       for (i in 1:nObs) {         y[i] ~ dbern(p[i])         p[i] <- skeleton_probs[xLevel[i]]^theta       }     },     priormodel = function() {       theta ~ dexp(lambda)     },     modelspecs = function() {       list(skeleton_probs = skeleton_probs, lambda = lambda)     },     init = function() {       list(theta = 1)     }, sample = \"theta\",     datanames = c(\"nObs\", \"y\", \"xLevel\")   ) } setMethod(   f = \"dose\",   signature = signature(     x = \"numeric\",     model = \"OneParExp\",     samples = \"Samples\"   ),   definition = function(x, model, samples) {     theta <- samples@data$theta     invSkeletonFun <- approxfun(x = model@skeleton_probs, y = model@dose_grid, rule = 1)     invSkeletonFun(x^(1 / theta))   } )  setMethod(   f = \"prob\",   signature = signature(     dose = \"numeric\",     model = \"OneParExp\",     samples = \"Samples\"   ),   definition = function(dose, model, samples) {     theta <- samples@data$theta     skeletonFun <- approxfun(x = model@dose_grid, y = model@skeleton_probs, rule = 2)     skeletonFun(dose)^theta   } ) (skeleton_probs <- round(data@doseGrid / max(data@doseGrid) / 2, 2)) ##  [1] 0.00 0.04 0.08 0.12 0.17 0.21 0.25 0.29 0.33 0.38 0.42 0.46 0.50 newModel <- OneParExp(   skeleton_probs = skeleton_probs,   dose_grid = data@doseGrid,   lambda = 1 ) newSamples <- mcmc(data, newModel, options) plot(newSamples, newModel, data) .NextBestMinDist <- setClass(   Class = \"NextBestMinDist\",   contains = \"NextBest\",   representation(target = \"numeric\") ) NextBestMinDist <- function(target) {   .NextBestMinDist(target = target) } setMethod(   \"nextBest\",   signature = signature(     nextBest = \"NextBestMinDist\",     doselimit = \"numeric\",     samples = \"Samples\",     model = \"OneParExp\",     data = \"Data\"   ),   def = function(nextBest, doselimit, samples, model, data, ...) {     dosesOK <-       if (length(doselimit)) {         which(data@doseGrid <= doselimit)       } else {         seq_along(data@doseGrid)       }     modelfit <- fit(samples, model, data)     probDLT <- modelfit$middle[dosesOK]     doses <- modelfit$dose[dosesOK]     bestIndex <- which.min(abs(probDLT - nextBest@target))     bestDose <- doses[bestIndex]     return(list(value = bestDose))   } ) newMyNextBest <- NextBestMinDist(target = 0.3) newNextDoseVal <- nextBest(newMyNextBest, nextMaxDose, newSamples, newModel, data)$value newNextDoseVal ## [1] 150"},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"paper introduced R package crmPack analyzing evaluating dose escalation trials. Unlike existing software package written make full use class structure enabling easy extensions user-specific dose-response models, prior distributions, escalation stopping rules. example Extending crmPack functionality demonstrated : New functionality can added - without changing package. new functionality needs coded one place - side effects need considered. Templates new designs can found looking existing code package - minimal S4 JAGS knowledge required. Therefore, crmPack allows user easily extend package keeping modifications local limited needs changed, experience key success factor wider use model-based dose escalation designs. package , however, already include wide range model-based algorithmic dose escalation procedures, described package’s documentation available crmPackHelp() provide end-users easy access approaches without need coding. Another unique feature package inclusion approaches allow placebo data, routinely collected healthy volunteer studies, utilized. Finally methods [e.g.,](Bekele Shen 2005)(Yeung et al. 2015) dose-finding incorporating safety efficacy implemented already package. designs, underlying structure extend novel dual endpoint methods provided. Simulation facilities approaches relevant graphical displays also available. package actively developed new methods added. Future extensions crmPack include model-based combination dose escalation designs, see example (M. J. Sweeting Mander 2012) [Riviere et al. (2014) recent reviews. Furthermore, data-augmentation CRM designs [see](Liu Ning 2013) allow decoupling inter-cohort waiting times DLT time windows, hence speeding dose escalation trials, included.","code":""},{"path":"https://roche.github.io/crmPack/articles/crmPack-jss-paper.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"like thank Francesca Michielin Peter Dutton valuable comments earlier draft manuscript. report funded Roche Postdoctoral Fellowship programme (RPF-234) research arising Prof Jaki’s Senior Research Fellowship (NIHR-SRF-2015-08-001) supported National Institute Health Research. views expressed publication authors necessarily NHS, National Institute Health Research Department Health. manuscript prepared using knitr (Xie 2018).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"crmPack: Object-oriented implementation of CRM designs","text":"Many models crmPack rely JAGS (please click link going webpage project) internal MCMC computations. WinBUGS required supported anymore.","code":""},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"crmPack: Object-oriented implementation of CRM designs","text":"able run anything, load package browsing help pages package, easiest start web browser interface gives list help pages available package. whole R-package built modular form, using S4 classes methods. Please look help page “Methods” read introduction S4 object framework R, typing ?Methods R console. next sections therefore go one one important building blocks (S4 classes corresponding methods) CRM designs crmPack.","code":"library(crmPack) library(data.tree) crmPackHelp()"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"crmPack: Object-oriented implementation of CRM designs","text":"Data classes structure three data classes package. parent class GeneralData class. Data class inheriting GeneralData class DataDual class inheriting Data class. Inheritance means subclass slots (attributes) parent class, can also additional slots. Methods work parent class also work way subclass, unless specialized method subclass defined. First, set data set. beginning trial, observations available. can define empty data set, example: R-package crmPack uses S4 class system implementation dose-escalation designs. convention class initialization functions name class, class names capitalized. Note order create Data object, use initialization function name, give parameters contents object constructed. least doseGrid parameter, contains possible dose levels potentially used trial, must specified call Data() initialization function. middle trial like recommend next dose, data previous patients input model. data can also captured Data object. example: important x (doses) y (DLTs, 0 DLT 1 DLT), using dose grid doseGrid . computations using dose grid specified Data object. example, except patient number 7, patients free DLTs. , can find details help page Data-class. Note received warning , specify patient IDs – however, automatic ones just indexing patients created : can get visual summary data applying plot object:  Note plot calls vignette, can leave away wrapping print function call working interactively R. knitr production vignette print statement needed.","code":"df <- data.frame(   pathString = c(     \"GeneralData/Data/DataDual\"   ) )  tree <- as.Node(df) SetNodeStyle(tree, shape = \"box\") plot(tree) emptydata <- Data(   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) ## Used default patient IDs! data@ID ## [1] 1 2 3 4 5 6 7 8 print(plot(data))"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"structure-of-the-model-class","dir":"Articles","previous_headings":"","what":"Structure of the model class","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:model-classes) shows structure model class defined package. AllModels class parent class model classes inherit. two sub-classes: First, GeneralModel class models inherit using JAGS specify model prior distribution estimated MCMC later . , second subclass ModelPseudo class prior models specified terms pseudo data standard maximum likelihood routines R used computational purposes. models included package parent class either GeneralModel ModelPseudo classes. two classes ModelPseudo ModelTox class include DLT (occurrence dose-limiting toxicity) class models, class ModelEff includes efficacy class models. Model classes structure","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"logistic-model-with-bivariate-log-normal-prior","dir":"Articles","previous_headings":"Model setup","what":"Logistic model with bivariate (log) normal prior","title":"crmPack: Object-oriented implementation of CRM designs","text":"First, show example setting model inheriting model GeneralModel classes, logistic normal model. can click corresponding help page LogisticLogNormal-class background information next steps. following command, create new model class LogisticLogNormal, certain mean covariance prior parameters reference dose: can query class object belongs class function: can look detail structure model follows: see object 9 slots, names. can accessed @ operator (similarly lists $ operator), example can extract ref_dose slot: can find slots, looking help page Model-class help browser, univariate models JAGS specification just special cases (subclasses) model class. Model-class help page, also find four additional specific model classes sub-classes model class, namely LogisticLogNormalSub, LogisticNormal, LogisticKadane DualEndpoint. Next, show example setting model ModelPseudo class, LogisticIndepBeta model. specifically, also model ModelTox class. LogisticIndepBeta model two-parameter logistic regression model describe relationship probability occurrence DLT corresponding log dose levels. model parameters φ1, intercept φ 2, slope. also model prior expressed form pseudo data. important data set defined defining models ModelPseudo class. ensure obtained updated estimates model parameters using currently available observations. Either empty data set data set contains currently available observations needed. Therefore, let’s assume empty data set set . example, use 12 dose levels 25 300 mg increments 25 mg. : express prior form pseudo data. idea follows. First fix two dose level \\(d_{(-1)}\\) \\(d_{(0)}\\), usually lowest highest dose level, choose 25 300 mg. elicit experts clinicians probability occurrence DLT, \\(p_{(-1)}\\) \\(p_{(0)}\\) two dose levels. , assuming \\(n_{(l)}\\) subjects treated two dose levels, \\(l=-1,0\\), \\(t_{(l)}\\) \\(n{(l)}\\) subjects expected observed DLT \\(p_{(l)} = t_{(l)}/n_{(l)}\\). Let \\(\\tilde{p}_{(l)}\\) probability occurrence DLT dose \\(l\\) dose \\(l=-1,0\\). \\(\\tilde{p}_{(l)}\\) follow independent Beta distributions joint probability density function \\(p_{(l)}\\) can obtained. Therefore, model called LogisticIndepBeta. expressed prior data (pseudo data) trial start. prior modal estimates φ1 φ2, also equivalent maximum likelihood estimators, can obtained R function glm. Please refer (Whitehead Williamson 1998) details form prior posterior density model parameters φ1 φ2. following commands, create model class LogisticIndepBeta, prior specified form pseudo data. (Note functions including initialization function, DLE instead DLT used. vignette use unified abbreviation DLT throughout text variable names.) model specified, fixed two dose levels (25 300 mg) represented DLEdose slot. assume 3 subjects treated dose levels, represented DLEweights slot. 1.05 subjects 3 subjects treated 25 mg observed DLT 1.8 subjects 3 subjects treated 300 mg observed DLT represented binDLE slot. Input Data slot also need ensure currently available observations incorporated model obtain updated modal estimates model parameters. empty data set used Data slot, prior modal estimates model parameters, φ1 intercept φ2 slope, can obtained. data set observations, e.g data1 DLTmodel used, can obtain posterior modal estimates model parameters. addition, pseudo data can expressed using 2 dose levels. hand, least two dose levels pseudo information needed obtain modal estimates intercept slope parameter. Therefore, binDLE,DLEweights, DLEdose must vectors least length 2 corresponding values specified position two vectors. Since imaginary nature pseudo data, value \\(t_l\\) number subjects observed DLT can non-integer values. principle, \\(n_l\\) can also non-integer values. can look structure model: total 10 slots names given. Remember can accessed @ operator (similarly lists $ operator), example can extract phi1 slot: gives updated modal estimate intercept parameter φ1. Please find slots using @ operator looking help page ModelPseudo, ModelTox LogisticIndepBeta classes.","code":"model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 ) class(model) ## [1] \"LogisticLogNormal\" ## attr(,\"package\") ## [1] \"crmPack\" str(model) ## Formal class 'LogisticLogNormal' [package \"crmPack\"] with 9 slots ##   ..@ params         :Formal class 'ModelParamsNormal' [package \"crmPack\"] with 3 slots ##   .. .. ..@ mean: num [1:2] -0.85 1 ##   .. .. ..@ cov : num [1:2, 1:2] 1 -0.5 -0.5 1 ##   .. .. ..@ prec: num [1:2, 1:2] 1.333 0.667 0.667 1.333 ##   ..@ ref_dose       :Formal class 'positive_number' [package \"crmPack\"] with 1 slot ##   .. .. ..@ .Data: num 56 ##   ..@ datamodel      :function ()   ##   ..@ priormodel     :function ()   ##   ..@ modelspecs     :function (from_prior)   ##   ..@ init           :function ()   ##   ..@ datanames      : chr [1:3] \"nObs\" \"y\" \"x\" ##   ..@ datanames_prior: chr(0)  ##   ..@ sample         : chr [1:2] \"alpha0\" \"alpha1\" model@ref_dose ## An object of class \"positive_number\" ## [1] 56 emptydata <- Data(   doseGrid =     seq(from = 25, to = 300, by = 25) ) data1 <- emptydata DLTmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8), DLEweights = c(3, 3),   DLEdose = c(25, 300), data = data1 ) str(DLTmodel) ## Formal class 'LogisticIndepBeta' [package \"crmPack\"] with 7 slots ##   ..@ binDLE    : num [1:2] 1.05 1.8 ##   ..@ DLEdose   : num [1:2] 25 300 ##   ..@ DLEweights: int [1:2] 3 3 ##   ..@ phi1      : num -1.95 ##   ..@ phi2      : num 0.412 ##   ..@ Pcov      : num [1:2, 1:2] 10.05 -2.077 -2.077 0.462 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(x)\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(x)\" ##   ..@ data      :Formal class 'Data' [package \"crmPack\"] with 9 slots ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 DLTmodel@phi1 ## [1] -1.946152"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"advanced-model-specification","dir":"Articles","previous_headings":"Model setup","what":"Advanced model specification","title":"crmPack: Object-oriented implementation of CRM designs","text":", advanced ways specify model object crmPack. First, minimal informative prior (Neuenschwander, Branson, Gsponer 2008) can computed using MinimalInformative function. construction based input minimal maximal dose, certain ranges DLT probabilities deemed unlikely. logistic function fitted corresponding points dose-toxicity plane order derive Beta distributions also doses -. Finally Beta distributions approximated common LogisticNormal (LogisticLogNormal) model. minimal informative construction avoids explicit specification prior parameters logistic regression model. example, construct follows, assuming minimal dose 0.1 mg maximum dose 100 mg: use grid points minimum maximum guide approximation routine, based stochastic optimization method (control argument optimization routine, please see help page Quantiles2LogisticNormal details). Therefore need set random number generator seed beforehand able reproduce results future. Please note currently reproducibility testing– currently advised save approximation result order certainly able use model later . threshmin threshmax values specify probability thresholds , respectively, unlikely (5% probability) true probability DLT minimum maximum dose, respectively. result minInfModel list, can use contents illustrate creation prior:  plot see blue quantiles (2.5%, 50%, 97.5%) Beta distributions approximate red quantiles logistic normal model. see distance still quite large, maximum distance red blue point : Therefore usually let computations take longer (removing control option MinimalInformative call) obtain better approximation. final approximating model, produced red points, contained model list element: see slots mean, cov parameters determined. point slight warning: directly change parameters slots existing model object, parameters also saved invisibly places model object. Therefore, always use class initialization function create new model object, new parameters required. want use approximation model, can save shorter name, e.g.:","code":"coarseGrid <- c(0.1, 10, 30, 60, 100) minInfModel <- MinimalInformative(   dosegrid = coarseGrid,   refDose = 50,   threshmin = 0.2,   threshmax = 0.3,   control =     list(       threshold.stop = 0.03,       maxit = 200     ),   seed = 432 ) ## It: 1, obj value: 0.4445658384 ## It: 4, obj value: 0.3926736165 ## It: 23, obj value: 0.120574847 matplot(   x = coarseGrid,   y = minInfModel$required,   type = \"b\", pch = 19, col = \"blue\", lty = 1,   xlab = \"dose\",   ylab = \"prior probability of DLT\" ) matlines(   x = coarseGrid,   y = minInfModel$quantiles,   type = \"b\", pch = 19, col = \"red\", lty = 1 ) legend(\"right\",   legend = c(\"quantiles\", \"approximation\"),   col = c(\"blue\", \"red\"),   lty = 1,   bty = \"n\" ) minInfModel$distance ## [1] 0.1205748 str(minInfModel$model) ## Formal class 'LogisticNormal' [package \"crmPack\"] with 9 slots ##   ..@ params         :Formal class 'ModelParamsNormal' [package \"crmPack\"] with 3 slots ##   .. .. ..@ mean: Named num [1:2] 1.15 1.18 ##   .. .. .. ..- attr(*, \"names\")= chr [1:2] \"meanAlpha.(Intercept)\" \"meanBeta.I(log(dosegrid/refDose))\" ##   .. .. ..@ cov : num [1:2, 1:2] 3.895 0.269 0.269 0.142 ##   .. .. ..@ prec: num [1:2, 1:2] 0.295 -0.561 -0.561 8.13 ##   ..@ ref_dose       :Formal class 'positive_number' [package \"crmPack\"] with 1 slot ##   .. .. ..@ .Data: num 50 ##   ..@ datamodel      :function ()   ##   ..@ priormodel     :function ()   ##   ..@ modelspecs     :function (from_prior)   ##   ..@ init           :function ()   ##   ..@ datanames      : chr [1:3] \"nObs\" \"y\" \"x\" ##   ..@ datanames_prior: chr(0)  ##   ..@ sample         : chr [1:2] \"alpha0\" \"alpha1\" myModel <- minInfModel$model"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"obtaining-the-posterior","dir":"Articles","previous_headings":"","what":"Obtaining the posterior","title":"crmPack: Object-oriented implementation of CRM designs","text":"said , models inheriting GeneralModel class rely MCMC sampling obtaining posterior distribution model parameters, given data. models, except EffFlexi class model (please refer Dual-endpoint dose escalation designs details), inheriting ModelPseudo class necessarily require MCMC sampling obtain posterior estimates. MCMC sampling involved, prior posterior modal estimates model estimates used. can still obtain full posterior distribution model parameters via MCMC models specified ModelPseudo class. MCMC sampling can controlled object class mcmcOptions, created example follows: Now object options specifies like 2000 parameter samples obtained Markov chain starts burn-phase 100 iterations discarded, save sample every 2 iterations. Note numbers low actual production use used illustrating purposes ; normally specify least default parameters initialization function mcmcOptions: 10000 burn-iterations 10000 samples saved every 2nd iteration. can look help browser link McmcOptions. set options, can proceed MCMC sampling calling mcmc function: mcmc function takes data object, model MCMC options. default, JAGS used obtaining samples. Use option verbose = TRUE show progress bar detailed JAGS messages. Finally, good practice check graphically Markov chain really converged posterior distribution. end, crmPack provides interface convenient R-package ggmcmc. function get can extract individual parameters object class Samples. example, extract \\(\\alpha_{0}\\) samples: (please look help page LogisticLogNormal model class interpretation parameters) alpha0samples now contains \\(\\alpha_{0}\\) samples format understood ggmcmc can produce plots , e.g. trace plot autocorrelation plot:   see autocorrelation samples, might consider using higher thinning parameter order decrease . can find useful plotting functions package information: Similarly, using models ModelPseudo class, can also obtain prior posterior samples model parameters via MCMC. example, using DLTmodel, data1, empty data set options specified earlier examples. prior samples model parameters now saved variable DLTsamples. Similarly, DLTpostsamples now contains posterior samples model parameters. %Since output message seen example display MCMC sampling observed data involved, suppressMessages function used now throughout document avoid showing message document mcmc function also takes data object, model MCMC options. using JAGS just R computations. DLTmodel, obtain samples φ1 φ2. Using described earlier section , can also look structure using function str, extracting model parameters samples get produce plots ggs_traceplot ggs_autocorrelation model parameters. MCMC sampling involved, posterior modal estimates model parameters can obtained models (except EffFlexi class object) inheriting ModelPseudo class object. First need put together currently available observations form Data object (DLT responses modelled) texttt{DataDual} object (DLT efficacy responses modelled) class object. using update function update model, posterior modal estimates model parameters display output model. example, new observations specified data set data3 update DLT model: example, update function used obtain posterior modal estimates model parameters, φ1 φ2, can extracted using operator updated result newDLTmodel.","code":"options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options) ## look at the structure of the samples object: str(samples) ## Formal class 'Samples' [package \"crmPack\"] with 2 slots ##   ..@ data   :List of 2 ##   .. ..$ alpha0: num [1:2000] -0.431 -0.431 -0.431 -0.431 -1.57 ... ##   .. ..$ alpha1: num [1:2000] 0.577 0.577 0.577 0.577 0.496 ... ##   ..@ options:Formal class 'McmcOptions' [package \"crmPack\"] with 5 slots ##   .. .. ..@ iterations: int 4100 ##   .. .. ..@ burnin    : int 100 ##   .. .. ..@ step      : int 2 ##   .. .. ..@ rng_kind  : chr NA ##   .. .. ..@ rng_seed  : int NA ## now extract the alpha0 samples (intercept of the regression model) alpha0samples <- get(samples, \"alpha0\") library(ggmcmc) ## Loading required package: dplyr ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union ## Loading required package: tidyr ## Registered S3 method overwritten by 'GGally': ##   method from    ##   +.gg   ggplot2 print(ggs_traceplot(alpha0samples)) print(ggs_autocorrelation(alpha0samples)) help(package = \"ggmcmc\", help_type = \"html\") DLTsamples <- mcmc(data = data1, model = DLTmodel, options = options) data3 <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = as.integer(1:8),   cohort = c(1, 2, 2, 3, 4, 4, 5, 6),   doseGrid = seq(from = 25, to = 300, by = 25) ) DLTpostsamples <- mcmc(data = data3, model = DLTmodel, options = options) newDLTmodel <- update(object = DLTmodel, data = data3) newDLTmodel@phi1 ## [1] -5.070681 newDLTmodel@phi2 ## [1] 1.125107"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"plotting-the-model-fit","dir":"Articles","previous_headings":"","what":"Plotting the model fit","title":"crmPack: Object-oriented implementation of CRM designs","text":"obtained parameter samples, can plot model fit, supplying samples, model data generic plot function:  plot shows posterior mean curve 95% equi-tailed credible intervals point dose grid Data object. Note can also produce plot prior mean curve credible intervals, .e. model without data. works principle way data, just use empty data object:  plot function can also apply DLTmodel samples parameters generated:  addition, can also plot fitted dose-response curve using prior posterior modal estimates model parameters MCMC sampling used. example, DLTmodel specified earlier ModelTox class data set data1 specified earlier:  Since samples involved, curve using prior posterior modal estimates parameters produced, without 95% credibility intervals.","code":"print(plot(samples, model, data)) ## provide only the dose grid: emptydata <- Data(doseGrid = data@doseGrid) ## obtain prior samples with this Data object priorsamples <- mcmc(emptydata, model, options) ## then produce the plot print(plot(priorsamples, model, emptydata)) print(plot(DLTsamples, DLTmodel, data1)) print(plot(data1, DLTmodel))"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"escalation-rules","dir":"Articles","previous_headings":"","what":"Escalation Rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"dose escalation, four kinds rules: Increments: specifying maximum allowable increments doses NextBest: derive next best dose CohortSize: specifying cohort size Stopping: Stopping rules finishing dose escalation listed classes rules, multiple subclasses , can find links help pages Increments-class, NextBest-class, CohortSize-class Stopping-class.","code":""},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"increments-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Increments rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:increments) shows structure Increments classes: Increments classes structure Increments class basis maximum increments rule classes within package. three subclasses, IncrementsRelative, IncrementsRelativeParts IncrementsRelativeDLTs classes. Let us start looking detail increments rules. Currently two specific rules implemented: Maximum relative increments based current dose (IncrementsRelative IncrementsRelativeParts, works DataParts objects), maximum relative increments based current cumulative number DLTs happened (IncrementsRelativeDLT). example, order specify maximum increase 100% doses 20 mg, maximum 33% doses 20 mg, can setup following increments rule: intervals slot specifies left bounds intervals, maximum relative Increments (note: decimal values , percentages!) valid. increments rule used maxDose function obtain maximum allowable dose given current data: case, next dose larger 20 mg. following example dose escalation restricted 3-fold (= 200%) increase: doses (since dose grid starts 25 mg) maximum increase 200% . IncrementsRelativeDLT class works similarly, taking number DLTs whole trial far basis maximum increments instead last dose.","code":"myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements,   data = data ) nextMaxDose ## [1] 20 myIncrements1 <- IncrementsRelative(   intervals = c(25),   increments = c(2) )"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"rules-for-next-best-dose-recommendation","dir":"Articles","previous_headings":"Escalation Rules","what":"Rules for next best dose recommendation","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:rules) show structure next best dose recommendation rules currently implemented crmPack. Escalation classes structure classes escalation rules contained nextBest class. two main types escalation rules: either binary DLT responses incorporated escalation process, binary DLT continuous efficacy/biomarker response jointly incorporated escalation process. two implemented rules toxicity endpoint CRMs inheriting GeneralModel class: NextBestMTD uses posterior distribution MTD estimate (given target toxicity probability defining MTD), nextBestCRM implements N-CRM, using posterior probabilities target-dosing overdosing dose grid points recommend next best dose. example, order use N-CRM target toxicity interval 20% 35%, maximum overdosing probability 25%, specify: Alternatively, use MTD driven recommendation rule. example, target toxicity rate 33%, recommending 25% posterior quantile MTD, specify Note NextBestMTD class quite flexible, can specify function derive derives next best dose posterior MTD samples. also two next best dose recommendation rules model inheriting ModelTox class. One rule specified samples model parameters involved one samples model parameters generated incorporated dose-escalation procedure. details rules follows. First, two probabilities occurrence DLT fixed. first one called targetDuringTrial target probability occurrence DLT used trial. second probability called targetEndOfTrial target probability occurrence DLT used end trial. two targets always specified. cases samples involved, additional argument used, function advise recommend using samples . elaborated details example . example, fixed target probability occurrence DLT used trial 0.35. means allow subjects dose levels probability DLT closest less equal 0.35 trial. end trial, therefore recommend dose level closest probability DLT less equal 0.3. NextBestTD rule class can used samples involved escalation procedure. Next show example NextBestTDsamples rule class samples involved escalation process. slot targetDuringTrial targetEndOfTrial specified way last example given value 0.35 0.3, respectively. derive slot always specified function. example, using function specified derive slot says recommend 30% posterior quantiles samples estimates doses corresponding targetDuringTrial targetEndOfTrial doses. study, order derive next best dose, supply generic nextBest function rule, maximum dose, posterior samples, model data: result list two elements: value contains numeric value recommended next best dose, plot contains plot illustrates next best dose computed. case used N-CRM rule, therefore plot gives target-dosing overdosing probabilities together safety bar 25%, maximum dose final recommendation (red triangle): Similarly, can use generic nextBest function theNextBestTD NextBestTDsamples rules. example use data set data3 DLT observations. can compute next best dose given next cohort using posterior modal estimates DLT model (.e., MCMC sampling involved ): list numerical values plot showing next best dose computed given. list results provide numerical values next dose level, next_dose_drt; target probability DLT used trial, prob_target_drt; estimated dose level probability DLT equals target probability used trial, dose_target_drt; target probability DLT used end trial, prob_target_eot; estimated dose level probability DLT equals target probability DLT used end trial dose_target_eot; dose level dose grid closest less dose_target_eot, next_dose_eot. can use $ operator obtain values plot list. example,  can see next dose suggested given next cohort subjects 50 mg. target probability DLT trial 0.35 TD35 (tolerated dose probability DLT equal 0.35) estimated 52.28 mg. using 12 dose levels dose grids 25 mg 300 mg increments 25 mg data set, data3, can see suggested next dose 50 mg also dose level closest 52.28 mg, estimated dose_target_drt. Similarly, end trial also obtain “End Trial” estimates using $ operator. addition, also plot show next dose allocation. red curve shows estimated DLT curve obtained using posterior modal estimates model parameters. also assumed maximum allowable dose 300 mg specified doselimit parameter nextBest function call red vertical line denoted “Max” shows maximum dose level (x-axis) allowed case. vertical purple line denoted “Next” marks dose level allocated next cohort subjects. example, target probability DLT used trial end trial 0.35 0.3, respectively. circle square DLT curve show probability DLT estimated equal 0.3 0.35, respectively. Hence, value estimated TD30 TD35 can checked x-axis vertically symbols. MCMC sampling involved, use samples model parameters choose next best dose. example, following code chunk use data set, data3, DLT observations posterior samples model parameters, DLTpostsamples compute next best dose: list results produced example : values next_dose_drt, prob_target_drt, dose_target_drt, prob_target_eot, dose_target_eot next_dose_eot can obtained using $ operator. difference plot example look slightly different previous example: > graph incorrect plot, vertical lines given show value next dose, TD30 estimate, TD35 estimate maximum allowable dose level. Since samples model parameters utilized, density curves TD30 (pink) TD35 (grey) plotted.","code":"myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) mtdNextBest <- NextBestMTD(   target = 0.33,   derive =     function(mtd_samples) {       quantile(mtd_samples, probs = 0.25)     } ) TDNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) TDsamplesNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples, model = model, data = data ) doseRecommendation$value ## [1] 20 print(doseRecommendation$plot) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] doseRecDLT <- nextBest(TDNextBest, doselimit = 300, model = newDLTmodel, data = data3) doseRecDLT$next_dose_drt ## [1] 50 doseRecDLT$prob_target_drt ## [1] 0.35 doseRecDLT$dose_target_drt ## [1] 52.28128 print(doseRecDLT$plot) doseRecDLTSamples <- nextBest(TDsamplesNextBest,   doselimit = 300,   samples = DLTpostsamples, model = newDLTmodel,   data = data3 ) print(doseRecDLTSamples$plot) ## Warning: Some data points are outside of `bounds`. Removing them. ## Some data points are outside of `bounds`. Removing them."},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"cohort-size-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Cohort size rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"CohortSize classes structure % classes related cohort size package contains within CohortSize class. Similarly increments rules, can define intervals dose space /DLT space define size cohorts. example, let’s assume want one patient cohorts reach 30 mg first DLT encountered, proceed three patients per cohort. start creating two separate rules, first dose range: DLT range: Finally combine two rules taking maximum number patients rules: CohortSize rule used size}` function, together next dose current data, order determine size next cohort: , one DLT already, go 3 patients next cohort. Moreover, like constant cohort size, can use following CohortSizeConst class, use (three patients) simplicity remainder vignette:","code":"df <- data.frame(   pathString = c(     \"CohortSize/CohortSizeRange\",     \"CohortSize/CohortSizeDLT\",     \"CohortSize/CohortSizeConst\",     \"CohortSize/CohortSizeParts\",     \"CohortSize/CohortSizeMax\",     \"CohortSize/CohortSizeMin\"   ) )  tree <- as.Node(df) SetNodeStyle(tree, shape = \"box\") plot(tree) mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3)) mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3)) mySize <- maxSize(mySize1, mySize2) size(mySize,   dose = doseRecommendation$value,   data = data ) ## [1] 3 mySize <- CohortSizeConst(size = 3)"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"stopping-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Stopping rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"stopping rules classes inherit directly Stopping class. total 9 stopping rules, listed follows: StoppingCohortNearDose StoppingPatientsNearDose StoppingMinCohorts StoppingMinPatients StoppingTargetProb StoppingMTDdistribution StoppingTargetBiomarker StoppingTDCIRatio StoppingMaxGainCIRatio names stopping rules, can idea criteria used stopping decisions explain briefly criteria. details please refer examples presented later vignette examples given help pages. can find link implemented stopping rule parts help page Stopping-class. example, StoppingCohortNearDose class objects can used stop dose escalation based numbers cohorts treated near next best dose (required proximity given percentage relative deviation next best dose). Similarly, StoppingPatientsNearDose, stopping based number patients treated near next best dose. StoppingMinCohorts StoppingMinPatients rules can used stop dose escalation minimum overall number patients cohorts enrolled. also stopping rules trial stopped either based MTD distribution (StoppingMTDdistribution), reached pre-specified probability next dose target toxicity interval (StoppingTargetProb) target biomarker interval (StoppingTargetBiomarker) current estimate quantity interest ‘accurate’ enough (StoppingTDCIRatio StoppingMaxGainCIRatio) Stopping rules often quite complex, built “/” combinations multiple parts. Therefore crmPack implementation mirrors , multiple atomic stopping rules can combined easily. example, let’s assume like stop trial least 3 cohorts least 50% probability target toxicity interval \\((20%, 35%)\\), maximum sample size 20 patients reached. start creating three pieces rule composed : Finally combine operator & operator |: can also stop trial current estimate quantity interest, TD30 given earlier examples, ‘accurate’ enough. accuracy current estimate TD30 quantified width associated 95% credibility interval. wider interval, less accurate estimate . particular, ratio upper lower limit 95% credibility interval used. smaller ratio, accurate estimate. example, stop trial obtain ratio less 5 95% credibility interval TD30 estimate case, deciding obtained estimate ‘accurate’ enough. StoppingTDCIRatio function can used cases DLT samples DLT samples involved: two examples, targetRatio targetEndOfTrial specified. dose escalation study, (atomic combined) stopping rule can used function stopTrial determine rule already fulfilled. example case: receive FALSE, means stopping rule criteria met. attribute message contains textual results atomic parts stopping rule. can read probability target toxicity just 30% recommended dose 20 mg therefore low, also maximum sample size reached, therefore trial shall continue. way stopping rule myStopping4 (samples samples) can evaluated: DLT samples DLT samples involved. Note moment operator & operator | used together StoppingTDCIRatio class objects. still development.","code":"myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3 myStopping4 <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) stopTrial(   stopping = myStopping, dose = doseRecommendation$value,   samples = samples, model = model, data = data ) ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## attr(,\"message\")[[1]][[1]] ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ##  ## attr(,\"message\")[[1]][[2]] ## [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" ##  ##  ## attr(,\"message\")[[2]] ## [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ##  ## attr(,\"message\")[[2]] ## [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] TRUE ## attr(,\"message\") ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"report_label\") ## [1] NA stopTrial(   stopping = myStopping4, dose = doseRecDLTSamples$next_dose_drt,   samples = DLTpostsamples, model = newDLTmodel, data = data3 ) ## [1] FALSE ## attr(,\"message\") ## [1] \"95% CI is (0.000611274483578011, 10459.1345133637), Ratio = 17110373.1537 is greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] NA stopTrial(   stopping = myStopping4, dose = doseRecDLT$next_dose_drt,   model = newDLTmodel, data = data3 ) ## [1] FALSE ## attr(,\"message\") ## [1] \"95% CI is ( 11.0662 , 164.618 ), Ratio = 14.8758 is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] NA"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"simulations","dir":"Articles","previous_headings":"","what":"Simulations","title":"crmPack: Object-oriented implementation of CRM designs","text":"order run simulations, first build specific design, comprises model, escalation rules, starting data, cohort size starting dose. Design classes structure might seem strange first sight supply starting data design, show makes sense. First, use emptydata object contains dose grid, cohorts 3 patients, starting 0.1 mg: Another example given TDDesign class used. empty data set, data1 used, starting dose 25 mg. code design defined MCMC sampling involved. nextBest slot TDDesign class function defined TDNextBest class object ensure pick next best dose using rules defined MCMC sampling involved. addition, define myStopping4 trial stop ratio 95% credibility interval limits current estimate TD30 (TDtargetEndOfTrial) less equal 5. addition, also use myIncrements1, mySize data1 defined earlier examples increments, cohort_size data slots defining TDDesign object: MCMC samples involved, also specify design ensure package run simulations using MCMC samples model parameters models specified ModelPseudo class object. example, TDsamplesDesign class object used TDsamplesNextBest class object nextBest slot ensure MCMC sampling involved design. also apply stopping rule myStopping4 myStopping3 trial stop either ratio 95% credibility interval limits current estimate TD30 (TDtargetEndOfTrial) less equal 5 (myStopping4) maximum 30 patients enrolled trial (myStopping3):","code":"design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 ) DLTdesign <- TDDesign(   model = DLTmodel,   nextBest = TDNextBest,   stopping = myStopping4,   increments = myIncrements1,   cohort_size = mySize,   data = data1,   startingDose = 25 ) DLTsamplesDesign <- TDsamplesDesign(   model = DLTmodel,   nextBest = TDsamplesNextBest,   stopping = (myStopping4 | myStopping3),   increments = myIncrements1,   cohort_size = mySize,   data = data1,   startingDose = 25 )"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"examining-single-trial-behavior","dir":"Articles","previous_headings":"Simulations","what":"Examining single trial behavior","title":"crmPack: Object-oriented implementation of CRM designs","text":"looking “many trials” operating characteristics, important look “single trial” operating characteristics dose escalation design. , crmPack provides function examine, generates data.frame showing beginning several hypothetical trial courses design. Assuming DLTs seen certain dose, consequences different number DLTs observed dose shown. current example Note important set seed, since minor changes might occur due sampling variations. However, mcmcOptions parameter chosen order minimize variation. default setting, used implicitly call, normally sufficient, checking (running function twice different seeds comparing results) important. resulting data frame gives dose cohort DLTs observed, number DLTs, resulting next dose recommendation, whether design stop, relative increment next dose compared current dose percentage. Note cohort size rules taken account examine. NA entries mean design stop without valid dose, since doses considered toxic observing number DLTs dose.","code":"set.seed(23) examine(design) ##    dose DLTs nextDose  stop increment ## 1     3    0      6.0 FALSE       100 ## 2     3    1      3.0 FALSE         0 ## 3     3    2      0.1 FALSE       -97 ## 4     3    3       NA FALSE        NA ## 5     6    0     12.0 FALSE       100 ## 6     6    1     12.0 FALSE       100 ## 7     6    2      3.0 FALSE       -50 ## 8     6    3      1.5 FALSE       -75 ## 9    12    0     24.0 FALSE       100 ## 10   12    1     24.0 FALSE       100 ## 11   12    2     14.0 FALSE        17 ## 12   12    3      6.0 FALSE       -50 ## 13   24    0     30.0 FALSE        25 ## 14   24    1     30.0 FALSE        25 ## 15   24    2     26.0 FALSE         8 ## 16   24    3     18.0 FALSE       -25 ## 17   30    0     38.0 FALSE        27 ## 18   30    1     38.0 FALSE        27 ## 19   30    2     34.0 FALSE        13 ## 20   30    3     26.0 FALSE       -13 ## 21   38    0     50.0 FALSE        32 ## 22   38    1     50.0 FALSE        32 ## 23   38    2     42.0 FALSE        11 ## 24   38    3     34.0 FALSE       -11 ## 25   50    0     58.0  TRUE        16 ## 26   50    1     56.0  TRUE        12 ## 27   50    2     50.0  TRUE         0 ## 28   50    3     44.0  TRUE       -12"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"simulating-from-a-true-scenario","dir":"Articles","previous_headings":"Simulations","what":"Simulating from a true scenario","title":"crmPack: Object-oriented implementation of CRM designs","text":"“many trials” operating characteristics, define true scenario, data arise. case, requires function computes probability DLT given dose. use specific case function contained model space:  similar way, can also simulate trials based true DLT scenario using TDDesign TDsamplesDesign. First, specified true DLT scenario  true DLT scenario used TDDesign TDsamplesDesign Now can proceed simulations. generate 100 trial outcomes illustration, actual study increased course least 500: wrapped call simulate system.time obtain required time simulations (119 seconds case). argument args contain additional arguments truth function, require therefore let default NULL. specify number simulations nsim random number generator seed seed. Note also pass MCMC options object, trial simulations MCMC routines used. Finally, argument parallel can used enable use processors computer running simulations parallel. can yield meaningful speedup, especially larger number simulations. (almost) always, result call object class, case Simulations: help page see class subclass GeneralSimulations class. looking help pages Simulations parent class GeneralSimulations, can find description slots mySims. particular, Data slot contains list produced Data objects simulated trials. Therefore, can plot course e.g. third simulated trial follows:  final dose trial stopping reason Furthermore, object, can apply two methods. First, can plot , .e. can apply plot method: resulting plot shows top panel summary trial trajectories. bottom, proportions doses tried, averaged simulated trials, shown. Note can select plots changing type argument plot, default type =   c(\"trajectory\", \"dosesTried\"). Second, can summarize simulation results. supply true dose-toxicity function. take (myTruth) : Note sometimes observed toxicity rate dose often selected (20 mg) available, can happen patients actually treated dose simulations. (available.) illustrates MTD can selected based evidence data dose levels – advantage model-based dose-escalation designs. Now can also produce plot summary results, gives bit detail textual summary just seen: top left panel shows distribution sample size across simulated trials. case trials 15 21 patients. top right panel shows distribution final MTD estimate / recommended dose across simulated trials. middle left panel shows distribution across simulations DLT proportions observed patients dosed. trials 20 30% patients DLTs. middle right panel shows distribution across simulations number patients treated target toxicity window (used default 20% 35%). Finally, bottom panel see comparison true dose-toxicity curve (black) estimated dose-toxicity curves, averaged (continuous red line) across trials 95% credible interval across trials. see steep true dose-toxicity curve recovered model fit. find e.g. top right plot distribution final selected doses small shows right x-axis window, can plot one add x-axis customization top: (see ggplot2 documentation information customizing plots)  examples given simulations using TDDesign TDsamplesDesign classes. illustration purpose, generate 10 trial outcomes. example MCMC sampling involved another example simulation MCMC sampling involved: meaning arguments defined explained simulate example Design class. % slots args specify additional arguments truth function, truth real DLT scenario simulate responses , nsim number simulations, seed, random generator seed parallel specify whether parallel computing used running simulations. Similarly, results individual simulations can obtained graphically using plot function. dose level recommendation dose levels closest final estimated TD30 (final estimates dose level probability DLT equals target end trial) overall results 100 trials two simulations can also plotted show trial trajectories proportion doses level tried. simulation results can also summarized using summary function given truth: can also plot summary two simulations using plot function: ","code":"## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  ## plot it in the range of the dose grid curve(myTruth(x), from = 0, to = 80, ylim = c(0, 1)) ## define the true function TrueDLT <- probFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499)  ## plot it in the range of the dose grid curve(TrueDLT, from = 25, to = 300, ylim = c(0, 1)) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 100,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3] time ## elapsed  ## 119.455 class(mySims) ## [1] \"Simulations\" ## attr(,\"package\") ## [1] \"crmPack\" help(\"Simulations-class\", help = \"html\") ## starting httpd help server ... done print(plot(mySims@data[[3]])) mySims@doses[3] ## [1] 22 mySims@stop_reasons[[3]] ## [[1]] ## [[1]][[1]] ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ##  ## [[1]][[2]] ## [1] \"Probability for target toxicity is 52 % for dose 22 and thus above the required 50 %\" ##  ##  ## [[2]] ## [1] \"Number of patients is 18 and thus below the prespecified minimum number 20\" print(plot(mySims)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] summary(mySims,   truth = myTruth ) ## Summary of 100 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 19 (18, 21)  ## Number of patients treated above target tox interval : mean 7 (6, 9)  ## Proportions of DLTs in the trials : mean 26 % (22 %, 33 %)  ## Mean toxicity risks for the patients on active : mean 25 % (16 %, 35 %)  ## Doses selected as MTD : mean 20.7 (16, 26)  ## True toxicity at doses selected : mean 31 % (5 %, 70 %)  ## Proportion of trials selecting target MTD: 19 % ## Dose most often selected as MTD: 18  ## Observed toxicity rate at dose most often selected: 9 % ## Fitted toxicity rate at dose most often selected : mean 24 % (19 %, 29 %) simSum <- summary(mySims,   truth = myTruth ) print(plot(simSum)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] dosePlot <- plot(simSum, type = \"doseSelected\") +   scale_x_continuous(breaks = 10:30, limits = c(10, 30)) ## Scale for x is already present. ## Adding another scale for x, which will replace the existing scale. print(dosePlot) DLTSim <- simulate(DLTdesign,   args = NULL,   truth = TrueDLT,   nsim = 10,   seed = 819,   parallel = FALSE ) DLTsampSim <- simulate(DLTsamplesDesign,   args = NULL,   truth = TrueDLT,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE ) DLTSim@doses[3] ## [1] 100 DLTsampSim@doses[3] ## [1] 100 print(plot(DLTSim)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] print(plot(DLTsampSim)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] summary(DLTSim,   truth = TrueDLT ) ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 16 (15, 18)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (3, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 3 (3, 3)  ## Proportions of observed DLT in the trials : mean 21 % (20 %, 22 %)  ## Mean toxicity risks for the patients : mean 20 % (17 %, 21 %)  ## Doses selected as TDEOT : mean 100 (100, 100)  ## True toxicity at TDEOT : mean 1 % (1 %, 1 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 24 % (24 %, 25 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    117.3   120.1   123.8   122.0   123.8   123.8   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    4.054   4.157   4.447   4.330   4.447   4.447   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    137.5   140.7   144.4   142.5   144.4   144.4   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    117.3   120.1   123.8   122.0   123.8   123.8   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    4.054   4.157   4.447   4.330   4.447   4.447 summary(DLTsampSim,   truth = TrueDLT ) ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 21 (21, 21)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 1 (0, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 1 (0, 3)  ## Proportions of observed DLT in the trials : mean 10 % (5 %, 14 %)  ## Mean toxicity risks for the patients : mean 6 % (1 %, 10 %)  ## Doses selected as TDEOT : mean 100 (75, 125)  ## True toxicity at TDEOT : mean 2 % (0 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 22 % (18 %, 26 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    97.28  100.35  115.37  114.40  125.23  135.76   ## The summary table of the final ratios of the TDEOT across all simulations ##       Min.   1st Qu.    Median      Mean   3rd Qu.      Max.   ##  1.000e+01 6.800e+01 4.079e+06 5.241e+11 1.917e+11 3.806e+12   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    118.8   122.2   144.9   143.3   161.5   170.3   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    97.28  100.35  115.37  114.40  125.23  135.76   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##       Min.   1st Qu.    Median      Mean   3rd Qu.      Max.   ##  1.000e+01 6.800e+01 4.079e+06 5.241e+11 1.917e+11 3.806e+12 DLTsimSum <- summary(DLTSim,   truth = TrueDLT ) print(plot(DLTsimSum)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] DLTsimsampSum <- summary(DLTsampSim,   truth = TrueDLT ) print(plot(DLTsimsampSum)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"predicting-the-future-course-of-the-trial","dir":"Articles","previous_headings":"Simulations","what":"Predicting the future course of the trial","title":"crmPack: Object-oriented implementation of CRM designs","text":"simulating parameters current posterior distribution instead assumed true scenario, possible generate trial simulations posterior predictive distribution time point trial. means can predict future course trial, given current data. illustrating example, work follows. rationale simulate call now specify truth argument prob function assumed model. simulations, arguments internally given values contained data frame given simulate args argument. case, want supply posterior samples alpha0 alpha1 data frame. take 50 2000 posterior samples order reduce runtime example: Therefore, simulated trial come posterior sample estimated model, given data far. Furthermore make new Design object contains current data start , current recommended dose starting dose: Finally can execute simulations: now, exactly way operating characteristics simulations, can summarize resulting predictive simulations, example show predicted trajectories doses: summary, need look characteristics involving true dose-toxicity function, case intending compare performance CRM relative truth: see e.g. estimated number patients overall 19, 11 current 8 patients expected needed finishing trial.","code":"postSamples <- as.data.frame(samples@data)[(1:20) * 50, ] postSamples ##           alpha0    alpha1 ## 50    0.74470938 0.8275603 ## 100  -0.19605820 0.6185270 ## 150  -0.54569621 0.7520255 ## 200   0.07149366 2.8515946 ## 250  -0.39253493 0.6282573 ## 300   0.99285102 1.6296029 ## 350   0.87763801 1.2731626 ## 400   0.04230585 1.3611502 ## 450  -0.38709302 1.1547978 ## 500   1.13890360 1.1713048 ## 550  -0.67575228 0.8127218 ## 600  -0.32596011 2.5321117 ## 650   0.53929820 1.3893484 ## 700  -0.31620906 1.1723690 ## 750   0.75020145 1.2255952 ## 800   0.79372212 0.6795673 ## 850  -0.86020004 0.6082518 ## 900   0.60763512 2.1367179 ## 950   0.02224223 1.1944404 ## 1000 -1.00864534 0.9778690 nowDesign <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   ## use the current data:   data = data,   ## and the recommended dose as the starting dose:   startingDose = doseRecommendation$value ) time <- system.time(futureSims <- simulate(   ## supply the new design here   nowDesign,   ## the truth is the assumed prob function   truth = function(dose, alpha0, alpha1) {     samples <- Samples(       data = list(alpha0 = alpha0, alpha1 = alpha1),       options = McmcOptions(samples = 1)     )     prob(dose, model, samples)   },   ## further arguments are the   ## posterior samples   args = postSamples,   ## do exactly so many simulations as   ## we have samples   nsim = nrow(postSamples),   seed = 918,   ## this remains the same:   mcmcOptions = options,   parallel = FALSE ))[3] time ## elapsed  ##  13.825 print(plot(futureSims)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] summary(futureSims,   truth = myTruth ) ## Summary of 20 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 19 (17, 20)  ## Number of patients treated above target tox interval : mean 3 (0, 6)  ## Proportions of DLTs in the trials : mean 22 % (12 %, 30 %)  ## Mean toxicity risks for the patients on active : mean 17 % (4 %, 31 %)  ## Doses selected as MTD : mean 21.2 (10, 36.2)  ## True toxicity at doses selected : mean 34 % (0 %, 97 %)  ## Proportion of trials selecting target MTD: 5 % ## Dose most often selected as MTD: 18  ## Observed toxicity rate at dose most often selected: 15 % ## Fitted toxicity rate at dose most often selected : mean 26 % (14 %, 36 %)"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"simulating-33-design-outcomes","dir":"Articles","previous_headings":"","what":"Simulating 3+3 design outcomes","title":"crmPack: Object-oriented implementation of CRM designs","text":"crmPack focuses model-based dose-escalation designs, also includes 3+3 design order allow convenient comparisons. Note actually simulations required 3+3 design, possible outcomes can enumerated, however still rely simulations consistency overall crmPack design. easiest way setup 3+3 design function ThreePlusThreeDesign: used much coarser dose grid model-based design , 3+3 design jump doses. starting dose automatically chosen first dose grid. outcome RuleDesign object, setup options directly use RuleDesign() initialization function. can simulate trials, assuming myTruth function gives true dose-toxicity relationship: model-based design, can summarize simulations: see mg dose often selected MTD, actually low comparing narrow target dose interval going mg. inherent problem dose-escalation designs dose grid coarse: might know starting trial range need refined dose grid. case obtain doses low, one can see average true toxicity ~% doses selected. Graphical summaries obtained calling plot summary object:","code":"threeDesign <- ThreePlusThreeDesign(doseGrid = c(5, 10, 15, 25, 35, 50, 80)) class(threeDesign) ## [1] \"RuleDesign\" ## attr(,\"package\") ## [1] \"crmPack\" threeSims <- simulate(threeDesign,   nsim = 1000,   seed = 35,   truth = myTruth,   parallel = FALSE ) threeSimsSum <- summary(threeSims,   truth = myTruth ) threeSimsSum ## Summary of 1000 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 16 (15, 18)  ## Number of patients treated above target tox interval : mean 4 (3, 6)  ## Proportions of DLTs in the trials : mean 17 % (13 %, 22 %)  ## Mean toxicity risks for the patients on active : mean 17 % (14 %, 22 %)  ## Doses selected as MTD : mean 15.2 (15, 15)  ## True toxicity at doses selected : mean 4 % (3 %, 3 %)  ## Proportion of trials selecting target MTD: 0 % ## Dose most often selected as MTD: 15  ## Observed toxicity rate at dose most often selected: 3 % print(plot(threeSimsSum)) ## TableGrob (2 x 2) \"arrange\": 4 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] ## 3 3 (2-2,1-1) arrange gtable[layout] ## 4 4 (2-2,2-2) arrange gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"dual-endpoint-dose-escalation-designs","dir":"Articles","previous_headings":"","what":"Dual-endpoint dose escalation designs","title":"crmPack: Object-oriented implementation of CRM designs","text":"section, look dose-escalation procedures included package two end points incorporated study. first endpoint binary DLT response discussed already last sections. second endpoint continuous biomarker/efficacy response. package, can either model two responses jointly (using single model class, assuming correlation) separately (using two separate model classes, assuming correlation). Now first describe model two responses jointly.","code":""},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"dual-endpoint-designs-with-a-joint-model","dir":"Articles","previous_headings":"Dual-endpoint dose escalation designs","what":"Dual-endpoint designs with a joint model","title":"crmPack: Object-oriented implementation of CRM designs","text":"disclaimer, please note designs section still development, far yet published. Therefore please consider experimental. help page DualEndpoint-class general joint model structure described. Basically idea (single) biomarker variable second endpoint dose-escalation design, aim maximize biomarker response controlling toxicity safe range. useful can assumed just increasing dose always lead better efficacy. Let’s look data structure. example: corresponding plot can obtained : see seems maximum biomarker response around 10 mg already. order model data, consider dual-endpoint model first-order random-walk (RW1) structure dose-biomarker relationship: use smoothing parameter \\(\\sigma^{2}_{\\beta_{W}} = 0.01\\), inverse-gamma prior \\(\\mathrm{IG}(0.1, 0.1)\\) biomarker variance \\(\\sigma^{2}_{W}\\) uniform prior (\\(\\mathrm{Beta}(1, 1)\\) prior) correlation \\(\\rho\\) latent DLT biomarker variable. dual-endpoint models complex, advisable use sufficiently long Markov chain fitting . just use illustration purposes quite small Markov chain – , real application, need least 25 times longer! can obtain MCMC samples: check convergence picking fitted biomarker means plotting traceplots:  4 \\(\\beta_{W,j}\\) (\\(j=1, 5, 10, 25\\)) means, biomarker means first, 5th, 10th 25th gridpoint, respectively, seem converged, traceplots show. (Remember data@nGrid gives number grid points.) can plot model fit: specify extrapolate = FALSE focus biomarker plot right panel observed dose range, don’t want extrapolate biomarker fit higher dose levels. can also look estimated biomarker precision \\(1 / \\sigma^{2}_{W}\\). extract precision precW use another ggmcmc function create histogram:  selection next best dose, special class NextBestDualEndpoint implemented. tries maximize biomarker response, NCRM-type safety constraint. want least 90% maximum biomarker response, 25% maximum overdose probability next dose, specify: example, assuming dose limit 50 mg given maximum allowable increments, next dose can found follows: corresponding plot can produced printing plot element returned list: bottom panel shows (NCRM) overdose probability, see doses 14 mg toxic. top panel, see probability dose reach least 90% maximum biomarker response dose grid — target probability. numbers low, clearly see local maximum 6 mg target probability, confirming seen previous data model fit plots. corresponding stopping rule exists. certain probability relative biomarker target, StoppingTargetBiomarker rule gives back TRUE queried fulfilled stopTrial function. example, require least 50% probability 90% biomarker response, specify: case, rule fulfilled yet, see : , dual-endpoint specific rule can combined required stopping rule. example, combine maximum sample size 40~patients: one stopping rules fulfilled, trial stopped. Let’s try build corresponding dual-endpoint design. start empty data set, use relative increments rule defined previous section use constant cohort size 3 patients: order study operating characteristics, need determine true biomarker DLT probability functions. going use biomarker function beta family. Note corresponding DualEndpointBeta model class, allows dual-endpoint designs beta biomarker response function. look corresponding help page information . let’s come back scenario definition: can draw corresponding curves:  biomarker response peaks 50 mg, toxicity still low. deciding true correlation \\(\\rho=0\\) true biomarker variance \\(\\sigma^{2}_{W} = 0.01\\) (giving high signal--noise ratio), can start simulating trials (starting 6 mg): Note “small” MCMC option set , order reduce simulation time — real application, “larger”. Plotting result gives overview final dose recommendations trial trajectories, also summary biomarker variance correlation estimates simulations: Finally, summary simulations can obtained corresponding function: see trials proceeded maximum sample size 40 patients (reaching 42 cohort size 3). doses selected lower toxicity target range, aiming biomarker target instead, true biomarker response peaked 50 mg. corresponding plot looks follows: see average biomarker fit bad range 50 mg, toxicity curve fit bad — probably result low frequency DLTs. warning : dual-endpoint designs still experimental! % Next talk dose escalation designs two endpoints modelled separately.","code":"data <- DataDual(   x =     c(       0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50     ),   y =     c(       0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1     ),   ID = as.integer(1:17),   cohort = as.integer(c(1:5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9)),   w =     c(       0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21     ),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) print(plot(data)) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW =     0.01,   sigma2W =     c(a = 0.1, b = 0.1),   rho =     c(a = 1, b = 1),   rw1 = TRUE ) options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) samples <- mcmc(data, model, options) data@nGrid ## [1] 41 betaWpicks <- get(samples, \"betaW\", c(1L, 5L, 10L, 25L)) ggs_traceplot(betaWpicks) print(plot(samples, model, data, extrapolate = FALSE)) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] ggs_histogram(get(samples, \"precW\")) myNextBest <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) nextDose <- nextBest(myNextBest,   doselimit = 50,   samples = samples,   model = model,   data = data ) nextDose$value ## [1] 12 print(nextDose$plot) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] myStopping6 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) stopTrial(myStopping6,   dose = nextDose$value,   samples, model, data ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target biomarker is 12 % for dose 12 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] NA myStopping <- myStopping6 | StoppingMinPatients(40) emptydata <- DataDual(doseGrid = data@doseGrid) design <- DualDesign(   model = model,   data = emptydata,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = CohortSizeConst(3),   startingDose = 6 ) betaMod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 } trueBiomarker <- function(dose) {   betaMod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) } trueTox <- function(dose) {   pnorm((dose - 60) / 10) } par(mfrow = c(1, 2)) curve(trueTox(x), from = 0, to = 80) curve(trueBiomarker(x), from = 0, to = 80) mySims <- simulate(design,   trueTox = trueTox,   trueBiomarker = trueBiomarker,   sigma2W = 0.01,   rho = 0,   nsim = 10,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions =     McmcOptions(       burnin = 1000,       step = 1,       samples = 3000     ) ) print(plot(mySims)) ## Note: method with signature 'Simulations#missing' chosen for function 'plot', ##  target signature 'DualSimulations#missing'. ##  \"GeneralSimulations#missing\" would also be valid ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange gtable[arrange] sumOut <- summary(mySims,   trueTox = trueTox,   trueBiomarker = trueBiomarker ) sumOut ## Summary of 10 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 51.6, 56.1  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 42 (42, 42)  ## Number of patients treated above target tox interval : mean 0 (0, 0)  ## Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  ## Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  ## Doses selected as MTD : mean 0.1 (0.1, 0.1)  ## True toxicity at doses selected : mean 0 % (0 %, 0 %)  ## Proportion of trials selecting target MTD: 0 % ## Dose most often selected as MTD: 0.1  ## Observed toxicity rate at dose most often selected: 0 % ## Fitted toxicity rate at dose most often selected : mean 2 % (1 %, 2 %)  ## Fitted biomarker level at dose most often selected : mean 0.2 (0.2, 0.2) print(plot(sumOut)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/example.html","id":"dual-endpoint-designs-with-separate-models","dir":"Articles","previous_headings":"Dual-endpoint dose escalation designs","what":"Dual-endpoint designs with separate models","title":"crmPack: Object-oriented implementation of CRM designs","text":"subsection, look dose-escalation designs model binary DLT responses continuous biomarker/efficacy responses separately. hence assume correlation binary DLT continuous efficacy responses. First, define data sets dual responses using DataDual function just like example given last subsection. example, data2 empty data set 12 dose levels, 25 300 mg increments 25 mg used. variable data4 contains data set binary DLT continuous efficacy responses observations. elements slot x dose levels 8 subjects treated. elements slot y represent corresponding binary DLT responses observed 8 subjects elements slot w represent continuous efficacy responses obtained 8 subjects. Similarly, can also obtain plot data sets using plot function described last subsection. described, model two responses separately. order , use models inheriting ModelPseudo class. binary DLT responses, can use models inheriting ModelTox class. example use models inheriting LogisticIndepBeta class variable DLTmodel (newDLTmodel observations) given previous examples. continuous efficacy responses, can use models inheriting ModelEff class. current version package, two model classes, Effloglog EffFlexi model, inheriting ModelEff class. Since ModelEff also inheriting ModelPseudo class, prior efficacy model also needs specified form pseudo data. (Please refer @ref(fig:model-classes) structure model classes defined package.) following commands show set Effloglog model. efficacy model describe relationship efficacy responses corresponding dose levels double logarithmic (“log-log”) scale. refers linear model three unknown parameters: intercept θ1, slope θ2 precision \\(\\nu\\) (inverse variance) efficacy responses. Similarly pseudo models, data set specified setting model: specification prior pseudo data, two dose levels 25 300 mg fixed specified eff_dose slot. eliciting prior expected efficacy values two dose levels (e.g. asking experts’), specified eff slot. example, 1.223 expected efficacy value subjects treated dose 25 mg 2.513 expected efficacy value subjects treated 300 mg. slot nu represents prior precision efficacy responses. example, two positive scalars \\(\\) \\(b\\) specified suggesting prior distribution precision gamma shape parameter \\(=1\\) rate parameter \\(b=0.025\\). Note , since gamma distribution used prior distribution \\(\\nu\\), posterior distribution gamma distribution, gamma prior precision conjugate normal likelihood. fixed value precision preferred, single positive scalar can also specified nu slot. Finally Data slot specified either empty data set data set currently available observations. Similarly, can also look structure Effmodel applying str function: 15 slots, can accessed @ operator. efficacy model, can obtain prior (using empty data set) posterior modal estimates model parameters θ1 (intercept) θ2 (slope). addition, gamma prior distribution used \\(\\nu\\) observations (data) available, can obtain updated values shape \\(\\) rate \\(b\\) parameters gamma distribution, via model. joint prior posterior density functions θ1 θ2 described details (Yeung et al. 2015). Next, describe example flexible semi-parametric function used describe relationship efficacy values corresponding dose levels. differences mean efficacy responses neighboring dose levels modeled either first second order random walk models. flexible model aims capture different shapes dose-efficacy curve. estimate mean efficacy responses obtained dose levels MCMC sampling. % involved obtain prior posterior distribution mean efficacy responses. flexible form can specified using EffFlexi class object. EffFlexi class inheriting ModelEff class prior also specified pseudo data: , similarly , also fixed two dose levels 25 300 mg supplied prior expected efficacy responses 1.223 2.513. variance efficacy responses \\(\\sigma^2\\) model can specified single positive scalar value two positive scalar values shape \\(\\) scale \\(b\\) parameters inverse gamma distribution slot sigma2. , specified variance efficacy responses inverse gamma distribution shape parameter \\(=0.1\\) scale parameter \\(b=0.1\\). , variance random walk model \\(\\sigma^2_{\\beta_W}\\) can also specified either single positive scalar two positive scalar parameters inverse gamma distribution slot sigma2betaW. , specified variance random walk model inverse gamma distribution shape parameter \\(=20\\) scale parameter \\(b=50\\). addition, can also specify like smooth mean efficacy response function. Either first order (RW1) second order (RW2) random walk model can used describe relationship neighbouring mean efficacy responses specified slot smooth. seen example, RW2, second order random walk model used. Finally, also specify data set Data used model data2 example. structure EffFlexi model object follows: slot names shown can accessed @ operator. value ‘FALSE’ slot useFixed shows variance efficacy response sigma2 variance random walk model `sigma2betaWare fixed, estimated assigned inverse gamma prior distribution model. slotuseRW1also gives 'FALSE' value means second order random walk model used model smooth dose-response function. addition, (internally required) random walk difference matrix rank matrix also shown slotRWmatandRWmatRank`, respectively. discussed, posterior estimates model parameters specified ModelPseudo class (except EffFlexi model class) can obtained modal estimates via MCMC sampling. , first show obtain estimates parameters via MCMC sampling. (Similarly, can also use mcmc function obtain prior posterior samples Effloglog EffFlexi models.) % using Effmodel Effmodel2, respectively data2 options specified earlier Effloglog (Effmodel) model, samples intercept θ1, slope θ2 efficacy linear log-log model precision \\(\\nu\\) efficacy responses can obtained. EffFlexi (Effmodel2) model, samples mean efficacy responses dose levels, variance \\(\\sigma^2\\) (sigma2) efficacy responses variance \\(\\sigma^2_{\\beta_W}\\) (sigma2betaW) random walk model obtained. also possible look structure (str) extract (get) obtain plots (ggs_traceplot ggs_autocorrelation) samples parameters. MCMC sampling involved, prior posterior modal estimates can obtained output models. observations responses available, can put DataDual data set, given Data slot model. can also updating current model new observations using update function. prior posterior modal estimates model parameters can obtained using @ operator model. example, Effloglog class model: posterior modal estimates θ1 θ2 updated values parameters gamma distribution \\(\\nu\\) can read now output . Similarly can update new data EffFlexi class model: plot function can also applied Effloglog model class EffFlexi model class objects, samples parameters generated models:   addition, can also plot fitted dose-efficacy curve using prior posterior modal estimates model parameters MCMC sampling used. example, using Effmodel data set data2 specified earlier:  Since samples involved, curves using prior posterior modal estimates parameters produced, 95% credibility intervals provided. Furthermore, can also plot estimated DLT probability efficacy curve side side using plotDualResponses function. example, using DLTmodel, Effmodel data2 specified earlier examples: MCMC samples used, : Next talk dose escalation rules two separate models used dual responses. Increments, CohortSize Stopping rules classes described earlier can applied . now look additional nextBest Stopping classes rules can use situation. , decision choosing next best dose administration based gain function defined (Yeung et al. 2015). gain function represents trade-DLT efficacy responses allocate dose gives best trade-responses. words, dose gives maximum gain value dose allocated next cohort subjects. basic ideas rules follows. % old text: Assume DLT observed subject, gain value observed particular dose level obtained multiplying probability DLT observed dose levels expected efficacy responses DLT observed particular dose level. %new: gain value particular dose level obtained multiplying probability DLT dose level expected efficacy response dose level. data accumulates trial, estimate gain function improve. gain function consists two components, one part DLT responses efficacy response. depends values obtained components affect values gain. example, ideal case probability DLT expected value efficacy response high. gain value obtained high. reason dose gives maximum gain value allocated next cohort subjects. can plot gain function given DLT model specified ModelTox class efficacy model specified ModelEff class using plotGain function. example, using variables newDLTmodel, newEffmodel data set observations, data4, specified earlier examples, :  case MCMC sampling involved prior posterior modal estimates model parameters used. two implemented nextBest rules dual responses using gain function: NextBestMaxGain NextBestMaxGainSamples class object. NextBestMaxGain used MCMC sampling involved use prior posterior modal estimates model parameters obtain gain values dose levels, NextBestMaxGainSamples used MCMC sampling involved obtain posterior estimates. example, MCMC sampling involved: use NextBestMaxGain, specify target probability occurrence DLT used trial end trial. example, target probability DLT used trial end trial 0.35 0.3, respectively. Therefore, rule suggest dose level gives maximum gain value probability DLT less equal 0.35 administer next cohort subjects. end trial, recommend dose maximum gain value probability DLT less equal 0.3. order derive next best dose administration, use nextBest function NextBestMaxGain object given doselimit, DLT efficacy models data set, includes currently available observations: results list numerical values plot illustrating next best dose computed. list numerical values include next best dose suggested, values target probabilities DLT used end trial. Furthermore, estimated doses two targets, well “Gstar” estimated dose (dose gives maximum gain value) provided along corresponding dose level dose grid three estimates. can also get see plot next best dose recommendation using $ operator.  usual, solid red, blue green lines curves represent relationship probability DLT, mean efficacy response gain values, respectively, corresponding dose levels. vertical line purple shows next best dose suggested administration vertical brown line shows maximum allowable dose level administered next cohort subjects. Furthermore, circle square DLT curve also show current estimate estimated TD30 TD35. Next look NextBestMaxGainSamples class object MCMC sampling involved. following code, specify target probabilities DLT used end trial 0.35 0.3 , specify 30% posterior quantile used estimate TD35 TD30, specify 50% posterior quantile Gstar estimate: Note two functions, derive mg_derive specified derive corresponding estimates posterior samples. , generic function nextBest used together rule object derive next best dose: list numerical results given output given using NextBestMaxGain class object includes next dose suggested, current estimates TD30, TD35 Gstar corresponding dose levels dose Grid. can also see plot:  plot, posterior distribution Gstar shown histogram. vertical lines plot show current estimates TD30, TD35 Gstar. addition, next dose maximum allowable dose also given blue red lines, respectively. Next, introduce Stopping rules can applied two classes escalation rules. escalation based two responses two separate pseudo DLT efficacy models, select one dose, minimum estimate TD30 (TDtargetEndOfTrial) optimal gain dose (Gstar) recommended dose potential clinical trials. main feature stopping rules trial stopped current estimates selected quantity ‘accurate’ enough. particular, also consider ratio 95% credibility interval bounds current estimate. smaller ratio, accurate estimate. example, like stop trial ratio less equal 5. functions StoppingMaxGainCIRatio used purpose: note , moment class stoppingMaxGainCIRatio used together stopping class rules “” operator & operator | (still development). Similarly, stopTrial function can used order determine rule fulfilled: % cases either DLT efficacy samples involved. Next, now look construct design objects. also start empty data set, object data3 DataDual class introduced earlier examples. two functions can used. DualResponsesDesign can used without MCMC samples, DualResponsesSamplesDesign can used MCMC samples involved. example, use object Effmodel Effloglog class specified earlier efficacy model following code: can use function DualResponsesSamplesDesign specify design efficacy model specified EffFlexi class object. example, use object Effmodel2 EffFlexi class specified earlier examples : specified three designs using previous rules nextBest (escalation rule), stopping, increments cohort size. Next, specify scenarios simulations. example, simulations using DLT model efficacy model LogisticIndepBeta Effloglog objects, respectively, can specify scenario : true DLT, efficacy gain curves can obtained. can see corresponding curves  Using commands, can obtained DLT (red), efficacy(blue) gain (green) curves also corresponding true values TD30 (TDtargetEndOfTrial), TD35 (TDtargetDuringTrial) Gstar. addition, scenario DLT efficacy can used cases (modal estimates MCMC samples). EffFlexi class object used simulations. Using DLT scenario new efficacy scenario specified corresponding curves can also plotted :  Similarly, also get DLT, efficacy gain values corresponding real values TD30, TD35 Gstar. establishing real scenarios, can simulate trials. First, look two examples Effloglog class object used efficacy model. show first example MCMC samples involved: simulate function used cases simulate trials specified scenarios. , specified true precision (trueNu) efficacy responses 1/0.025. words, used value 0.025 true variance efficacy responses simulation. arguments args,nsim, seed parallel, please refer earlier examples details specification description details. MCMC samples used, can also specify simulations similar way additional argument mcmcOptions EffFlexi class object used efficacy model, generate simulations follows: specification arguments object, args, trueDLE, trueEff, mcmcOptions,nsim,seed,parallel please refer earlier examples details. addition, two arguments used EffFlexi class efficacy model used simulations: First, trueSigma2 specified true variance efficacy responses trueSigma2betaW true variance random walk model used simulation. Furthermore, can also plot, summarize plot summary simulated results using plot summary function: plots give overview final dose recommendations trial trajectories. addition, also give summary efficacy variance also random walk model variance EffFlexi class object used efficacy model. , summary plot summary simulations can obtained : first simulation, Sim1 trial stop ratio 95% credibility interval bounds current estimate minimum TD30(TDtargetEndOfTrial) Gstar less equal 5. last two simulations, Sim2 Sim3, use trials stop either maximum 72 patients treated ratio 95% credibility interval less equal 5. can see simulations trials require total around 60 patients study. reminder, dual endpoint dose escalation design uses two separate models describe dose-responses relationship, gain function used determine next best dose final recommended dose end trial. specifically end trial, recommend dose level closest minimum final estimate TD30 (TDtargetEndOfTrial) Gstar. DLT efficacy scenario used first, Sim1 second simulations, Sim2 . real TD30 (TDtargetEndOfTrial) given summary 152.6125 mg dose level doseGrid closest real TD30 150 mg. real Gstar 130.0097 mg dose level dose grid closest Gstar 125 mg. case, real Gstar less real TD30 expect recommendations made dose level close real Gstar. words, scenario, expect recommendations made 125 mg. can see simulated results agrees expecting. summaries plots summaries, 125 mg dose level selected often simulations. scenario last simulation, Sim3, real TD30 real Gstar 125 mg. Since real TD30 greater real Gstar, also expect recommendations made close real Gstar scenario. can see simulated results summary plot summary, procedure also recommends 125 mg often simulations, agrees real scenario. Now, also look fitted dose-DLT dose-efficacy curves obtained three simulations. plots summaries, can see cases, fitted dose-DLT curves (solid-red curve) approximate well real dose-DLT curve (solid-black curve). 95% credibility interval DLT curve (broken-red curves) also given MCMC samples involved simulation. contrast, can see fitted efficacy curve (solid-blue curve) gives good fit real efficacy curve (solid-black) cases. approximation real efficacy curve better linear linear log-log model, Effloglog used, compared flexible form , EffFlexi used. addition, can also see 95% credibility interval efficacy curve (broken-blue line) MCMC sampling efficacy responses involved.","code":"data2 <- DataDual(doseGrid = seq(25, 300, 25))  data4 <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 2, 3, 4, 4, 5, 6)),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data2 ) str(Effmodel) ## Formal class 'Effloglog' [package \"crmPack\"] with 13 slots ##   ..@ eff      : num [1:2] 1.22 2.51 ##   ..@ eff_dose : num [1:2] 25 300 ##   ..@ nu       : Named num [1:2] 1 0.025 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ use_fixed: logi FALSE ##   ..@ theta1   : num -1.41 ##   ..@ theta2   : num 2.25 ##   ..@ Pcov     : num [1:2, 1:2] NaN NaN NaN NaN ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   ..@ X        : num [1:2, 1:2] 1 1 1.17 1.74 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"1\" \"2\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. ..- attr(*, \"assign\")= int [1:2] 0 1 ##   ..@ Y        : num [1:2] 1.22 2.51 ##   ..@ mu       : num [1:2] -1.41 2.25 ##   ..@ Q        : num [1:2, 1:2] 2 2.91 2.91 4.4 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   ..@ const    : num 0 ##   ..@ data     :Formal class 'DataDual' [package \"crmPack\"] with 10 slots ##   .. .. ..@ w       : num(0)  ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 Effmodel2 <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data2 ) str(Effmodel2) ## Formal class 'EffFlexi' [package \"crmPack\"] with 10 slots ##   ..@ eff        : num [1:2] 1.22 2.51 ##   ..@ eff_dose   : num [1:2] 25 300 ##   ..@ sigma2W    : Named num [1:2] 0.1 0.1 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ sigma2betaW: Named num [1:2] 20 50 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ use_fixed  : Named logi [1:2] FALSE FALSE ##   .. ..- attr(*, \"names\")= chr [1:2] \"sigma2W\" \"sigma2betaW\" ##   ..@ rw1        : logi FALSE ##   ..@ X          : int [1:2, 1:12] 1 0 0 0 0 0 0 0 0 0 ... ##   ..@ RW         : num [1:12, 1:12] 1 -2 1 0 0 0 0 0 0 0 ... ##   ..@ RW_rank    : int 10 ##   ..@ data       :Formal class 'DataDual' [package \"crmPack\"] with 10 slots ##   .. .. ..@ w       : num(0)  ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 Effsamples <- mcmc(data = data2, model = Effmodel, options) Effsamples2 <- mcmc(data = data2, model = Effmodel2, options) Effpostsamples <- mcmc(data = data2, model = Effmodel, options) Effpostsamples2 <- mcmc(data = data2, model = Effmodel2, options) newEffmodel <- update(object = Effmodel, data = data4) newEffmodel@theta1 ## [1] -2.81695 newEffmodel@theta2 ## [1] 2.709524 newEffmodel@nu ##         a         b  ## 3.0000000 0.9832955 newEffmodel2 <- update(object = Effmodel2, data = data4) newEffmodel2@RW ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] ##  [1,]    1   -2    1    0    0    0    0    0    0     0     0     0 ##  [2,]   -2    5   -4    1    0    0    0    0    0     0     0     0 ##  [3,]    1   -4    6   -4    1    0    0    0    0     0     0     0 ##  [4,]    0    1   -4    6   -4    1    0    0    0     0     0     0 ##  [5,]    0    0    1   -4    6   -4    1    0    0     0     0     0 ##  [6,]    0    0    0    1   -4    6   -4    1    0     0     0     0 ##  [7,]    0    0    0    0    1   -4    6   -4    1     0     0     0 ##  [8,]    0    0    0    0    0    1   -4    6   -4     1     0     0 ##  [9,]    0    0    0    0    0    0    1   -4    6    -4     1     0 ## [10,]    0    0    0    0    0    0    0    1   -4     6    -4     1 ## [11,]    0    0    0    0    0    0    0    0    1    -4     5    -2 ## [12,]    0    0    0    0    0    0    0    0    0     1    -2     1 print(plot(Effpostsamples, newEffmodel, data4)) print(plot(Effpostsamples2, newEffmodel2, data4)) print(plot(data2, Effmodel)) plotDualResponses(   DLEmodel = DLTmodel,   Effmodel = Effmodel, data = data2 ) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] plotDualResponses(   DLEmodel = DLTmodel, DLEsamples = DLTsamples,   Effmodel = Effmodel, Effsamples = Effsamples, data = data2 ) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] plotGain(DLEmodel = newDLTmodel, Effmodel = newEffmodel, data = data4) GainNextBest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) doseRecGain <- nextBest(GainNextBest,   doselimit = max(data4@doseGrid),   model = newDLTmodel,   model_eff = newEffmodel,   data = data4 ) doseRecGain$plot GainsamplesNextBest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(TDsamples) {     as.numeric(quantile(TDsamples, prob = 0.3))   },   mg_derive = function(Gstarsamples) {     as.numeric(quantile(Gstarsamples, prob = 0.5))   } ) doseRecGainSamples <- nextBest(GainsamplesNextBest,   doselimit = max(data4@doseGrid),   model = newDLTmodel,   samples = DLTpostsamples,   model_eff = newEffmodel,   samples_eff = Effpostsamples,   data = data4 ) ## [1] \"Estimated TD 30 = 18.6611868271306 not within dose grid\" doseRecGainSamples$plot myStopping7 <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) myStopping8 <- myStopping7 | StoppingMinPatients(72) stopTrial(   stopping = myStopping7, dose = doseRecGain$next_dose, model = newDLTmodel,   data = data4, Effmodel = newEffmodel ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Gstar estimate is 79.7805 with 95% CI ( 21.5588 , 295.2361 ) and its ratio = 13.6945\"                ## [2] \"TDtargetEndOfTrial estimate is  42.6813 with 95% CI ( 11.0662 , 164.618 ) and its ratio= 14.8758\"    ## [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 14.8758 which is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] NA stopTrial(   stopping = myStopping7,   dose = doseRecGainSamples$next_dose,   samples = DLTpostsamples,   model = newDLTmodel,   data = data4,   TDderive = function(TDsamples) {     quantile(TDsamples, prob = 0.3)   },   Effmodel = newEffmodel,   Effsamples = Effpostsamples,   Gstarderive = function(Gstarsamples) {     quantile(Gstarsamples, prob = 0.5)   } ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Gstar estimate is 50 with 95% CI ( 25 , 300 ) and its ratio = 12\"                                           ## [2] \"TDtargetEndOfTrial estimate is  18.6612 with 95% CI ( 6e-04 , 10459.1345 ) and its ratio= 17110373.1537\"    ## [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 17110373.1537  which is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] NA design1 <- DualResponsesDesign(   nextBest = GainNextBest,   model = DLTmodel,   eff_model = Effmodel,   data = data2,   stopping = myStopping7,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 )  design2 <- DualResponsesSamplesDesign(   nextBest = GainsamplesNextBest,   model = DLTmodel,   eff_model = Effmodel,   data = data2,   stopping = myStopping8,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 ) design3 <- DualResponsesSamplesDesign(   nextBest = GainsamplesNextBest,   model = DLTmodel,   eff_model = Effmodel2,   data = data2,   stopping = myStopping8,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 ) myTruthDLT <- probFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  myTruthGain <- function(dose) {   return(myTruthEff(dose) * (1 - myTruthDLT(dose))) } TruthTD <- doseFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499)  GAIN <- function(xi) {   -(-4.8218429 + 3.653058 * log(xi)) / (1 + exp(-53.66584 + 10.50499 * xi)) } Txi <- (optim(1, GAIN, method = \"BFGS\")$par) maxg <- (optim(1, GAIN, method = \"BFGS\")$value) gstar <- exp(Txi) td30 <- TruthTD(0.3) td35 <- TruthTD(0.35) DoseLevels <- seq(2, 300, 1) plot(DoseLevels, myTruthDLT(DoseLevels),   col = \"red\", type = \"l\", lwd = 3, ylab = \"Values\",   ylim = c(0, max(1, max(myTruthEff(DoseLevels)))) ) points(td30, 0.3, col = \"violet\", pch = 15, cex = 2) points(td35, 0.35, col = \"violet\", pch = 16, cex = 2) lines(DoseLevels, myTruthEff(DoseLevels), col = \"blue\", type = \"l\", lwd = 3) lines(DoseLevels, myTruthGain(DoseLevels), col = \"green3\", type = \"l\", lwd = 3) points(gstar, -maxg, col = \"green3\", pch = 17, cex = 2) legend(\"topright\",   bty = \"n\", cex = 1.2, c(     \"p(DLT)=0.3\", \"p(DLT)=0.35\", \"Max gain\", \"p(DLTs)\",     \"efficacy\", \"gain\"   ), text.col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\"),   pch = c(15, 16, 17, NA, NA, NA), lty = c(NA, NA, NA, 1, 1, 1), col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\") ) myTruthEff1 <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )  d1 <- data2@doseGrid myTruthGain1 <- myTruthEff1 * (1 - myTruthDLT(d1)) maxg1 <- max(myTruthGain1) gstar1 <- data2@doseGrid[which.max(myTruthGain1)] DoseLevels1 <- seq(1, 300, 1) TruthTD <- doseFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499) td30 <- TruthTD(0.3) td35 <- TruthTD(0.35) plot(DoseLevels1, myTruthDLT(DoseLevels1),   col = \"red\", type = \"l\",   lwd = 3, ylab = \"Values\", ylim = c(0, max(1, max(myTruthEff1))) ) points(td30, 0.3, col = \"violet\", pch = 15, cex = 2) points(td35, 0.35, col = \"violet\", pch = 16, cex = 2) lines(d1, myTruthEff1, col = \"blue\", type = \"l\", lwd = 3) lines(d1, myTruthGain1, col = \"green3\", type = \"l\", lwd = 3) points(gstar1, maxg1, col = \"green3\", pch = 17, cex = 2) legend(\"topright\",   bty = \"n\", cex = 1.2, c(     \"p(DLT)=0.3\", \"p(DLT)=0.35\",     \"Max gain\", \"p(DLTs)\", \"efficacy\", \"gain\"   ), text.col = c(     \"violet\", \"violet\",     \"green3\", \"red\", \"blue\", \"green3\"   ), pch = c(15, 16, 17, NA, NA, NA),   lty = c(NA, NA, NA, 1, 1, 1), col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\") ) Sim1 <- simulate(   object = design1,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 10,   seed = 819,   parallel = FALSE ) Sim2 <- simulate(   object = design2,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE ) Sim3 <- simulate(   object = design3,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff1,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = options,   nsim = 10,   seed = 819,   parallel = FALSE ) plot(Sim1) ## Note: method with signature 'PseudoSimulations#missing' chosen for function 'plot', ##  target signature 'PseudoDualSimulations#missing'. ##  \"GeneralSimulations#missing\" would also be valid ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] plot(Sim2) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] plot(Sim3) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] Sum1 <- summary(Sim1,   trueDLE = myTruthDLT,   trueEff = myTruthEff ) Sum1 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 16 (15, 19)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (3, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 3 (3, 3)  ## Proportions of observed DLT in the trials : mean 21 % (20 %, 23 %)  ## Mean toxicity risks for the patients : mean 21 % (20 %, 21 %)  ## Doses selected as TDEOT : mean 100 (97.5, 102.5)  ## True toxicity at TDEOT : mean 1 % (0 %, 1 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 0 % ## Fitted probabilities of DLE at dose most often selected : mean 24 % (24 %, 24 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    118.2   144.4   144.4   143.5   144.4   161.5   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ##  ## Target Gstar, the dose which gives the maximum gain value was 130.0097  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    142.9   146.7   152.1   152.6   153.1   178.6   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    6.807   6.985   7.188   7.691   7.472  10.729   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ## Fitted expected efficacy level at dose most often selected : mean 0.9 (0.9, 1) print(plot(Sum1)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] Sum2 <- summary(Sim2,   trueDLE = myTruthDLT,   trueEff = myTruthEff ) Sum2 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 45 (36, 51)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 8 (3, 12)  ## Number of patients treated above the target p(DLE) used during a trial : mean 8 (3, 12)  ## Proportions of observed DLT in the trials : mean 19 % (17 %, 20 %)  ## Mean toxicity risks for the patients : mean 19 % (15 %, 25 %)  ## Doses selected as TDEOT : mean 120 (100, 125)  ## True toxicity at TDEOT : mean 4 % (1 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 125  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 25 % (23 %, 27 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    133.2   151.0   155.9   154.2   159.3   168.8   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ##  ## Target Gstar, the dose which gives the maximum gain value was 130.0097  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    150.0   175.0   187.5   182.5   200.0   200.0   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##      2.4     2.4     2.4     2.4     2.4     2.4   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## Fitted expected efficacy level at dose most often selected : mean 1 (1, 1) print(plot(Sum2)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] Sum3 <- summary(Sim3,   trueDLE = myTruthDLT,   trueEff = myTruthEff1 ) Sum3 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 50 (39, 58)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 8 (6, 12)  ## Number of patients treated above the target p(DLE) used during a trial : mean 8 (6, 12)  ## Proportions of observed DLT in the trials : mean 21 % (18 %, 24 %)  ## Mean toxicity risks for the patients : mean 20 % (15 %, 24 %)  ## Doses selected as TDEOT : mean 115 (100, 125)  ## True toxicity at TDEOT : mean 3 % (1 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 125  ## Observed toxicity rate at dose most often selected: 4 % ## Fitted probabilities of DLE at dose most often selected : mean 27 % (25 %, 28 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    128.9   143.6   149.2   149.0   154.4   169.5   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ##  ## Target Gstar, the dose which gives the maximum gain value was 125  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    250.0   250.0   250.0   262.5   275.0   300.0   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    1.333   1.500   1.857   1.938   2.000   3.000   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## Fitted expected efficacy level at dose most often selected : mean 0.9 (0.9, 1) print(plot(Sum3)) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name            grob ## 1 1 (1-1,1-1) arrange gtable[arrange] ## 2 2 (2-2,1-1) arrange  gtable[layout] # nolint end"},{"path":[]},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"naming-convention-motivation","dir":"Articles","previous_headings":"Class and slot changes","what":"Naming convention motivation","title":"Migrating from crmPack version 1.0.3","text":"close common R style guidelines (Wickham 2019) use consistent naming conventions within crmPack package, CamelCase notation used class names, method names constructor function names, snake_case notation used slot names throughout package.","code":""},{"path":[]},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"renamed-slots","dir":"Articles","previous_headings":"Class and slot changes","what":"Renamed slots","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates class/slot removed.","code":""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"moved-dose-and-prob-functions-from-slots-to-methods","dir":"Articles","previous_headings":"","what":"Moved dose and prob Functions from Slots to Methods","title":"Migrating from crmPack version 1.0.3","text":"Moved dose prob functions model class slots model class methods. Example usage: dose/prob function true dose-DLT/DLT-dose relationship.","code":""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"generate-data-define-a-model-and-get-samples","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Generate data, define a model and get samples","title":"Migrating from crmPack version 1.0.3","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100)) my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) ) my_options <- McmcOptions(burnin = 2, step = 2, samples = 20) my_samples <- mcmc(empty_data, my_model, my_options)"},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"dose","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Dose","title":"Migrating from crmPack version 1.0.3","text":"example dose function can used case different inputs, .e. model’s parameters samples case fixed model’s parameters values.","code":"# Doses reaching a specific target probability of the occurrence of a DLT (equal to 0.3), # given a particular models and samples. # Every single dose corresponds to one particular sample in `my_samples`. dose(0.3, my_model, my_samples) ##  [1] 4.890186e+05 1.621796e+00 1.966284e+00 1.062283e+00 1.364904e+00 ##  [6] 2.729472e-01 3.523279e-01 6.111257e-02 9.287453e-01 1.610243e+00 ## [11] 2.806204e+00 1.592511e+00 1.510752e+00 8.549368e-01 6.100870e-01 ## [16] 1.147578e+00 9.592463e-01 1.456528e+00 1.911540e+00 2.655042e+00 # True dose-DLT relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_dose_fun` takes one argument (target probability of the occurrence of a DLT) # and computes the corresponding dose, according to the model chosen and given a fixed values # of the model's parameters. true_dose_fun <- doseFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_dose_fun(0.3) ## [1] 0.9538033"},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"prob","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Prob","title":"Migrating from crmPack version 1.0.3","text":"","code":"# Toxicity probabilities for a given dose (equal to 10), model and samples. # Every single probability value corresponds to one particular sample in `my_samples`. prob(10, my_model, my_samples) ##  [1] 0.74588810 0.07608781 0.92158634 0.99062038 0.96828281 0.71811811 ##  [7] 0.48762577 0.84215610 0.75971216 0.98858862 0.83778194 0.94999929 ## [13] 0.98143953 0.99299351 0.85799496 0.69043937 0.87776109 0.99310605 ## [19] 0.97939779 0.91953329 # True DLT-dose relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_prob_fun` takes one argument (the dose) and computes the corresponding # toxicity probability, according to the model chosen and given a fixed values # of the model's parameters. true_prob_fun <- probFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_prob_fun(10) ## [1] 0.8179597"},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"new-random-number-generator-settings-for-the-mcmc","dir":"Articles","previous_headings":"","what":"New Random Number Generator settings for the MCMC","title":"Migrating from crmPack version 1.0.3","text":"Random Number Generator (RNG) settings used JAGS MCMC now configured solely McmcOptions class. RNG settings : RNG type RNG seed corresponds given RNG type. Find details help page McmcOptions class. RNG-related user settings R session level (us set.seed()) ignored MCMC sampler.","code":""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"new-no-argument-constructors","dir":"Articles","previous_headings":"","what":"New no-argument constructors","title":"Migrating from crmPack version 1.0.3","text":"aid software development, new -argument constructs sub-classes GeneralModel, Increments, NextBest Stopping introduced. names constructors take form .Default<classname>, <classname> name class created. constructors return valid, necessarily contextually sensible, objects required class. One reason objects returned may contextually sensible constructors take account associated doseGrid. examples use:","code":".DefaultStoppingAll() ## An object of class \"StoppingAll\" ## Slot \"stop_list\": ## [[1]] ## An object of class \"StoppingMinCohorts\" ## Slot \"nCohorts\": ## [1] 3 ##  ## Slot \"report_label\": ## [1] NA ##  ##  ## [[2]] ## An object of class \"StoppingTargetProb\" ## Slot \"target\": ## [1] 0.20 0.35 ##  ## Slot \"prob\": ## [1] 0.5 ##  ## Slot \"report_label\": ## [1] NA ##  ##  ## [[3]] ## An object of class \"StoppingMinPatients\" ## Slot \"nPatients\": ## [1] 20 ##  ## Slot \"report_label\": ## [1] NA ##  ##  ##  ## Slot \"report_label\": ## [1] NA class_name <- \"LogisticNormal\" eval(parse(text = paste0(\".Default\", class_name, \"()\"))) ## An object of class \"LogisticNormal\" ## Slot \"params\": ## An object of class \"ModelParamsNormal\" ## Slot \"mean\": ## [1] -0.85  1.00 ##  ## Slot \"cov\": ##      [,1] [,2] ## [1,]  1.0 -0.5 ## [2,] -0.5  1.0 ##  ## Slot \"prec\": ##           [,1]      [,2] ## [1,] 1.3333333 0.6666667 ## [2,] 0.6666667 1.3333333 ##  ##  ## Slot \"ref_dose\": ## An object of class \"positive_number\" ## [1] 1 ##  ## Slot \"datamodel\": ## function ()  ## { ##     for (i in 1:nObs) { ##         logit(p[i]) <- alpha0 + alpha1 * log(x[i]/ref_dose) ##         y[i] ~ dbern(p[i]) ##     } ## } ## <bytecode: 0x557d67429ed8> ## <environment: 0x557d685d0408> ##  ## Slot \"priormodel\": ## function ()  ## { ##     theta ~ dmnorm(mean, prec) ##     alpha0 <- theta[1] ##     alpha1 <- theta[2] ## } ## <bytecode: 0x557d67429068> ## <environment: 0x557d685d0408> ##  ## Slot \"modelspecs\": ## function (from_prior)  ## { ##     ms <- list(mean = params@mean, prec = params@prec) ##     if (!from_prior) { ##         ms$ref_dose <- ref_dose ##     } ##     ms ## } ## <bytecode: 0x557d67430060> ## <environment: 0x557d685d01a0> ##  ## Slot \"init\": ## function ()  ## { ##     list(theta = c(0, 1)) ## } ## <bytecode: 0x557d6742f768> ## <environment: 0x557d685d01a0> ##  ## Slot \"datanames\": ## [1] \"nObs\" \"y\"    \"x\"    ##  ## Slot \"datanames_prior\": ## character(0) ##  ## Slot \"sample\": ## [1] \"alpha0\" \"alpha1\""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"handling-of-na-or-placebo-returned-as-next-dose","dir":"Articles","previous_headings":"","what":"Handling of NA or placebo returned as next dose","title":"Migrating from crmPack version 1.0.3","text":"consistent handling study stopped facilitate analysis stop reasons operation characteristics, handling NA placebo returned nextBest methods changed. previous version crmPack stopping placebo NA returned nextBest method handled automatically generic Stopping method. now moved new stopping rule StoppingMissingDose. consequence, stopping rule StoppingMissingDose must specified nextBest methods can return NA, placebo used. Otherwise simulation may run error study stopped NA returned next dose. nextBest methods can return NA NextBestNCRM, NextBestNCRMLoss NextBestDualEndpoint.","code":""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"evaluation-of-stopping-rules-at-a-specific-dose","dir":"Articles","previous_headings":"","what":"Evaluation of stopping rules at a specific dose","title":"Migrating from crmPack version 1.0.3","text":"Without specification, stopping rules evaluated dose returned used nextBest method. new stopping rule StoppingSpecificDose possible evaluate stopping rules dose. usage see documentation StoppingSpecificDose.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"classes","dir":"Articles","previous_headings":"Further details in class and methods name changes","what":"Classes","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates class/slot removed.","code":""},{"path":"https://roche.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"methods","dir":"Articles","previous_headings":"Further details in class and methods name changes","what":"Methods","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates method/argument removed.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Parallel computing with extensions","text":"One big advantages crmPack existing R implementations flexible framework based S4 classes methods system (Chambers 2008). Users can extend existing functionality easily specific needs study (Sabanes Bove et al. 2019). User defined extensions classes methods can easily created used together existing crmPack classes methods setting study performing analysis observed data. long parallel computing used, special care needs taken utilizing native user defined classes methods. trial simulations need performed derive operational characteristics study setup, run times may become long single core processing. run time depends mainly number study replications MCMC samples. cases long run times, utilizing parallel computing, .e., using multiple CPU cores, can overcome challenge decrease run times significantly. Parallel computing supported crmPack design, .e., whenever simulation call invoked parameters parallel = TRUE nCores = one CPU, core initialized crmPack package global environment. Due nature S4 object system, user defined classes method defined global environment just made available core initializing core global environment. User defined classes method needs executed core initialized warrant full functionality S4 objects. following paragraphs provide example user defined extensions can used utilizing parallel computing within crmPack.","code":""},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"high-level-usage","dir":"Articles","previous_headings":"","what":"High level usage","title":"Parallel computing with extensions","text":"use user written extension parallel computing crmPack, user written code needs embedded function. function stored value global option fixed name crmpack_extensions. existence global option evaluated parallel computing requested. case option crmpack_extensions exists, content submitted node cluster, user written S4 classes methods available along crmPack package. following code show high level, option utilized.","code":"options(   crmpack_extensions = function() {     # ..... user code .....   } )"},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"important-information-for-usage","dir":"Articles","previous_headings":"","what":"Important information for usage","title":"Parallel computing with extensions","text":"operation characteristics design needs derived utilizing parallel computing, simulation function must executed parameter parallel = TRUE nCores = number greater one. case, evaluated global option name crmpack_extensions exists. true, value global option crmpack_extensions executed core time initialization, .e., character string equal global option crmpack_extensions executed core cluster, code available use parallel computing. Please note wrapper function holds user extensions convenient way hand class method definitions user constructor function crmpack_extensions option. However, constructor function must available environment called. extensions directly coded within wrapper function, <<- operator must used new user defined constructor function defined within wrapper function. <<- operator force function become visible within global environment. Another possibility store user extensions file sourced within wrapper function. case user defined constructor function can assigned regular <- operator, source parse content file environment. avoid errors important understand packages attached current environment available workers environment. .e., even though code may work without problems used single core processing, may fail parallel execution functions attached workers environment. Therefore necessary make sure called functions available workers environment. can achieved including library statement within wrapper function using double colon operator ::. described usage options detailed example.","code":""},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"information-for-debugging","dir":"Articles","previous_headings":"","what":"Information for debugging","title":"Parallel computing with extensions","text":"expected good practice, new written extension first tested validated one CPU core, utilizing global option crmpack_extensions. important understand character string value global option crmpack_extensions executed directly core checked validity correctness. case code run errors, returned error message using parallel computing may misleading may help identify root cause problem. Debugging newly written code much easier without using parallel computing.","code":""},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"worked-out-example","dir":"Articles","previous_headings":"","what":"Worked out example","title":"Parallel computing with extensions","text":"Let us assume want utilize two-parameter logistic regression model, slope parameter positive values, normal prior truncated slope parameter, slope can positive values. case want set prior distribution slope parameter truncated normal distribution bounded zero lower end. model representation part crmPack package can easily added shown . Please note example extra code directly inserted option crmpack_extensions function. mentioned , user write test code first without embedding function set equal option crmpack_extensions, assure errors occur whole execution results expected. new code defined embedded function, can store function value global option, name crmpack_extensions. Please note <<-operator used assign LogisticNormalTruncPrior function global environment. assertion functions package checkmate referenced double colon operator example. case package checkmate attached within function, .e., statement library(checkmate) used code , direct reference checkmate:: can removed. Either way works parallel computing makes sure functions can used current environment workers parallel study simulations performed. Now able use newly created model LogisticNormalTruncPrior set study. First, get value global option crmpack_extensions, function defined . execute function within global environment, constructor function corresponding classes methods prob dose become available. Next can set study new model desired design features. setting model design features, useful check model decisions case DLT observed certain dose level study simulations performed. check can also serve additional test new written code. examine runs expected, study simulations can performed. demonstrate difference single core processing multiple core processing, two scenarios processed single core processing, followed 5 scenarios utilizing parallel computing. regard run times example, please see note end vignette. simulations single core processing running successful, full operation characteristics utilizing parallel computing can derived.","code":"library(crmPack)  my_own_extension <- function() {   # Attach the package checkmate with library(checkmate) here, to avoid usage of   # the :: operator in the code below.    # LogisticNormalTruncPrior ----    ## class ----    #' `LogisticNormalTruncPrior`   #'   #' @description `r lifecycle::badge(\"experimental\")`   #'   #' [`LogisticNormalTruncPrior`] is the class for the usual logistic regression   #'  model with bivariate normal prior on the intercept and slope.   #'   #' @aliases LogisticNormalTruncPrior   #' @export   #'   #' @slot mean1 the mean of the intercept   #' @slot mean2 the mean of the slope   #' @slot var1 the variance of the intercept   #' @slot var2 the variance of the slope   #'   .LogisticNormalTruncPrior <- setClass(     Class = \"LogisticNormalTruncPrior\",     contains = \"GeneralModel\",     slots = c(       mean1 = \"numeric\",       mean2 = \"numeric\",       var1 = \"numeric\",       var2 = \"numeric\"     )   )    ## constructor ----    #' @rdname LogisticNormalTruncPrior-class    #' Initialization function for the `LogisticNormalTruncPrior` class   #'   #' @param mean1 the mean of the intercept   #' @param mean2 the mean of the slope   #' @param var1 the variance of the intercept   #' @param var2 the variance of the slope   #' @return the \\code{\\linkS4class{LogisticNormalTruncPrior}} object   #'   #' @export   #' @keywords methods   LogisticNormalTruncPrior <<- function(mean1, mean2, var1, var2) {     .LogisticNormalTruncPrior(       mean1 = mean1,       mean2 = mean2,       var1 = var1,       var2 = var2,       datamodel = function() {         for (i in 1:nObs) {           y[i] ~ dbern(mean[i])           logit(mean[i]) <- alpha0 + alpha1 * x[i]         }       },       priormodel = function() {         alpha0 ~ dnorm(mean1, 1 / var1)         alpha1 ~ dnorm(mean2, 1 / var2) %_% I(0, )       },       datanames = c(\"nObs\", \"y\", \"x\"),       modelspecs = function() {         list(           mean1 = mean1,           mean2 = mean2,           var1 = var1,           var2 = var2         )       },       init = function() {         list(alpha0 = mean1, alpha1 = mean2)       },       sample = c(\"alpha0\", \"alpha1\")     )   }    ## dose ----    #' @describeIn dose compute the dose level reaching a specific toxicity   #'   probability.   #'   #' @aliases dose-LogisticNormalTruncPrior   #' @export   #'   setMethod(     f = \"dose\",     signature = signature(       x = \"numeric\",       model = \"LogisticNormalTruncPrior\",       samples = \"Samples\"     ),     definition = function(x, model, samples) {       checkmate::assert_probabilities(x)       checkmate::assert_subset(c(\"alpha0\", \"alpha1\"), names(samples))       assert_length(x, len = size(samples))        alpha0 <- samples@data$alpha0       alpha1 <- samples@data$alpha1       (logit(x) - alpha0) / alpha1     }   )    ## prob ----    #' @describeIn prob compute the toxicity probability of a specific dose.   #'   #' @aliases prob-LogisticNormalTruncPrior   #' @export   #'   setMethod(     f = \"prob\",     signature = signature(       dose = \"numeric\",       model = \"LogisticNormalTruncPrior\",       samples = \"Samples\"     ),     definition = function(dose, model, samples) {       checkmate::assert_numeric(         dose,         lower = 0L, any.missing = FALSE, min.len = 1       )       checkmate::assert_subset(c(\"alpha0\", \"alpha1\"), names(samples))       assert_length(dose, len = size(samples))        alpha0 <- samples@data$alpha0       alpha1 <- samples@data$alpha1       1 / (1 + exp(-alpha0 - alpha1 * dose))     }   ) } # Store the function into the global option crmpack_extensions. options(crmpack_extensions = my_own_extension) # Execute the user written extensions. getOption(\"crmpack_extensions\")() # Create the dose grid. emptydata <- Data(   doseGrid = c(     10, 15, 20, 30, 40, 60, 80, 120, 160, 240, 320,     480, 640, 960, 1280, 1920, 2400, 3000, 4000   ),   placebo = FALSE )  # Create data for basic testing of the setup. my_data <- Data(   x = c(10, 20, 40, 80, 80, 160, 160),   y = c(0, 0, 0, 0, 0, 1, 1),   cohort = c(1, 2, 3, 4, 4, 5, 5),   ID = 1:7,   doseGrid = emptydata@doseGrid )  # Setup the model. my_model <- LogisticNormalTruncPrior(   mean1 = -3,   mean2 = 0.00075,   var1 = 1,   var2 = 0.000009 )  # Options used for simulations. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 100,   rng_kind = \"Mersenne-Twister\",   rng_seed = 94 )  # Create mcmc samples. my_samples <- mcmc(my_data, my_model, my_options)  # Plot the dose toxicity curve. plot(my_samples, my_model, my_data)  # Specify increments. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1),   increments = c(1, 0.5) )  # Maximum dose. this_max_dose <- maxDose(my_increments, my_data)  # Next best dose. my_next_best <- NextBestMinDist(target = 0.3) this_next_dose <- nextBest(   my_next_best, this_max_dose, my_samples, my_model, my_data )$value  # Stopping rule. my_stopping <- StoppingPatientsNearDose(nPatients = 9, percentage = 0)  # Stop trial based on criteria and observed data. stopTrial(my_stopping, this_next_dose, my_samples, my_model, my_data)  # Cohorts size. my_size <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Design. my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 10 ) # Examine the design. examine(my_design, my_options) # Set up scenarios scenario_setup <- function(intercept, mtd_prob, mtd_dose) {   probFunction(     my_model,     alpha0 = logit(intercept),     alpha1 = (logit(mtd_prob) - logit(intercept)) / mtd_dose   ) }  safe_scenario <- scenario_setup(0.05, 0.3, 20000) late_scenario <- scenario_setup(0.05, 0.3, 2000) early_scenario <- scenario_setup(0.05, 0.3, 700) toxic_scenario <- scenario_setup(0.6, 0.3, -300) peak_scenario <- function(     dose,     scenario = cbind(emptydata@doseGrid, c(rep(0.05, 11), rep(0.80, 8)))) {   scenario[match(dose, scenario[, 1]), 2] }  # Helper function that outputs the elapsed time. report_time <- function(report_text) {   cat(     format(Sys.time(), usetz = TRUE),     report_text,     \"done - elapsed time from start:\",     round(difftime(Sys.time(), start_time, units = \"mins\"), digits = 1),     \"\\n\"   ) }  # Helper function that simulates a specific truth. get_oc <- function(truth) {   simulate(     my_design,     args = NULL,     truth = truth,     nsim = my_nsim,     mcmcOptions = my_options,     parallel = do_parallel,     nCores = parallelly::availableCores()   ) }  # get operation characteristics without utilizing parallel computing for # selected truth (to reduce the run time). time_no_parallel <- system.time({   start_time <- Sys.time()   cat(format(Sys.time(), usetz = TRUE), \"start\", \"\\n\")    my_nsim <- 10   do_parallel <- FALSE    safe <- get_oc(safe_scenario)    report_time(\"safe (single core processing)\")    late <- get_oc(late_scenario)    report_time(\"late (single core processing)\") }) # Get full operation characteristics utilizing parallel computing. time <- system.time({   start_time <- Sys.time()   cat(format(Sys.time(), usetz = TRUE), \"start\", \"\\n\")    my_nsim <- 10   do_parallel <- TRUE    safe <- get_oc(safe_scenario)    report_time(\"safe\")    late <- get_oc(late_scenario)    report_time(\"late\")    early <- get_oc(early_scenario)    report_time(\"early\")    toxic <- get_oc(toxic_scenario)    report_time(\"toxic\")    peak <- get_oc(peak_scenario)    report_time(\"peak\") })"},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"alternative-read-user-code-from-external-file","dir":"Articles","previous_headings":"","what":"Alternative: read user code from external file","title":"Parallel computing with extensions","text":"alternative may convenient store user extensions external file source file wrapper function. advantage, <<- operator necessary user constructor functions can replaced usual assignment <-.","code":"if (FALSE) {   # Store code example form above in external file and   # remove the wrapper function structure.   dump(\"my_own_extension\", file = \"user_extension.R\")   file_con <- file(\"user_extension.R\")   tmp <- readLines(file_con)[-c(1:3, 135)]   tmp <- gsub(\"<<-\", \"<-\", tmp)   writeLines(tmp, file_con)    # Source the stored file in the wrapper function.   my_own_extension2 <- function() {     source(\"user_extension.R\")   }    options(crmpack_extensions = my_own_extension2)   getOption(\"crmpack_extensions\")()    # Run the rest of the code from above example }"},{"path":"https://roche.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Parallel computing with extensions","text":"analyses presented vignette used chains short length well limited number trial simulations. purely convenience. Study simulations real trials use considerably longer chains much higher number trial simulations. example apparent small number study simulations, overhead initializing cluster parallel computing, leads longer run time simulations comparison single core processing. However, relevant number study simulations, substantial run time benefit utilizing parallel computation can easily seen.","code":""},{"path":[]},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"setting-up-the-data","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Setting up the data","title":"Rolling CRM Example","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 3, 4, 5, 6, 6, 6)),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = rep(0, 8),   Tmax = 60 )  emptydata <- DataDA(   doseGrid = c(     0.1, 0.5, 1, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   Tmax = 60 )"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"structure-of-the-model-class","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Structure of the model class","title":"Rolling CRM Example","text":"","code":"npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 )"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"obtain-the-posterior","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Obtain the posterior","title":"Rolling CRM Example","text":"","code":"options <- McmcOptions(   burnin = 10,   step = 2,   samples = 1e2 )  set.seed(94) samples <- mcmc(data, model, options)"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"use-ggmcmc-to-diagnose","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Use ggmcmc to diagnose","title":"Rolling CRM Example","text":"","code":"library(ggmcmc) ## Loading required package: dplyr ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union ## Loading required package: tidyr ## Registered S3 method overwritten by 'GGally': ##   method from    ##   +.gg   ggplot2 alpha0samples <- get(samples, \"alpha0\")  print(ggs_traceplot(alpha0samples)) print(ggs_autocorrelation(alpha0samples))"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"plot-the-model-fit","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Plot the model fit","title":"Rolling CRM Example","text":"","code":"plot(samples, model, data, hazard = TRUE) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] plot(samples, model, data, hazard = FALSE) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"prior-mean-curve","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"prior mean curve","title":"Rolling CRM Example","text":"","code":"emptydata <- DataDA(doseGrid = c(   0.1, 0.5, 1.5, 3, 6,   seq(from = 10, to = 80, by = 2) ), Tmax = 60)  Priorsamples <- mcmc(emptydata, model, options)  plot(Priorsamples, model, emptydata, hazard = FALSE) ## TableGrob (1 x 2) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout]"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"escalation-rules","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Escalation rules","title":"Rolling CRM Example","text":"Need fill (use rule section 8 “using package crmPack: introductory examples”)","code":"myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  nextMaxDose <- maxDose(myIncrements, data = data)  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3)) mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3)) mySize <- maxSize(mySize1, mySize2)  myStopping1 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping2 <- StoppingMinPatients(nPatients = 50) myStopping <- (myStopping1 | myStopping2)"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"recommended-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Recommended dose for the next cohort","title":"Rolling CRM Example","text":"","code":"doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )   doseRecommendation$plot ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] doseRecommendation$value ## [1] 1.5"},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"set-up-safety-window-and-dadesign-to-be-completed","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up safety window and DADesign to be completed","title":"Rolling CRM Example","text":"","code":"mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"set-up-true-curves","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up true curves","title":"Rolling CRM Example","text":"","code":"myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from = 0, to = 100, ylim = c(0, 1)) onset <- 15 exp_cond.cdf <- function(x) {   1 - (pexp(x, 1 / onset, lower.tail = FALSE) - pexp(28, 1 / onset, lower.tail = FALSE)) / pexp(28, 1 / onset) }"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"perform-the-simulations","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Perform the simulations","title":"Rolling CRM Example","text":"","code":"mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf, # piece_exp_cond.cdf,   trueTmax = 80,   nsim = 2,   seed = 819,   mcmcOptions = options,   firstSeparate = TRUE,   deescalate = FALSE,   parallel = FALSE )"},{"path":"https://roche.github.io/crmPack/articles/rolling-crm.html","id":"interpret-the-simulation-results","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Interpret the simulation results","title":"Rolling CRM Example","text":"Use similar way section 9.2 “using package crmPack: introductory examples” document","code":"a <- summary(mySims, truth = myTruth) b <- mySims@data[[1]]  plot(mySims) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] plot(b) ## TableGrob (2 x 1) \"arrange\": 2 grobs ##   z     cells    name           grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (2-2,1-1) arrange gtable[layout] mySims@stop_reasons[[2]] ## [[1]] ## [1] \"Probability for target toxicity is 56 % for dose 14 and thus above the required 50 %\" ##  ## [[2]] ## [1] \"Number of patients is 17 and thus below the prespecified minimum number 50\" # nolint end"},{"path":"https://roche.github.io/crmPack/articles/simulations.html","id":"simulation-setting","dir":"Articles","previous_headings":"","what":"Simulation setting","title":"Simulation study example","text":"simulation study setting defined.","code":"id <- 1 onset <- 3 a0 <- 2 a1 <- 3 refDose <- 56  # True dose-DLT relationship myTruth <- function(dose) {   StandLogDose <- log(dose / refDose)   plogis(a0 + a1 * StandLogDose) }  # The conditional CDF of the PEM if (onset == 30) {   onset <- 15   exp_cond.cdf <- function(x) {     (pexp(42 - x, 1 / onset, lower.tail = FALSE) - pexp(Tmax_, 1 / onset, lower.tail = FALSE)) / pexp(Tmax_, 1 / onset)   } } else {   exp_cond.cdf <- function(x) {     1 - (pexp(x, 1 / onset, lower.tail = FALSE) - pexp(Tmax_, 1 / onset, lower.tail = FALSE)) / pexp(Tmax_, 1 / onset)   } }"},{"path":"https://roche.github.io/crmPack/articles/simulations.html","id":"design-definition","dir":"Articles","previous_headings":"","what":"Design definition","title":"Simulation study example","text":"dose escalation designs defined: example TITE-CRM used. Similarly code can adapted rolling-CRM.","code":"library(crmPack) ## Loading required package: ggplot2 ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example Tmax_ <- 42  model <- TITELogisticLogNormal(   mean = c(1.33, 1.49),   cov = matrix(c(1.826, 0.0209, 0.0209, 0.0245), nrow = 2),   ref_dose = refDose )  myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(10, 3) )  myNextBest <- NextBestMTD(   target = 0.3,   derive =     function(mtd_samples) {       mean(mtd_samples)     } )  myStopping <- StoppingMinPatients(nPatients = 48)  mySize <- CohortSizeConst(size = 3)  emptydata <- DataDA(doseGrid = seq(from = 2, to = 50, by = 2), Tmax = Tmax_)  mysafetywindow <- SafetyWindowConst(c(7, 7), 7, 7)  design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 8 )"},{"path":"https://roche.github.io/crmPack/articles/simulations.html","id":"simulation-run","dir":"Articles","previous_headings":"","what":"Simulation run","title":"Simulation study example","text":"order obtain stable results, increase simulation parameters appropriately (step, samples, nsim).","code":"options <- McmcOptions(   burnin = 20,   step = 1,   samples = 50 ) mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf,   trueTmax = 42,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Analysis","text":"vignette picks previous one (Trial Definition), ends. recap, trial defines six fundamental elements CRM trial ","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Introduction","what":"The dose grid","title":"Trial Analysis","text":"trial use dose grid consisting following doses: 1, 3, 9, 20, 30, 45, 60, 80 100. units doses defined irrelevant operation CRM.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Introduction","what":"The dose-toxicity model","title":"Trial Analysis","text":"trial uses logistic log Normal dose toxicity model \\[ log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta log(d_i / d^*) \\] prior joint distribution \\(\\alpha\\) \\(\\beta\\) \\[ \\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}. \\]","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-increment-rule","dir":"Articles","previous_headings":"Introduction","what":"The increment rule","title":"Trial Analysis","text":"maximum increment doses greater 0 less 20 100 x (1 + 1)%, 200% highest dose used far, whereas 20 , maximum increment 100 x (1 + 0.5)%, 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-selection-rule","dir":"Articles","previous_headings":"Introduction","what":"The dose selection rule","title":"Trial Analysis","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability overdose range - [0.35, 1.0] - less 0.25.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Introduction","what":"The cohort size","title":"Trial Analysis","text":"Whilst dose next cohort 20 less DLTs observed, minimum cohort size 1. Otherwise, 3.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-stopping-rule","dir":"Articles","previous_headings":"Introduction","what":"The stopping rule","title":"Trial Analysis","text":"trial stop either Twenty patients recruited, . least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"trial-definition","dir":"Articles","previous_headings":"Introduction","what":"Trial definition","title":"Trial Analysis","text":"code define elements trial design given Trial Definition vignette.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"analysing-a-trial","dir":"Articles","previous_headings":"","what":"Analysing a trial","title":"Trial Analysis","text":"Given trial design constructed , process analysing real life instance trial simply matter providing model actual toxicity status participants treated far. escalation rules defined earlier allow use single patient run-either first DLT observed dose 20 administered.","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-single-patient-run-in","dir":"Articles","previous_headings":"Analysing a trial","what":"The single patient run-in","title":"Trial Analysis","text":"Assume first three patients - dosed 1, 3 5 - completed trial without incident, fourth patient - treated 10 - experienced DLT. provide information crmPack via Data object: Within Data object, doses patient treated given x slot toxicity status (Boolean toxicity represented truthy value) y slot. observed data easily visualised  , since plot method returns ggplot object, easily customised.  Now, update model obtain posterior estimate dose-toxicity curve: posterior estimate dose toxicity curve easily visualised:  visual representation model’s state obtained : lower panel plot shows posterior probability dose overdose range. dashed horizontal black line shows acceptable risk overdose: Doses red lines go line considered toxic. upper panel shows probability dose target toxicity range. Clearly, doses 30 45 highest probability target toxicity range. However, risk overdose range unacceptable. Therefore, 20 dose recommended next cohort. can produce tabulation model state presentations, can see : highest dose far administered 20, escalation rule permits doses including 40 considered dose next cohort. However… Doses 30 considered unsafe remaining doses, 20 highest posterior probability target toxicity range DLT reported Items 1 4 list tell us size next cohort three. Items 2 3 together imply highest dose can used next cohort 20. Thus, model’s recommendation next cohort consist three patients, treated 20. can confirmed programmatically: However, given probability 20 overdose range just less threshold 0.25 (participant far treated 20 experienced DLT) perfectly reasonable clinical decision treat next cohort 10 - , indeed, dose 20. absolutely obligation follow CRM dose recommendation without consideration factors might affect choice appropriate dose next cohort. However, purpose exposition, treat next cohort 20, recommended model. can confirm trial’s stopping rules satisfied:","code":"firstFour <- Data(   x = c(1, 3, 9, 20),   y = c(0, 0, 0, 1),   ID = 1:4,   cohort = 1:4,   doseGrid = doseGrid ) plot(firstFour) plot(firstFour) + theme_light() vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) postSamples <- mcmc(   data = firstFour,   model = model,   options = vignetteMcmcOptions ) plot(postSamples, model, firstFour) nextBest(   my_next_best,   doselimit = 100,   samples = postSamples,   model = model,   data = empty_data )$plot #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (2-2,1-1) arrange gtable[layout] tabulatePosterior <- function(mcmcSamples, observedData) {   as_tibble(     nextBest(       my_next_best,       doselimit = 100,       samples = mcmcSamples,       model = model,       data = observedData     )$probs   ) %>%     left_join(       tibble(         dose = observedData@x,         WithDLT = observedData@y       ) %>%         group_by(dose) %>%         summarise(           Treated = n(),           WithDLT = sum(WithDLT),           .groups = \"drop\"         ),       by = \"dose\"     ) %>%     replace_na(list(Treated = 0, WithDLT = 0)) %>%     select(dose, Treated, WithDLT, target, overdose) %>%     kableExtra::kable(       col.names = c(\"Dose\", \"Treated\", \"With DLT\", \"Target range\", \"Overdose range\"),       digits = c(0, 0, 0, 3, 3)     ) %>%     kableExtra::add_header_above(c(\" \" = 1, \"Participants\" = 2, \"Probability that dose is in \" = 2)) }  tabulatePosterior(postSamples, firstFour) nextMaxDose <- maxDose(my_increments, firstFour) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples,   model = model,   data = firstFour ) doseRecommendation$value #> [1] 20 stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples,   model,   firstFour ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 29 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 4 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 29 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 29 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 4 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-first-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The first full cohort","title":"Trial Analysis","text":"Assume none three patients first full cohort report DLT: Update model: Tabulate posterior: trial stop? , dose used next cohort? trial continue, treating three patients next cohort 30.","code":"firstFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20),   y = c(0, 0, 0, 1, 0, 0, 0),   ID = 1:7,   cohort = c(1:4, rep(5, 3)),   doseGrid = doseGrid ) postSamples1 <- mcmc(   data = firstFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples1, firstFullCohort) nextMaxDose <- maxDose(my_increments, firstFullCohort) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples1,   model = model,   data = firstFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples1,   model,   firstFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-second-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The second full cohort","title":"Trial Analysis","text":"Assume none three patients next cohort report DLT: Update model: Tabulate posterior: dose highest posterior probability target toxicity range now 45, dose also unacceptably high probability overdose range. Therefore, trial continue next cohort treated 30:","code":"secondFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20, 30, 30, 30),   y = c(0, 0, 0, 1, 0, 0, 0, 0, 0, 0),   ID = 1:10,   cohort = c(1:4, rep(5, 3), rep(6, 3)),   doseGrid = doseGrid ) postSamples2 <- mcmc(   data = secondFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples2, secondFullCohort) nextMaxDose <- maxDose(my_increments, secondFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples2,   model = model,   data = secondFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples2,   model,   secondFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-third-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The third full cohort","title":"Trial Analysis","text":"Assume none three patients third cohort report DLT: Update model: Tabulate posterior: 45 still dose highest posterior probability target toxicity range, probability overdose range now acceptable. Therefore, trial continue next cohort treated 45:","code":"thirdFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6)),   y = c(0, 0, 0, 1, rep(0, 9)),   ID = 1:13,   cohort = c(1:4, rep(5, 3), rep(6, 3), rep(7, 3)),   doseGrid = doseGrid ) postSamples3 <- mcmc(   data = thirdFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples3, thirdFullCohort) nextMaxDose <- maxDose(my_increments, thirdFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples3,   model = model,   data = thirdFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples3,   model,   thirdFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-fourth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fourth full cohort","title":"Trial Analysis","text":"Assume none three patients fourth cohort report DLT: Update model: Tabulate posterior: 60 now dose highest posterior probability target toxicity range, probability overdose range unacceptable. Therefore, trial continue next cohort treated 45:","code":"fourthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 3)),   y = c(0, 0, 0, 1, rep(0, 12)),   ID = 1:16,   cohort = c(1:4, rep(5:8, each = 3)),   doseGrid = doseGrid ) postSamples4 <- mcmc(   data = fourthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples4, fourthFullCohort) nextMaxDose <- maxDose(my_increments, fourthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples4,   model = model,   data = fourthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples4,   model,   fourthFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"the-fifth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fifth full cohort","title":"Trial Analysis","text":"Assume two three patients fourth cohort report DLT: Update model: Tabulate posterior: 45 remains dose highest posterior probability target toxicity range, probability overdose range acceptable. Moreover, probability 45 target toxicity range 0.5 three cohorts treated total. Therefore, trial stop conclude 45 MTD:","code":"fifthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 6)),   y = c(0, 0, 0, 1, rep(0, 13), 1, 1),   ID = 1:19,   cohort = c(1:4, rep(5:9, each = 3)),   doseGrid = doseGrid ) postSamples5 <- mcmc(   data = fifthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples5, fifthFullCohort) nextMaxDose <- maxDose(my_increments, fifthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples5,   model = model,   data = fifthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples5,   model,   fifthFullCohort ) x #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 56 % for dose 45 and thus above the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 19 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 56 % for dose 45 and thus above the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 56 % for dose 45 and thus above the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 19 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"summarising-the-trial-results","dir":"Articles","previous_headings":"","what":"Summarising the trial results","title":"Trial Analysis","text":"crmPack provides wealth information trial’s results. following code snippets illustrate many possibilities trial might summarised.   little bit work, can obtain detailed summary plot posterior probabilities toxicity dose:","code":"plot(fifthFullCohort) plot(postSamples5, model, fifthFullCohort) doseRecommendation$plot #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (2-2,1-1) arrange gtable[layout] slotNames(model) #> [1] \"params\"          \"ref_dose\"        \"datamodel\"       \"priormodel\"      #> [5] \"modelspecs\"      \"init\"            \"datanames\"       \"datanames_prior\" #> [9] \"sample\"  fullSamples <- tibble(   Alpha = postSamples5@data$alpha0,   Beta = postSamples5@data$alpha1 ) %>%   expand(nesting(Alpha, Beta), Dose = doseGrid) %>%   rowwise() %>%   mutate(P = probFunction(model, alpha0 = Alpha, alpha1 = Beta)(dose = Dose)) %>%   ungroup()  fullSummary <- fullSamples %>%   group_by(Dose) %>%   summarise(     Mean = mean(P),     Median = median(P),     Q = list(quantile(P, probs = c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95), na.rm = TRUE))   ) %>%   unnest_wider(     col = Q,     names_repair = function(.x) {       ifelse(         str_detect(.x, \"\\\\d+%\"),         sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))),         .x       )     }   ) #> Warning in sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))): NAs #> introduced by coercion  fullSummary %>%   kableExtra::kable(     col.names = c(\"Dose\", \"Mean\", \"Median\", \"5th\", \"10th\", \"25th\", \"75th\", \"90th\", \"95th\"),     digits = c(0, rep(3, 8))   ) %>%   add_header_above(c(\" \" = 3, \"Quantiles\" = 6)) %>%   add_header_above(c(\" \" = 1, \"P(Toxicity)\" = 8)) fullSamples %>%   filter(Dose > 9) %>%   ggplot() +   geom_density(aes(x = P, color = as.factor(Dose))) +   theme_light() +   theme(     axis.text.y = element_blank(),     axis.title.y = element_blank(),     axis.ticks.y = element_blank()   ) +   labs(     title = \"Posterior PDFs for doses > 9\",     colour = \"Dose\"   ) fullSummary %>%   ggplot(aes(x = Dose)) +   geom_ribbon(aes(ymin = Q05, ymax = Q95), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q10, ymax = Q90), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q25, ymax = Q75), fill = \"steelblue\", alpha = 0.25) +   geom_line(aes(y = Mean), colour = \"black\") +   geom_line(aes(y = Median), colour = \"blue\") +   theme_light() +   labs(     title = \"Posterior Dose toxicity curve\",     colour = \"Dose\",     y = \"P(Toxicity)\"   )"},{"path":"https://roche.github.io/crmPack/articles/trial_analysis.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Trial Analysis","text":"analyses presented vignette used chains short length. purely convenience. Analyses real trials use considerably longer chains. example, effective sample size approximately 40,000 required estimate percentage within ±1%.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"defining-the-design","dir":"Articles","previous_headings":"","what":"Defining the design","title":"Trial Definition","text":"CRM study consists six basic elements: dose grid dose-toxicity model increment rule_1 dose recommendation rule1 cohort size1 stopping rule 1: Note crmPack, increment, dose selection cohort size rules collectively known escalation rules. many, many possible choices element. introduction, make simple choices value element. start loading crmPack package … … defining element turn.","code":"library(crmPack) #> Loading required package: ggplot2 #> Type crmPackHelp() to open help browser #> Type crmPackExample() to open example"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Defining the design","what":"The dose grid","title":"Trial Definition","text":"First, list doses might used trial. commitment use every dose grid. define grid 9 doses ranging 1 100. crmPack agnostic respect units used measure doses. requirements dose grid ordered one dimensional. Additional doses can added whilst trial running. affect validity results trial prior addition, probably affect trial’s operating characteristics.","code":"# Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 9, 20, 30, 45, 60, 80, 100))"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Defining the design","what":"The dose toxicity model","title":"Trial Definition","text":"Next, define dose toxicity model. crmPack, LogisticLogNormal class fits model following form: \\[log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta log(d_i / d^*)\\] \\(d^*\\) reference dose (specified ref_dose argument LogisticLogNormal function ) prior joint distribution \\(\\alpha\\) \\(\\beta\\) \\[\\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} \\mu_{\\alpha}\\\\ \\mu_{\\beta} \\end{bmatrix}   , \\begin{bmatrix} \\sigma_{\\alpha\\alpha} & \\sigma_{\\alpha\\beta} \\\\ \\sigma_{{\\beta\\alpha}} & \\sigma_{\\beta\\beta} \\end{bmatrix}    \\end{pmatrix}. \\] mean covariance matrices defined mean cov parameters LogisticLogNormal call. code defines prior joint distribution \\(\\alpha\\) \\(log(\\beta)\\) \\[ N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}. \\] easy obtain visual representation prior:","code":"# Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 ) vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) prior_samples <- mcmc(   data = empty_data,   model = model,   options = vignetteMcmcOptions ) plot(prior_samples, model, empty_data)"},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-maximum-increment","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The maximum increment","title":"Trial Definition","text":"Now, define maximum possible increment dose used current cohort dose used next, regardless likely toxicity. rule chosen defines maximum possible increment terms multiples highest dose far administered: doses greater 0 less 20, maximum increment 100 x (1 + 1)%, 200% highest dose used far. doses 20 , maximum increment 100 x (1 + 0.5)%, 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation. tabular form, based dose grid defined , maximum permitted escalation , highest dose used far 9, highest dose dose grid can used next cohort 20, even 30 higher doses deemed safe NextBest rule. Next, define rule choosing best dose next cohort","code":"# Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 30),   increments = c(1, 0.5) )"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-nextbest-rule-for-recommending-the-best-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The NextBest rule for recommending the best dose for the next cohort","title":"Trial Definition","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability toxicity overdose range - [0.35, 1.0] - less 0.25.","code":"# Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The cohort size","title":"Trial Definition","text":"Now, define rule choosing size next cohort. Note, term “cohort size” somewhat anachronistic. hangover days 3+3 design. context CRM trials, best interpreted “largest permitted interval CRM model updates”. CRM trial, model can updated time mathematical need halt recruitment allow model updated. elect define cohort size using compound rule. dose used number DLTs far observed contribute decision. first part compound rule (my_size_1), based dose used, permits use single patient run-including dose 20. doses 20, minimum cohort size 3. second part compound rule (my_size_2) also permits single patient run-, long DLTs far observed. soon first DLT reported, minimum cohort size 3. determine actual size next cohort, larger number required two parts compound rule used. words, provided dose 20 DLTs observed, single patient cohort permitted. cases, required cohort size 3.","code":"# Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-stopping-rules","dir":"Articles","previous_headings":"Defining the design","what":"The stopping rules","title":"Trial Definition","text":"Now create rules define trial’s objectives met (stopped futility). futility rule easiest explain: twenty patients recruited, study stop (my_stopping_3). success rule requires following conditions met: least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5. trial stop either futility rule components success rule satisfied.","code":"# Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3"},{"path":"https://roche.github.io/crmPack/articles/trial_definition.html","id":"the-overall-trial-design","dir":"Articles","previous_headings":"Defining the design","what":"The overall trial design","title":"Trial Definition","text":"Finally, combine six elements design, together starting dose, define trial. now ready use trial definition, either analyse real trial simulate long term operating characteristics design. processes described vignettes .","code":"# Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )"},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/trial_sanity_checks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Design: basic sanity checks","text":"vignette contains example basic superficial examination operating characteristics basic CRM trial. design uses 2-parameter logistic regression model log normal prior distribution, custom rules choosing cohort size, deciding whether stop continue trial, defining maximum permitted increment selecting dose nest study. first step define trial design crmPack…","code":""},{"path":"https://roche.github.io/crmPack/articles/trial_sanity_checks.html","id":"study-definition","dir":"Articles","previous_headings":"","what":"Study definition","title":"Trial Design: basic sanity checks","text":"","code":"library(crmPack)   # Define the dose grid and an empty data object dose_grid <- c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100) empty_data <- Data(doseGrid = dose_grid)  # Initialize the CRM model. initial_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. cohort_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) cohort_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) cohort_size <- maxSize(cohort_size1, cohort_size2)  # Choose the rule for stopping. stopping_success1 <- StoppingMinCohorts(nCohorts = 3) stopping_success2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) stopping_futility <- StoppingMinPatients(nPatients = 20) stopping_trial <- (stopping_success1 & stopping_success2) | stopping_futility  # Choose the rule for dose increments. increment_rule <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = initial_model,   nextBest = next_best,   stopping = stopping_trial,   increments = increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/articles/trial_sanity_checks.html","id":"incoherence-and-rigidity","dir":"Articles","previous_headings":"","what":"Incoherence and rigidity","title":"Trial Design: basic sanity checks","text":"examine function lists dose recommendations made CRM design first DLT reported. output shows, dose number DLTs reported, dose recommendation (nextBest dose) made model assumption earlier DLTs reported lower doses. Cheung (Cheung 2013) (p146) describes CRM trial* rigid exists dose escalation possible regardless number participants experience treated dose. (p164) defines CRM trial incoherent , among criteria, recommends dose escalation immediately following first report DLT. *: Strictly, Cheung defines incoherence rigidity terms trial’s dose-toxicity model. extend terms include trial’s design features, including escalation, dose selection, increments stopping rules. output examine shows initial design incoherent (recommendation increase dose used next cohort following first report DLT), rigid. rigid , even toxicities reported 25 mg, model unable recommend escalation trial’s futility stopping rule (defined stopping_futility ) satisfied. clearly unsatisfactory. problem lies increments rule, allows maximum escalation 33% one dose next doses 20 mg. dose grid used 1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100. ratio 20 25 1.25, 25 40 1.6. can confirm checking behaviour maxDose artificial data: Thus, initial dose rule permanently prevents escalation 25 mg highest permitted dose 25 mg 33.25 lowest dose dose grid 40. problem can solved least two ways: can either relax increments rule can introduce one intermediate doses. (, course, .) choose relax increments rule check , ceteris paribus, permits escalation every dose: Yes, . update design:","code":"examine(design) %>% kable() no_tox_below_25_data <- Data(   doseGrid = dose_grid,   x = c(1, 3, 5, 10, 15, 20, 25),   y = rep(0, 7),   ID = 1L:7L,   cohort = 1L:7L )  next_dose <- maxDose(increment_rule, no_tox_below_25_data) next_dose #> [1] 33.25 revised_increment_rule <- IncrementsRelative(   intervals = c(0, 20, 80),   increments = c(1, 0.67, 0.33) ) tibble(   HighestDoseUsed = dose_grid,   MaxPermittedDose = c(     NA,     sapply(       seq_along(dose_grid[-1]),       function(n) {         tmp <- dose_grid[-1]         d <- Data(           doseGrid = dose_grid,           x = tmp[1:n],           y = rep(0, n),           ID = as.integer(1:n),           cohort = as.integer(1:n)         )         maxDose(revised_increment_rule, d)       }     )   ) ) %>%   mutate(EscalationPermitted = lead(HighestDoseUsed < MaxPermittedDose)) %>%   kable() revised_design <- Design(   model = initial_model,   nextBest = next_best,   stopping = stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/articles/trial_sanity_checks.html","id":"does-the-prior-make-sense","dir":"Articles","previous_headings":"","what":"Does the prior make sense?","title":"Trial Design: basic sanity checks","text":"Hmmm. now appear stuck 50 mg. ? Let’s examine state model escalation 50 mg without toxicity… Whilst increments rule allows escalation 83.5 mg, toxicity estimates provided model : current estimate toxicity 80 mg 0.778, well limit 0.25 defined dose recommendation rule (next_best). , several options. can introduce intermediate doses, thus slowing escalation allowing prior model time adapt (probably requiring larger trial), can modify prior allows faster, still reasonable, escalation. Let’s try creating minimally informative prior consistent first attempt. minimally informative model prior distribution \\[\\binom{\\alpha}{log(\\beta)} \\sim N \\left( \\left[\\begin{array}{rr} 0.979 \\\\  1.348 \\end{array}\\right], \\left[\\begin{array}{rr}  1.923 &  0.045 \\\\  0.045 &  0.002\\end{array}\\right]\\right)\\] fix rigidity problem? Yes, . can now escalate dose 80, plateaux . First, two toxicity-free participants, rather just one, needed escalate 20 mg 25 mg. Similarly, four toxicity-free participants required escalate 25 mg 40 mg. fine tuning prior probably allow numbers reduced, purposes vignette, explore possibility. Now create data represent trial escalates without reports toxicity, fit revised model … importantly, results illustrate something obvious outset: expecting trial identify MTD definitively fewer 20 participants unrealistic (unless MTD much towards left hand - lower - end dose grid) takes almost 20 participants travel lower end dose grid upper. Ignoring plateauing mentioned previous paragraph, increments rule defined means need least one participant doses 1, 3, 5, 10, 15 20 mg, three 25, 40, 50, 80 100 mg. ’s total 6 x 1 + 5 x 3 = 21 participants. hit futility limit finish escalation dose grid, even DLTs reported. ’s simply realistic. final alteration increase futility rule 20 participants 40. new design allows us escalate full extent dose grid futility stopping rule kicks . refinement prior model may remove need additional cohorts escalation 20, 25 50 mg. leave exercise reader. now design worthy detailed investigation operating characteristics. next vignette series, yet written.","code":"examine(revised_design) %>% kable() no_tox_below_50_data <- Data(   doseGrid = dose_grid,   x = c(1, 3, 5, 10, 15, 20, 25, 40, 40, 40, 50, 50, 50),   y = rep(0, 13),   ID = 1L:13L,   cohort = c(1L:7L, rep(8L:9L, each = 3)) )  default_mcmc_options <- McmcOptions(burnin = 1000, step = 2, samples = 1000) no_tox_50_samples <- mcmc(no_tox_below_50_data, initial_model, default_mcmc_options) recommended_dose <- nextBest(   next_best,   doselimit = Inf,   samples = no_tox_50_samples,   model = initial_model,   data = no_tox_below_50_data ) recommended_dose$value #> [1] 50 recommended_dose$probs #>       dose target overdose #>  [1,]    1  0.000    0.000 #>  [2,]    3  0.000    0.000 #>  [3,]    5  0.000    0.000 #>  [4,]   10  0.000    0.000 #>  [5,]   15  0.000    0.000 #>  [6,]   20  0.000    0.000 #>  [7,]   25  0.000    0.000 #>  [8,]   40  0.037    0.000 #>  [9,]   50  0.156    0.016 #> [10,]   80  0.157    0.778 #> [11,]  100  0.089    0.885  maxDose(revised_increment_rule, no_tox_below_50_data) #> [1] 83.5 # Fitting the min_inf_model is slow. if (file.exists(\"minInfModel.Rds\")) {   min_inf_model <- readRDS(\"minInfModel.Rds\") } else {   min_inf_model <- MinimalInformative(     dose_grid,     56,     threshmin = 0.1,     threshmax = 0.4,     probmin = 0.05,     probmax = 0.05   )    as_tibble(min_inf_model$required) %>%     add_column(Dose = dose_grid) %>%     add_column(Type = \"Required\") %>%     bind_rows(       as_tibble(min_inf_model$quantiles) %>%         add_column(Dose = dose_grid) %>%         add_column(Type = \"Fitted\")     ) %>%     ggplot() +     geom_line(aes(x = Dose, y = median, colour = Type), linetype = \"solid\") +     geom_line(aes(x = Dose, y = lower, colour = Type), linetype = \"dotted\") +     geom_line(aes(x = Dose, y = upper, colour = Type), linetype = \"dotted\")    saveRDS(min_inf_model, \"minInfModel.Rds\") }  min_inf_model$model@params #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #>             meanAlpha.(Intercept) meanBeta.I(log(dosegrid/refDose))  #>                         0.9794332                         1.3478525  #>  #> Slot \"cov\": #>            [,1]        [,2] #> [1,] 1.92349350 0.045004741 #> [2,] 0.04500474 0.002019231 #>  #> Slot \"prec\": #>            [,1]       [,2] #> [1,]   1.086455  -24.21497 #> [2,] -24.214974 1034.94305 revised_model <- min_inf_model$model  revised_design1 <- Design(   model = revised_model,   nextBest = next_best,   stopping = stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )  examine(revised_design1) %>% kable() no_tox_data <- Data(   doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),   x = c(c(1, 3, 5, 10, 15, 20), rep(c(25, 40, 50, 80, 100), each = 3)),   y = rep(0, 21),   cohort = as.integer(c(1:6, rep(7:11, each = 3))),   ID = as.integer(1:21) )  no_tox_samples <- mcmc(no_tox_data, revised_model, default_mcmc_options)  recommended_dose <- nextBest(   next_best,   doselimit = Inf,   samples = no_tox_samples,   model = initial_model,   data = no_tox_data ) recommended_dose$probs #>       dose target overdose #>  [1,]    1  0.000    0.000 #>  [2,]    3  0.000    0.000 #>  [3,]    5  0.000    0.000 #>  [4,]   10  0.000    0.000 #>  [5,]   15  0.000    0.000 #>  [6,]   20  0.000    0.000 #>  [7,]   25  0.000    0.000 #>  [8,]   40  0.000    0.000 #>  [9,]   50  0.005    0.000 #> [10,]   80  0.185    0.000 #> [11,]  100  0.313    0.024  stopTrial(stopping_trial, recommended_dose$value, no_tox_samples, initial_model, no_tox_data) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 31 % for dose 100 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 21 and thus reached the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 31 % for dose 100 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 31 % for dose 100 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of patients is 21 and thus reached the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA revised_stopping_futility <- StoppingMinPatients(nPatients = 40) revised_stopping_trial <- (stopping_success1 & stopping_success2) | revised_stopping_futility  revised_design2 <- Design(   model = revised_model,   nextBest = next_best,   stopping = revised_stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/articles/trial_sanity_checks.html","id":"final-observation","dir":"Articles","previous_headings":"","what":"Final observation","title":"Trial Design: basic sanity checks","text":"simulations used vignette used relatively short chains 1000 samples, purely interests speed. investigating properties real trial, much longer chain lengths used. example, estimate binomial probability accuracy ±1%, effective sample size (ESS) around 40,000 required.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/articles/trial_simulation.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Trial Simulation","text":"basic example shows run simulations CRM 2-parameter logistic regression model, using log normal prior distribution, custom cohort size, stopping maximum increments rules:","code":"library(crmPack)  # Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)  # Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )  # Define the true function. my_truth <- function(dose) {   alpha0 <- 7   alpha1 <- 8   ref_dose <- 56   stand_log_dose <- log(dose / ref_dose)   plogis(alpha0 + alpha1 * stand_log_dose) }  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course. options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 ) time <- system.time(my_sims <- simulate(design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]"},{"path":"https://roche.github.io/crmPack/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Sabanes Bove. Author, maintainer. Wai Yin Yeung. Author. Burak Kuersad Guenhan. Author. Giuseppe Palermo. Author. Thomas Jaki. Author. Jiawen Zhu. Author. Ziwei Liao. Author. Dimitris Kontos. Author. Marlene Schulte-Goebel. Author. Doug Kelkhoff. Author. Oliver Boix. Author. Robert Adams. Author. Clara Beck. Author. John Kirkpatrick. Author. F. Hoffmann-La Roche AG. Copyright holder, funder. Merck Healthcare KGaA. Copyright holder, funder. Bayer AG. Copyright holder, funder.","code":""},{"path":"https://roche.github.io/crmPack/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sabanés Bové D, Yeung WY, Palermo G, Jaki T (2019). “Model-Based Dose Escalation Designs R crmPack.” Journal Statistical Software, 89(10), 1–22. doi:10.18637/jss.v089.i10.","code":"@Article{,   title = {Model-Based Dose Escalation Designs in {R} with {crmPack}},   author = {Daniel {Saban\\'es Bov\\'e} and Wai Yin Yeung and Giuseppe Palermo and Thomas Jaki},   journal = {Journal of Statistical Software},   year = {2019},   volume = {89},   number = {10},   pages = {1--22},   doi = {10.18637/jss.v089.i10}, }"},{"path":"https://roche.github.io/crmPack/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Object-Oriented Implementation of CRM Designs","text":"can install development version crmPack github : can install stable release version crmPack CRAN :","code":"devtools::install_github(\"Roche/crmPack\") install.packages(\"crmPack\")"},{"path":"https://roche.github.io/crmPack/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Object-Oriented Implementation of CRM Designs","text":"package vignettes provide information various aspects CRM trial design, implementation, simulation analysis: Trial definition Trial analysis Sanity checking Simulation operating characteristics Extending crmPack Migration old crmPack Sabanes Bove et al (2019) Model-based Dose Escalation Designs R crmPack. JSS 89:10 DOI 10.18637/jss.v089.i10","code":""},{"path":"https://roche.github.io/crmPack/pull_request_template.html","id":null,"dir":"","previous_headings":"","what":"Pull Request","title":"Pull Request","text":"Fixes #nnn","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSize — .DefaultCohortSize","title":"CohortSize — .DefaultCohortSize","text":"CohortSize class cohort sizes.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSize — .DefaultCohortSize","text":"","code":".DefaultCohortSize()  .DefaultCohortSize()"},{"path":"https://roche.github.io/crmPack/reference/CohortSize-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSize — .DefaultCohortSize","text":"Typically, end users use DefaultCohortSize() function. Typically, end users use DefaultCohortSize() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeConst — CohortSizeConst-class","title":"CohortSizeConst — CohortSizeConst-class","text":"CohortSizeConst class fixed constant size cohort.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"CohortSizeConst(size)  .DefaultCohortSizeConst()"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeConst — CohortSizeConst-class","text":"size (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeConst — CohortSizeConst-class","text":"size (integer) cohort size.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeConst — CohortSizeConst-class","text":"Typically, end users use .DefaultCohortSizeConst() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"# Cohort of size 3, constant along the study. my_size <- CohortSizeConst(size = 3)"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeDLT — CohortSizeDLT-class","title":"CohortSizeDLT — CohortSizeDLT-class","text":"CohortSizeDLT class cohort size based number DLTs.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"CohortSizeDLT(intervals, cohort_size)  .DefaultCohortSizeDLT()"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeDLT — CohortSizeDLT-class","text":"intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeDLT — CohortSizeDLT-class","text":"intervals (integer) vector left bounds relevant DLT intervals. cohort_size (integer) vector cohort sizes corresponding elements intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeDLT — CohortSizeDLT-class","text":"Typically, end users use .DefaultCohortSizeDLT() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"# Rule for having cohort of size 1 until no DLT is observed and having cohort # of size 3 as soon as 1 DLT is observed. my_size <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMax — CohortSizeMax-class","title":"CohortSizeMax — CohortSizeMax-class","text":"CohortSizeMax class cohort size based maximum multiple cohort size rules. cohort_sizes slot stores set cohort size rules, objects class CohortSize. maximum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":".DefaultCohortSizeMax()  CohortSizeMax(cohort_sizes)"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_sizes (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_sizes (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeMax — CohortSizeMax-class","text":"Typically, end users use .DefaultCohortSizeMax() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMax' which will then be combined with # the 'max' operation. mySize <- CohortSizeMax(cohort_sizes = list(my_size1, my_size2))"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMin — CohortSizeMin-class","title":"CohortSizeMin — CohortSizeMin-class","text":"CohortSizeMin class cohort size based minimum multiple cohort size rules. cohort_sizes slot stores set cohort size rules, objects class CohortSize. minimum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"CohortSizeMin(cohort_sizes)  .DefaultCohortSizeMin()"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_sizes (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_sizes (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeMin — CohortSizeMin-class","text":"Typically, end users use .DefaultCohortSizeMin() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMin' which will then be combined with # the 'min' operation. my_size <- CohortSizeMin(cohort_sizes = list(my_size1, my_size2))"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeParts — CohortSizeParts-class","title":"CohortSizeParts — CohortSizeParts-class","text":"CohortSizeParts class cohort size changes second part dose escalation. works conjunction DataParts objects.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"CohortSizeParts(cohort_sizes)  .DefaultCohortSizeParts()"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeParts — CohortSizeParts-class","text":"cohort_sizes (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeParts — CohortSizeParts-class","text":"cohort_sizes (integer) vector length two two sizes, one part 1, one part 2 respectively.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeParts — CohortSizeParts-class","text":"Typically, end users use .DefaultCohortSizeParts() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"# Part 1 cohort size = 1, Part 2 cohort size = 3. my_size <- CohortSizeParts(cohort_sizes = c(1, 3))"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeRange — CohortSizeRange-class","title":"CohortSizeRange — CohortSizeRange-class","text":"CohortSizeRange class cohort size based dose range.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"CohortSizeRange(intervals, cohort_size)  .DefaultCohortSizeRange()"},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) vector left bounds relevant dose intervals. cohort_size (integer) integer vector cohort sizes corresponding elements intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeRange — CohortSizeRange-class","text":"Typically, end users use .DefaultCohortSizeRange() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/CohortSizeRange-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"# Example for the rule having cohort of size 1 for doses <30 # and having cohort of size 3 for doses >=30.  my_size <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))"},{"path":"https://roche.github.io/crmPack/reference/CrmPackClass.html","id":null,"dir":"Reference","previous_headings":"","what":"CrmPackClass — CrmPackClass-class","title":"CrmPackClass — CrmPackClass-class","text":"CrmPackClass virtual class, crmPack classes inherit.","code":""},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DADesign — DADesign-class","title":"DADesign — DADesign-class","text":"class special requirements model data slots comparison parent class Design:","code":""},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DADesign — DADesign-class","text":"","code":"DADesign(model, data, safetyWindow, ...)  .DefaultDADesign()"},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DADesign — DADesign-class","text":"model (GeneralModel) see slot definition. data (DataDA) see slot definition. safetyWindow (SafetyWindow) see slot definition. ... Arguments passed Design stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DADesign — DADesign-class","text":"model (GeneralModel) model use, see particular DALogisticLogNormal TITELogisticLogNormal make use time--DLT data. data (DataDA) dose grid, previous data, etc. safetyWindow (SafetyWindow) safety window apply cohorts.","code":""},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DADesign — DADesign-class","text":"Typically, end users use .DefaultDADesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DADesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DADesign — DADesign-class","text":"","code":"empty_data <- DataDA(doseGrid = c(   0.1, 0.5, 1, 1.5, 3, 6,   seq(from = 10, to = 80, by = 2) ), Tmax = 60)  npiece <- 10 t_max <- 60  lambda_prior <- function(k) {   npiece / (t_max * (npiece - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece,   l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),   c_par = 2 )  my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) )  my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  my_size <- maxSize(my_size1, my_size2)  my_stopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 )  my_stopping2 <- StoppingMinPatients(nPatients = 50)  my_stopping <- (my_stopping1 | my_stopping2)  my_safety_window <- SafetyWindowConst(c(6, 2), 7, 7)  design <- DADesign(   model = model,   increments = my_increments,   nextBest = my_next_best,   stopping = my_stopping,   cohort_size = my_size,   data = empty_data,   safetyWindow = my_safety_window,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DALogisticLogNormal — DALogisticLogNormal-class","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"DALogisticLogNormal class logistic model bivariate (log) normal prior data augmentation. class inherits LogisticLogNormal class.","code":""},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"DALogisticLogNormal(npiece = 3, l, c_par = 2, cond_pem = TRUE, ...)  .DefaultDALogisticLogNormal()"},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"still need include formula lambda prior. Typically, end users use .DefaultDALogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"npiece <- 10 Tmax <- 60 # nolintr  lambda_prior <- function(k) {   npiece / (Tmax * (npiece - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece,   l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),   c_par = 2 )"},{"path":"https://roche.github.io/crmPack/reference/DASimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the simulations output from DA based designs — DASimulations-class","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"class captures trial simulations DA based designs. comparison parent class Simulations, contains additional slots capture time DLT fits, additional parameters trial duration.","code":""},{"path":"https://roche.github.io/crmPack/reference/DASimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"","code":".DefaultDASimulations()"},{"path":"https://roche.github.io/crmPack/reference/DASimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"trialduration vector trial duration values simulations.","code":""},{"path":"https://roche.github.io/crmPack/reference/DASimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"Typically, end users use .DASimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DASimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for DASimulations — DASimulations","title":"Initialization function for DASimulations — DASimulations","text":"Initialization function DASimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/DASimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for DASimulations — DASimulations","text":"","code":"DASimulations(trialduration, ...)"},{"path":"https://roche.github.io/crmPack/reference/DASimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for DASimulations — DASimulations","text":"trialduration see DASimulations ... additional parameters Simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/DASimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for DASimulations — DASimulations","text":"DASimulations object","code":""},{"path":"https://roche.github.io/crmPack/reference/DLTLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of DLTs in each interval — DLTLikelihood","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"helper function fitPEM methods .","code":""},{"path":"https://roche.github.io/crmPack/reference/DLTLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"","code":"DLTLikelihood(lambda, Tmax)"},{"path":"https://roche.github.io/crmPack/reference/DLTLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"lambda vector piecewise hazards Tmax end time interval DLTs","code":""},{"path":"https://roche.github.io/crmPack/reference/DLTLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"vector probabilities DLTs within intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data — Data-class","title":"Data — Data-class","text":"Data class data input. inherits GeneralData.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data — Data-class","text":"","code":"Data(   x = numeric(),   y = integer(),   ID = integer(),   cohort = integer(),   doseGrid = numeric(),   placebo = FALSE,   ... )  .DefaultData()"},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1). can also supply numeric vectors, converted integer internally. ID (integer) unique patient IDs. can also supply numeric vectors, converted integer internally. cohort (integer) cohort (non-negative sorted) indices. can also supply numeric vectors, converted integer internally. doseGrid (numeric) possible doses. placebo (flag) TRUE first dose level doseGrid considered placebo. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data — Data-class","text":"cohort can missing placebo equal FALSE.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1 integers). doseGrid (numeric) vector possible doses (sorted), .e. dose grid. nGrid (integer) number gridpoints. xLevel (integer) levels doses patients given, w.r.t doseGrid. placebo (logical) TRUE first dose level doseGridis considered PLACEBO.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Data — Data-class","text":"ID cohort can missing. message issued variables filled default IDs best guesses cohort, .e. sorted (ascending order) sequence values {1, 2, ...}. Typically, end users use .DefaultData() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Data-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data — Data-class","text":"","code":"my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 3, 4, 5, 6, 6, 6)),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) ) my_data #> An object of class \"Data\" #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDA — DataDA-class","title":"DataDA — DataDA-class","text":"DataDA class time--DLT augmented data. inherits Data contains additional DLT free survival times.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDA — DataDA-class","text":"","code":"DataDA(   u = numeric(),   t0 = numeric(length(u)),   Tmax = 0 + .Machine$double.xmin,   ... )  .DefaultDataDA()"},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Default vector 0s length equal length u. Tmax (number) DLT observation period. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Tmax (number) DLT observation period.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataDA — DataDA-class","text":"survival time refers time period subject experience DLT, referring deaths. Typically, end users use .DefaultDataDA() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDA-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDA — DataDA-class","text":"","code":"my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Set up an empty data set. empty_data <- DataDA(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   Tmax = 60 ) empty_data #> An object of class \"DataDA\" #> Slot \"u\": #> numeric(0) #>  #> Slot \"t0\": #> numeric(0) #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.0  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 #> [16] 28.0 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 #> [31] 58.0 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 42 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>"},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDual — DataDual-class","title":"DataDual — DataDual-class","text":"DataDual class dual endpoint data. inherits Data contains additional biomarker information.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDual — DataDual-class","text":"","code":"DataDual(w = numeric(), ...)  .DefaultDataDual()"},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataDual — DataDual-class","text":"Typically, end users use .DefaultDataDual() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataDual-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDual — DataDual-class","text":"","code":"my_data <- DataDual(   w = rnorm(8),   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs! #> Used best guess cohort indices! my_data #> An object of class \"DataDual\" #> Slot \"w\": #> [1]  0.001423948 -0.684206610  0.098762324 -1.643637668  0.347773355 #> [6] -0.692056308  0.421453391  2.157287449 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataGrouped — DataGrouped-class","title":"DataGrouped — DataGrouped-class","text":"DataGrouped class two groups dose escalation data set, comprised monotherapy (mono) combination therapy (combo) arm. inherits Data contains additional group information.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataGrouped — DataGrouped-class","text":"","code":"DataGrouped(group = character(), ...)  .DefaultDataGrouped()"},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataGrouped — DataGrouped-class","text":"group (factor character) whether mono combo used. character coerced factor correct levels internally. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataGrouped — DataGrouped-class","text":"group (factor) whether mono combo used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataGrouped — DataGrouped-class","text":"Typically, end users use .DefaultDataGrouped() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataGrouped — DataGrouped-class","text":"","code":"my_data <- DataGrouped(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   group = c(\"mono\", \"mono\", \"mono\", \"mono\", \"mono\", \"mono\", \"combo\", \"combo\") ) #> Used default patient IDs! #> Used best guess cohort indices!  # Set up an empty data set. empty_data <- DataGrouped(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) empty_data #> An object of class \"DataGrouped\" #> Slot \"group\": #> factor() #> Levels: mono combo #>  #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.0  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 #> [16] 28.0 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 #> [31] 58.0 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 42 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>"},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataMixture — DataMixture-class","title":"DataMixture — DataMixture-class","text":"DataMixture class data mixture sharing. inherits Data contains additional information mixture sharing.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataMixture — DataMixture-class","text":"","code":"DataMixture(xshare = numeric(), yshare = integer(), ...)  .DefaultDataMixture()"},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. can also supply numeric vectors, converted integer internally. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. nObsshare (count) number share patients.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataMixture — DataMixture-class","text":"Typically, end users use .DefaultDataMixture() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataMixture — DataMixture-class","text":"","code":"my_data <- DataMixture(   xshare = c(12, 14, 16, 18.0),   yshare = c(0L, 1L, 1L, 1L),   nObsshare = 4L,   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) my_data #> An object of class \"DataMixture\" #> Slot \"xshare\": #> [1] 12 14 16 18 #>  #> Slot \"yshare\": #> [1] 0 1 1 1 #>  #> Slot \"nObsshare\": #> [1] 4 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataOrdinal — DataOrdinal-class","title":"DataOrdinal — DataOrdinal-class","text":"DataOrdinal class ordinal toxicity data. inherits GeneralData describes toxicity responses ordinal rather binary scale.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataOrdinal — DataOrdinal-class","text":"","code":"DataOrdinal(   x = numeric(),   y = integer(),   ID = integer(),   cohort = integer(),   doseGrid = numeric(),   placebo = FALSE,   yCategories = c(`No DLT` = 0L, DLT = 1L),   ... )  .DefaultDataOrdinal()"},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataOrdinal — DataOrdinal-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1). can also supply numeric vectors, converted integer internally. ID (integer) unique patient IDs. can also supply numeric vectors, converted integer internally. cohort (integer) cohort (non-negative sorted) indices. can also supply numeric vectors, converted integer internally. doseGrid (numeric) possible doses. placebo (flag) TRUE first dose level doseGrid considered placebo. yCategories (named integer) names codes toxicity categories used data.  Category labels taken names vector.  names vector must unique values must sorted take values 0, 1, 2, ... ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DataOrdinal — DataOrdinal-class","text":"cohort can missing placebo equal FALSE.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataOrdinal — DataOrdinal-class","text":"class implemented sibling existing Data class (rather parent child) minimise risk unintended side effects existing classes methods. default setting yCategories slot replicates behaviour existing Data class. Typically, end users use .DefaultDataOrdinal() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataOrdinal — DataOrdinal-class","text":"","code":"DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE ) #> An object of class \"DataOrdinal\" #> Slot \"x\": #>  [1] 10 20 30 40 50 50 50 60 60 60 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 1 0 0 1 2 #>  #> Slot \"doseGrid\": #>  [1]  10  20  30  40  50  60  70  80  90 100 #>  #> Slot \"nGrid\": #> [1] 10 #>  #> Slot \"xLevel\": #>  [1] 1 2 3 4 5 5 5 6 6 6 #>  #> Slot \"yCategories\": #>     No tox Sub-tox AE        DLT  #>          0          1          2  #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 5 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 10 #>"},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataParts — DataParts-class","title":"DataParts — DataParts-class","text":"DataParts class data two study parts. inherits Data contains additional information two study parts.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataParts — DataParts-class","text":"","code":"DataParts(part = integer(), nextPart = 1L, part1Ladder = numeric(), ...)  .DefaultDataParts()"},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataParts — DataParts-class","text":"Typically, end users use .DefaultDataParts() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DataParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataParts — DataParts-class","text":"","code":"my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) my_data #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 #>  #> Slot \"nextPart\": #> [1] 1 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Design — Design-class","title":"Design — Design-class","text":"Design class rule-based designs. difference class parent RuleDesign class Design class contains additional model, stopping increments slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design — Design-class","text":"","code":"Design(model, stopping, increments, pl_cohort_size = CohortSizeConst(0L), ...)  .DefaultDesign()"},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design — Design-class","text":"model (GeneralModel) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Design — Design-class","text":"model (GeneralModel) model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Design — Design-class","text":"Typically, end users use .DefaultDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Design-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design — Design-class","text":"","code":"empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DesignGrouped — DesignGrouped-class","title":"DesignGrouped — DesignGrouped-class","text":"DesignGrouped combines two Design objects: one mono one combo arm joint dose escalation design.","code":""},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DesignGrouped — DesignGrouped-class","text":"","code":"DesignGrouped(   model,   mono,   combo = mono,   first_cohort_mono_only = TRUE,   same_dose = TRUE,   stop_mono_with_combo = FALSE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DesignGrouped — DesignGrouped-class","text":"model (LogisticLogNormalGrouped) see slot definition. mono (Design) see slot definition. combo (Design) see slot definition. first_cohort_mono_only (flag) see slot definition. same_dose (flag) see slot definition. stop_mono_with_combo (flag) see slot definition. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DesignGrouped — DesignGrouped-class","text":"Note model slots inside mono combo parameters ignored (fit separate regression models mono combo arms). Instead, model parameter used fit joint regression model mono combo arms together.","code":""},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DesignGrouped — DesignGrouped-class","text":"model (LogisticLogNormalGrouped) model used, currently one class allowed. mono (Design) defines dose escalation rules mono arm, see details. combo (Design) defines dose escalation rules combo arm, see details. first_cohort_mono_only (flag) whether first test one mono agent cohort, DLT data collected, proceed second cohort onwards concurrent mono combo cohorts. same_dose (flag) whether lower dose separately determined mono combo doses used next dose mono combo. stop_mono_with_combo (flag) whether mono arm stopped combo arm stopped (makes sense real trial objective recommended combo dose).","code":""},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DesignGrouped — DesignGrouped-class","text":"Typically, end-users use .DefaultDesignGrouped() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DesignGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DesignGrouped — DesignGrouped-class","text":"","code":"empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the joint model. my_model <- LogisticLogNormalGrouped(   mean = c(-0.85, 0, 1, 0),   cov = diag(1, 4),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Rules to be used for both arms. one_arm <- Design(   model = .DefaultModelLogNormal(), # Ignored.   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )  # Initialize the design. design <- DesignGrouped(   model = my_model,   mono = one_arm )  # Alternative options: Here e.g. use both mono and combo from the start, # but allow different dose levels for the cohorts. Stop mono arm too, when combo # arm is stopped. design2 <- DesignGrouped(   model = my_model,   mono = one_arm,   first_cohort_mono_only = FALSE,   same_dose = FALSE,   stop_mono_with_combo = TRUE, )"},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualDesign — DualDesign-class","title":"DualDesign — DualDesign-class","text":"DualDesign class dual-endpoint CRM design. class special requirements model data slots comparison parent class Design.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualDesign — DualDesign-class","text":"","code":"DualDesign(model, data, ...)  .DefaultDualDesign()"},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualDesign — DualDesign-class","text":"model (DualEndpoint) see slot definition. data (DataDual) see slot definition. ... Arguments passed Design stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualDesign — DualDesign-class","text":"model (DualEndpoint) model used. data (DataDual) specifies dose grid, previous data, etc.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualDesign — DualDesign-class","text":"nextBest slot can class, allows easy comparison recommendation methods use biomarker information. Typically, end users use .DefaultDualDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualDesign — DualDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) my_stopping <- my_stopping1 | StoppingMinPatients(40)  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- DualDesign(   model = my_model,   data = empty_data,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   startingDose = 3 )"},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpoint — DualEndpoint-class","title":"DualEndpoint — DualEndpoint-class","text":"DualEndpoint general class dual endpoint model.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpoint — DualEndpoint-class","text":"","code":"DualEndpoint(mean, cov, ref_dose = 1, use_log_dose = FALSE, sigma2W, rho)  .DefaultDualEndpoint()"},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpoint — DualEndpoint-class","text":"mean (numeric) probit toxicity model, prior mean vector. cov (matrix) probit toxicity model, prior covariance matrix. precision matrix internally calculated inverse cov. ref_dose (number) probit toxicity model, reference dose \\(x*\\) (strictly positive number). use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpoint — DualEndpoint-class","text":"idea dual-endpoint models model dose-toxicity relationship, also model, time, relationship PD biomarker dose. sub-classes class define dose-biomarker relationship parametrized. class shall contain common features reduce duplicate code. (class however, must virtual need create objects construction subclass objects.) dose-toxicity relationship modeled probit regression model $$probit[p(x)] = betaZ1 + betaZ2 * x/x*,$$ $$probit[p(x)] = betaZ1 + betaZ2 * log(x/x*),$$ case option use_log_dose TRUE. , \\(p(x)\\) probability observing DLT given dose \\(x\\) \\(x*\\) reference dose. prior $$(betaZ1, log(betaZ2)) ~ Normal(mean, cov).$$ biomarker response \\(w\\) dose \\(x\\), assume $$w(x) ~ Normal(f(x), sigma2W),$$ \\(f(x)\\) function dose \\(x\\), specified sub-classes. biomarker variance \\(sigma2W\\) can fixed assigned Inverse-Gamma prior distribution; see details slot sigma2W. Finally, two endpoints \\(y\\) (binary DLT variable) \\(w\\) (biomarker) can correlated, assuming correlation level \\(rho\\) underlying continuous latent toxicity variable \\(z\\) biomarker \\(w\\). , correlation can fixed assigned prior distribution scaled Beta family; see details slot rho. Please see example vignette typing crmPackExample() full example.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpoint — DualEndpoint-class","text":"betaZ_params (ModelParamsNormal) probit toxicity model, contains prior mean, covariance matrix precision matrix internally calculated inverse covariance matrix. ref_dose (positive_number) probit toxicity model, reference dose. use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. use_fixed (logical) indicates whether fixed value sigma2W rho (parameter separately) used . slot needed internal purposes must touched user.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpoint-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpoint — DualEndpoint-class","text":"Typically, end users use .DefaultDualEndpoint() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointBeta — DualEndpointBeta-class","title":"DualEndpointBeta — DualEndpointBeta-class","text":"DualEndpointBeta class dual endpoint model beta function dose-biomarker relationship.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"DualEndpointBeta(E0, Emax, delta1, mode, ref_dose_beta = 1, ...)  .DefaultDualEndpointBeta()"},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointBeta — DualEndpointBeta-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric, rescaled beta density function: $$f(x) = E0 + (Emax - E0) * Beta(delta1, delta2) * (x/x*)^delta1 * (1 - x/x*)^delta2,$$ \\(x*\\) maximum dose (end dose range considered), \\(delta1\\) \\(delta2\\) two beta function parameters, \\(E0\\), \\(Emax\\) minimum maximum levels, respectively. ease interpretation, use parametrization based \\(delta1\\) mode, $$mode = delta1 / (delta1 + delta2),$$ multiplying \\(x*\\) gives mode dose grid. parameters can currently assigned uniform distributions fixed advance. Note E0 Emax can negative values uniform distributions reaching negative range, delta1 mode must positive uniform distributions positive range.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointBeta — DualEndpointBeta-class","text":"Typically, end users use .DefaultDualEndpointBeta() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   ref_dose = 10,   use_log_dose = TRUE,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   delta1 = c(0, 5),   mode = c(1, 15),   ref_dose_beta = 1000 )"},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointEmax — DualEndpointEmax-class","title":"DualEndpointEmax — DualEndpointEmax-class","text":"DualEndpointEmax class dual endpoint model Emax function dose-biomarker relationship.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"DualEndpointEmax(E0, Emax, ED50, ref_dose_emax = 1, ...)  .DefaultDualEndpointEmax()"},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointEmax — DualEndpointEmax-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric Emax function: $$f(x) = E0 + [(Emax - E0) * (x/x*)]/[ED50 + (x/x*)],$$ \\(x*\\) reference dose, \\(E0\\) \\(Emax\\) minimum maximum levels biomarker, \\(ED50\\) dose achieving half maximum effect \\(0.5 * Emax\\). parameters can currently assigned uniform distributions fixed.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointEmax — DualEndpointEmax-class","text":"Typically, end users use .DefaultDualEndpointEmax() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"my_model <- DualEndpointEmax(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   ED50 = c(10, 200),   ref_dose_emax = 1000 )"},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointRW — DualEndpointRW-class","title":"DualEndpointRW — DualEndpointRW-class","text":"DualEndpointRW class dual endpoint model random walk prior biomarker.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"DualEndpointRW(sigma2betaW, rw1 = TRUE, ...)  .DefaultDualEndpointRW()"},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used. ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointRW — DualEndpointRW-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled non-parametric random walk first second order. means, first order random walk assume $$betaW_i - betaW_i-1 ~ Normal(0, (x_i - x_i-1) * sigma2betaW),$$ \\(betaW_i = f(x_i)\\) biomarker mean \\(\\)-th dose gridpoint \\(x_i\\). second order random walk, second-order differences instead first-order differences biomarker means follow normal distribution \\(0\\) mean \\(2 * (x_i - x_i-2) * sigma2betaW\\) variance. variance parameter \\(sigma2betaW\\) important steers smoothness function \\(f(x)\\), .e.: large, \\(f(x)\\) wiggly; small, \\(f(x)\\) smooth. parameter can either fixed value assigned inverse gamma prior distribution.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointRW — DualEndpointRW-class","text":"Non-equidistant dose grids can used now, difference \\(x_i - x_i-1\\) included modelling assumption . Please note due impropriety random walk prior distributions, possible produce MCMC samples empty data objects (.e., sample prior). bug, theoretical feature model. Typically, end users use .DefaultDualEndpointRW() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/DualEndpointRW-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )"},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualResponsesDesign.R — DualResponsesDesign-class","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model without DLE efficacy samples. contains slots RuleDesign TDsamplesDesign classes.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"","code":"DualResponsesDesign(eff_model, data, ...)  .DefaultDualResponsesDesign()"},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"eff_model (ModelEff) see slot definition. data (DataDual) see slot definition. ... Arguments passed TDDesign model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"data (DataDual) data set. eff_model (ModelEff) pseudo efficacy model used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"Typically, end users use .DefaultDualResponsesDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = seq(25, 300, 25))  tox_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data )  my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  my_increments <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) )  my_size <- CohortSizeConst(size = 3) my_stopping <- StoppingMinPatients(nPatients = 36)  design <- DualResponsesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = tox_model,   eff_model = eff_model,   data = empty_data,   stopping = my_stopping,   increments = my_increments )"},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model DLE efficacy samples. contain slots RuleDesign TDsamplesDesign class objects.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"","code":"DualResponsesSamplesDesign(eff_model, data, ...)  .DefaultDualResponsesSamplesDesign()"},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"eff_model (ModelEff) see slot definition. data (DataDual) see slot definition. ... Arguments passed TDsamplesDesign model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"data (DataDual) data set. eff_model (ModelEff) pseudo efficacy model used.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"Typically, end users use .DefaultDualResponsesSamplesDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = seq(25, 300, 25))  tox_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data ) options <- McmcOptions(burnin = 100, step = 2, samples = 200) tox_samples <- mcmc(empty_data, tox_model, options)  eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data ) eff_samples <- mcmc(empty_data, eff_model, options)  my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  my_increments <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) my_size <- CohortSizeConst(size = 3) my_stopping <- StoppingMinPatients(nPatients = 36)  design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = tox_model,   eff_model = eff_model,   data = empty_data,   stopping = my_stopping,   increments = my_increments )"},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualSimulations — DualSimulations-class","title":"DualSimulations — DualSimulations-class","text":"class captures trial simulations dual-endpoint model based designs. comparison parent class Simulations, contains additional slots capture dose-biomarker fits, sigma2W rho estimates.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualSimulations — DualSimulations-class","text":"","code":"DualSimulations(rho_est, sigma2w_est, fit_biomarker, ...)  .DefaultDualSimulations()"},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualSimulations — DualSimulations-class","text":"rho_est (numeric) see DualSimulations sigma2w_est (numeric)DualSimulations fit_biomarker (list) see DualSimulations ... additional parameters Simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualSimulations — DualSimulations-class","text":"rho_est (numeric) vector final posterior median rho estimates sigma2w_est (numeric) vector final posterior median sigma2W estimates fit_biomarker (list) final dose-biomarker curve fits","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualSimulations — DualSimulations-class","text":"Typically, end users use .DefaultDualSimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualSimulations — DualSimulations-class","text":"","code":"data_list <- list(   Data(     x = 1:2,     y = 0:1,     doseGrid = 1:2,     ID = 1L:2L,     cohort = 1L:2L   ),   Data(     x = 3:4,     y = 0:1,     doseGrid = 3:4,     ID = 1L:2L,     cohort = 1L:2L   ) )  doses <- c(1, 2) seed <- as.integer(123)  fit <- list(   c(0.1, 0.2),   c(0.3, 0.4) )  stop_report <- matrix(c(TRUE, FALSE), nrow = 2)  stop_reasons <- list(\"A\", \"B\")  additional_stats <- list(a = 1, b = 1)  dual_simulations_obj <- DualSimulations(   rho_est = c(0.25, 0.35),   sigma2w_est = c(0.15, 0.25),   fit_biomarker = list(c(0.3, 0.4), c(0.4, 0.5)),   fit = fit,   stop_report = stop_report,   stop_reasons = stop_reasons,   additional_stats = additional_stats,   data = data_list,   doses = doses,   seed = seed )"},{"path":"https://roche.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"addition slots parent class SimulationsSummary, contains two slots biomarker model fit information.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"","code":".DefaultDualSimulationsSummary()"},{"path":"https://roche.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"biomarkerFitAtDoseMostSelected fitted biomarker level dose often selected meanBiomarkerFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted biomarker level dose level","code":""},{"path":"https://roche.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"Typically, end users use .DefaultDualSimulationsSummary() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":null,"dir":"Reference","previous_headings":"","what":"EffFlexi — EffFlexi-class","title":"EffFlexi — EffFlexi-class","text":"EffFlexi class efficacy model flexible form prior expressed form pseudo data. class, flexible form used describe relationship efficacy responses dose levels specified $$(W | betaW, sigma2W) ~ Normal(X * betaW, sigma2W * ),$$ \\(W\\) vector efficacy responses, \\(betaW\\) column vector mean efficacy responses dose levels, \\(X\\) design matrix entries \\(I_i,j\\) equal 1 subject \\(\\) allocated dose \\(j\\), \\(0\\) otherwise. \\(sigma2W\\) variance efficacy responses can either fixed number number inverse gamma distribution. flexible form aims capture different shapes dose-efficacy curve. addition, first (RW1) second order (RW2) random walk model can used smoothing data. random walk model used model first second order differences mean efficacy responses neighboring dose levels mean efficacy responses. RW1 model given $$betaW_j - betaW_j-1) ~ Normal(0, sigma2betaW),$$ RW2 $$betaW_j-2 - 2 * betaW_j-1 + beta_j ~ Normal(0, sigma2betaW),$$ \\(betaW_j\\) vector mean efficacy responses dose j, \\(sigma2betaW\\) prior variance can either fixed number number inverse gamma distribution. eff eff_dose pseudo efficacy responses dose levels pseudo efficacy responses observed. , eff eff_dose must vectors length least 2. positions elements specified eff eff_dose must correspond vectors.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EffFlexi — EffFlexi-class","text":"","code":"EffFlexi(eff, eff_dose, sigma2W, sigma2betaW, rw1 = TRUE, data)  .DefaultEffFlexi()"},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. sigma2W (numeric) prior variance efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. sigma2betaW (numeric) prior variance random walk model used smoothing. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. data (DataDual) observed data update estimates model parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EffFlexi — EffFlexi-class","text":"model output updated value updated values parameters inverse gamma distributions \\(sigma2W\\) \\(sigma2betaW\\). EffFlexi inherits slots ModelEff class.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. sigma2W (numeric) prior variance flexible efficacy form. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. sigma2betaW (numeric) prior variance random walk model mean efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (logical) indicates whether fixed value sigma2W sigma2betaW (parameter separately) used . slot needed internal purposes must touched user. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. X (matrix) design matrix efficacy responses. based pseudo observed efficacy responses. RW (matrix) difference matrix random walk model. slot needed internal purposes must used user. RW_rank (integer) rank difference matrix. slot needed internal purposes must used user.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"EffFlexi — EffFlexi-class","text":"Typically, end users use .DefaultEffFlexi() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/EffFlexi-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EffFlexi — EffFlexi-class","text":"","code":"# Obtain prior estimates for the efficacy model in flexible form, given the pseudo data. # First define an empty data set by defining the dose levels used in the study. # There are 12 dose levels used in the study, ranging from 25 to 300 mg with # increments of 25. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # Define the pseudo data, i.e.: fixed 2 dose levels 25 and 300 mg (`eff_dose`) # and the efficacy responses 1.223 and 2.513 observed at these two dose levels (`eff`). # The prior variance of the pseudo efficacy responses can be either a fixed value # or two parameters for the inverse gamma distribution, the shape (a) and the # rate (b) (`sigma2W`). # The prior variance of the random walk model can be either a fixed value or two # parameters for the inverse gamma distribution, the shape (a) and the rate (b) # (`sigma2betaW`). my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # Obtain estimates from the model given some observed data is available. data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model1 <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )"},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Effloglog — Effloglog-class","title":"Effloglog — Effloglog-class","text":"Effloglog class linear log-log efficacy model using pseudo data prior. describes relationship continuous efficacy responses corresponding dose levels log-log scale. efficacy log-log model given $$y_i = theta1 + theta2 * log(log(x_i)) + epsilon_i,$$ \\(y_i\\) efficacy response subject \\(\\), \\(x_i\\) dose level treated subject \\(\\) \\(epsilon_i\\) random error term efficacy model subject \\(\\). error term \\(epsilon_i\\) random variable follows normal distribution mean \\(0\\) variance \\(nu^{-1}\\), assumed subjects. three parameters model, intercept \\(theta1\\), slope \\(theta2\\) precision \\(nu\\) efficacy responses, also known inverse variance pseudo efficacy responses. can fixed constant gamma distribution. Therefore, single scalar value vector two positive numbers values must specified nu slot. observed efficacy responses available, output, nu display updated value precision updated values parameters gamma distribution. Effloglog inherits slots ModelEff class.","code":""},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effloglog — Effloglog-class","text":"","code":"Effloglog(eff, eff_dose, nu, data, const = 0)"},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. nu (numeric) precision (inverse variance) efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. data (DataDual) observed data update estimates model parameters. const (number) constant value added dose level dose level value less equal 1 special form linear log-log applied (Yeung et al. (2015).).","code":""},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Effloglog — Effloglog-class","text":"prior model specified form pseudo data. First, least two dose levels fixed. , using e.g. experts' opinion, efficacy values correspond dose levels can obtained, eff eff_dose arguments represent prior form pseudo data. eff represents pseudo efficacy values. eff_dose represents dose levels pseudo efficacy values observed. Hence, positions elements specified eff eff_dose must correspond vectors. Since least 2 pseudo efficacy values needed obtain modal estimates intercept slope parameters, eff eff_dose must vectors length least 2. joint prior distribution intercept \\(theta1\\) slope \\(theta2\\) model follows bivariate normal distribution mean \\(mu\\) covariance matrix \\((nu * Q)^{-1}\\). mean \\(mu\\) \\(2 x 1\\) column vector contains prior modal estimates intercept slope. Scalar \\(nu\\) precision pseudo efficacy responses \\(Q\\) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding DLT efficacy responses observed (). Hence, \\(X0\\) (\\(X\\)) size \\(r x 2\\), \\(r >= 2\\) pseudo efficacy responses specified (\\(r\\) DLT efficacy responses observed data).","code":""},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. nu (numeric) parameter prior precision pseudo efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (flag) indicates whether nu specified fixed value vector two parameters gamma distribution. slot internal purposes must used user. theta1 (number) intercept efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. theta2 (number) slope efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. Pcov (matrix) refers \\(2 x 2\\) covariance matrix estimators intercept \\(theta1\\) slope \\(theta2\\) parameters model. used output display resulting prior posterior covariance matrix \\(theta1\\) \\(theta2\\) obtained, based pseudo observed () data. slot needed internal purposes. X (matrix) design matrix based either pseudo dose levels observed dose levels (without DLT). used output display design matrix pseudo observed efficacy responses. Y (numeric) vector either contains pseudo efficacy responses observed efficacy responses (without DLT). mu (numeric) vector prior posterior modal estimates intercept (\\(theta1\\)) slope (\\(theta2\\)). slot used output display mean prior posterior bivariate normal distribution \\(theta1\\) \\(theta2\\). Q (matrix) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding observed, DLT efficacy values (). const (number) non-negative number (default 0), leading model form described . general, model form \\(y_i = theta1 + theta2 * log(log(x_i + const)) + epsilon_i\\), dose levels greater \\(1 - const\\) can considered described Yeung et al. (2015).","code":""},{"path":"https://roche.github.io/crmPack/reference/Effloglog-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effloglog — Effloglog-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we use an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # Define the pseudo data as first by fixing two dose levels 25 and 300 mg (`eff_dose`). # Then, the efficacy responses observed at these two dose levels are 1.223 and 2.513 (`eff`). # We specify the prior precision of the pseudo efficacy responses (`nu`) as a vector # with the shape (a) and the rate (b) parameters for the gamma distribution. # Obtain modal estimates and other estimates from the model (no observations, # only pseudo data). my_model1 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Observed data. my_data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  # Obtain posterior modal estimates and other estimates from the model given some # observed data. my_model2 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )"},{"path":"https://roche.github.io/crmPack/reference/FractionalCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"FractionalCRM — FractionalCRM-class","title":"FractionalCRM — FractionalCRM-class","text":"FractionalCRM class fractional CRM model based one parameter CRM (normal prior log-power parameter) well Kaplan-Meier based estimation conditional probability experience DLT non-complete observations. fractional CRM model follows paper code Guosheng Yin et al.","code":""},{"path":"https://roche.github.io/crmPack/reference/FractionalCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FractionalCRM — FractionalCRM-class","text":"","code":"FractionalCRM(...)  .DefaultFractionalCRM()"},{"path":"https://roche.github.io/crmPack/reference/FractionalCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FractionalCRM — FractionalCRM-class","text":"... Arguments passed OneParLogNormalPrior skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":"https://roche.github.io/crmPack/reference/FractionalCRM-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"FractionalCRM — FractionalCRM-class","text":"Typically, end users use .DefaultTITELogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/FractionalCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FractionalCRM — FractionalCRM-class","text":"","code":"my_model <- FractionalCRM(   skel_probs = c(0.1, 0.2, 0.3, 0.4),   dose_grid = c(10, 30, 50, 100),   sigma2 = 2 )"},{"path":"https://roche.github.io/crmPack/reference/GeneralData-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralData — GeneralData-class","title":"GeneralData — GeneralData-class","text":"GeneralData class general data input.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralData-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralData — GeneralData-class","text":"ID (integer) unique patient IDs. cohort (integer) cohort (non-negative sorted) indices. nObs (integer) number observations, single value.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralModel — GeneralModel-class","title":"GeneralModel — GeneralModel-class","text":"GeneralModel general model class, specific model-like classes inherit.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralModel-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralModel — GeneralModel-class","text":"","code":".DefaultGeneralModel()"},{"path":"https://roche.github.io/crmPack/reference/GeneralModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralModel — GeneralModel-class","text":"datamodel (function) function representing JAGS data model specification. priormodel (function) function representing JAGS prior specification. modelspecs (function) function computing list data model prior model specifications required specified completely (e.g. prior parameters, reference dose, etc.), based data slots required arguments function. Apart data arguments, function can specified one additional (optional) argument from_prior type logical length one. from_prior flag can used differentiate output modelspecs, value taken directly from_prior argument mcmc method invokes modelspecs function. , from_prior TRUE, priormodel JAGS model used (datamodel used) mcmc, hence modelspecs function return parameters required priormodel . value from_prior FALSE, JAGS models datamodel priormodel used MCMC sampler, hence modelspecs function return parameters required datamodel priormodel. init (function) function computing list starting values parameters required initialized MCMC sampler, based data slots required arguments function. datanames (character) names data slots used datamodel JAGS function. names specified . datanames_prior (character) names data slots used priormodel JAGS function. names specified . sample (character) names parameters like save MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralModel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralModel — GeneralModel-class","text":"datamodel must obey convention data input called exactly way corresponding data class. prior distributions parameters contained model function priormodel. background can used simulate prior distribution, obtaining data. Typically, end users use .DefaultGeneralModel() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralSimulations — GeneralSimulations-class","title":"GeneralSimulations — GeneralSimulations-class","text":"class captures trial simulations. also random generator state starting simulation saved, order able reproduce outcome. just use set.seed seed argument running simulate,Design-method.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralSimulations — GeneralSimulations-class","text":"","code":"GeneralSimulations(data, doses, seed)  .DefaultGeneralSimulations()"},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GeneralSimulations — GeneralSimulations-class","text":"data (list) see slot definition. doses (numeric) see slot definition. seed (integer) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralSimulations — GeneralSimulations-class","text":"data (list) produced Data objects. doses (numeric) final dose recommendations. seed (integer) random generator state starting simulation.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralSimulations — GeneralSimulations-class","text":"Typically, end users use .DefaultGeneralSimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GeneralSimulations — GeneralSimulations-class","text":"","code":"data <- list(   Data(x = 1:3, y = c(0, 1, 0), doseGrid = 1:3, ID = 1L:3L, cohort = 1L:3L),   Data(x = 4:6, y = c(0, 1, 0), doseGrid = 4:6, ID = 1L:3L, cohort = 1L:3L) )  doses <- c(1, 2)  seed <- 123L  simulations <- GeneralSimulations(data, doses, seed)"},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"","code":".DefaultGeneralSimulationsSummary()  .DefaultPseudoSimulationsSummary()"},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"target target toxicity interval targetDoseInterval corresponding target dose interval nsim number simulations propDLTs proportions DLTs trials meanToxRisk mean toxicity risks patients doseSelected doses selected MTD toxAtDosesSelected true toxicity doses selected propAtTarget Proportion trials selecting target MTD doseMostSelected dose often selected MTD obsToxRateAtDoseMostSelected observed toxicity rate dose often selected nObs number patients overall nAboveTarget number patients treated target tox interval doseGrid dose grid used placebo set TRUE (default FALSE) design placebo","code":""},{"path":"https://roche.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"Typically, end users use .DefaultGeneralSimulationsSummary() function. Typically, end users use .DefaultPseudoSimulationsSummary() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Increments-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Increments — Increments-class","title":"Increments — Increments-class","text":"Increments virtual class controlling increments, specific increments classes inherit.","code":""},{"path":"https://roche.github.io/crmPack/reference/Increments-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increments — Increments-class","text":"","code":".DefaultIncrements()"},{"path":"https://roche.github.io/crmPack/reference/Increments-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Increments — Increments-class","text":"Typically, end users use .DefaultIncrements() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsDoseLevels — IncrementsDoseLevels-class","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"IncrementsDoseLevels class increments control based number dose levels.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"","code":"IncrementsDoseLevels(levels = 1L, basis_level = \"last\")  .DefaultIncrementsDoseLevels()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"levels (count) see slot definition. basis_level (string) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"levels (count) maximum number dose levels increment next dose. defaults 1, means dose skipping allowed, .e. next dose can maximum one level higher current base dose. current base dose level dose level used increment (see basis_level parameter). basis_level (string) defines current base dose level. can take one two possible values: last max. last specified (default), current base dose level set last dose given. max specified, current base dose level set maximum dose level given.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"Typically, end users use .DefaultIncrementsDoseLevels() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"","code":"# The rule for dose increments which allows for maximum skip one dose level, # that is 2 dose levels higher than the last dose given. my_increments <- IncrementsDoseLevels(levels = 2, basis_level = \"last\")"},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsHSRBeta — IncrementsHSRBeta-class","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"IncrementsHSRBeta class limiting increments using Hard Safety Rule based Bin-Beta model. Increment control based number observed DLTs number subjects dose level. probability toxicity calculated using Bin-Beta model prior (,b). probability exceeds threshold given dose, dose doses excluded escalation. hard safety rule limits escalation based observed data per dose level, independent underlying model.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"IncrementsHSRBeta(target = 0.3, prob = 0.95, a = 1, b = 1)  .DefaultIncrementsHSRBeta()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) target toxicity, except 0 1. prob (proportion) threshold probability (except 0 1) dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"Typically, end users use .DefaultIncrementsHSRBeta() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"# Limit the escalation with a hard safety criteria to the doses that are below # the first dose that is toxic with a probability of 0.95. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)"},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsMin — IncrementsMin-class","title":"IncrementsMin — IncrementsMin-class","text":"IncrementsMin class combines multiple increment rules minimum operation. Slot increments_list contains increment rules, objects class Increments. minimum individual increments taken give final maximum increment.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsMin — IncrementsMin-class","text":"","code":"IncrementsMin(increments_list)  .DefaultIncrementsMin()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) list increment rules.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsMin — IncrementsMin-class","text":"Typically, end users use .DefaultIncrementsMin() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsMin — IncrementsMin-class","text":"","code":"# As example, here we are combining 2 different increment rules.  # The first rule is the following: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed. my_increments_1 <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # The second rule is the following: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments_2 <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Now we combine the 2 rules. comb_increments <- IncrementsMin(   increments_list = list(my_increments_1, my_increments_2) )"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelative — IncrementsRelative-class","title":"IncrementsRelative — IncrementsRelative-class","text":"IncrementsRelative class increments control based relative differences intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"IncrementsRelative(intervals, increments)  .DefaultIncrementsRelative()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) vector left bounds relevant intervals. example, intervals  = c(0, 50, 100) specifies three intervals: \\((0, 50)\\), \\([50, 100)\\) \\([100, +Inf)\\). means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector length maximum allowable relative increments intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelative — IncrementsRelative-class","text":"Typically, end users use .DefaultIncrementsRelative() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelative-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"IncrementsRelativeDLT class increments control based relative differences terms DLTs.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"IncrementsRelativeDLT(intervals, increments)  .DefaultIncrementsRelativeDLT()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"intervals (integer) vector left bounds relevant DLT intervals. example, intervals  = c(0, 1, 3) specifies three intervals (sets DLTs: first, 0 DLT; second 1 2 DLTs; third one, least 3 DLTs. means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector maximum allowable relative increments corresponding intervals. must length length intervals.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"considers DLTs across cohorts observed far. Typically, end users use .DefaultIncrementsRelativeDLT() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if no DLTs were observed in the whole study so far # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed so far # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed so far. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"IncrementsRelativeDLTCurrent class increments control based relative differences current DLTs. class based number DLTs observed current cohort, cumulatively cohorts far.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"IncrementsRelativeDLTCurrent(intervals = c(0L, 1L), increments = c(2L, 1L))  .DefaultIncrementsRelativeDLTCurrent()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"Typically, end users use .DefaultIncrementsRelativeDLTCurrent() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"# As example, here is the rule for: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed.  my_increments <- IncrementsRelativeDLTCurrent(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeParts — IncrementsRelativeParts-class","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"IncrementsRelativeParts class increments control based relative differences intervals, special rules part 1 beginning part 2.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"IncrementsRelativeParts(dlt_start, clean_start, ...)  .DefaultIncrementsRelativeParts()"},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (count) see slot definition. clean_start (count) see slot definition. ... Arguments passed IncrementsRelative intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"class works conjunction DataParts objects. part 2 just started next cohort, next maximum dose either dlt_start (e.g. -1) shift last part 1 dose case DLT part 1, clean_start shift (e.g. -1) case DLTs part 1, given clean_start <= 0 (see description clean_start slot details). part 1 still next cohort, next dose level next higher dose level part1Ladder slot data object. part 2 started , usual relative increment rules apply, see IncrementsRelative.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (integer) scalar, dose level increment starting part 2 case least one DLT event part 1. clean_start (integer) scalar, dose level increment starting part 2 case DLTs part 1. clean_start <= 0, part 1 ladder used find maximum next dose. Otherwise, relative increment rules applied find next maximum dose level.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"require clean_start >= dlt_start. However, precondition prerequisite function (except class' validation function) works objects class. rather motivated semantics. , observe DLT part 1, aggressive case clean part 1 without DLT. Typically, end users use .DefaultIncrementsRelativeParts() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"my_increments <- IncrementsRelativeParts(dlt_start = 0, clean_start = 1)"},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticIndepBeta — LogisticIndepBeta-class","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"LogisticIndepBeta class two-parameters logistic regression dose-limiting events (DLE) model prior expressed form pseudo data. model describes relationship binary DLE responses dose levels. specifically, represents relationship probabilities occurrence DLE corresponding dose levels log scale. model specified $$p(x) = exp(phi1 + phi2 * log(x)) / (1 + exp(phi1 + phi2 * log(x)))$$ \\(p(x)\\) probability occurrence DLE dose \\(x\\). two parameters model intercept \\(phi1\\) slope \\(phi2\\). LogisticIndepBeta inherits slots ModelTox class. context pseudo data, following three arguments used, binDLE, DLEdose DLEweights. DLEdose represents fixed dose levels pseudo DLE responses binDLE observed. DLEweights represents total number subjects treated per dose level DLEdose. binDLE represents number subjects observed DLE per dose level DLEdose. Hence, three vectors must length order elements vectors binDLE, DLEdose DLEweights must kept, element given vector corresponds elements remaining two vectors (see example insight). Finally, since least two DLE pseudo responses needed obtain prior modal estimates (maximum likelihood estimates) model parameters, binDLE, DLEdose DLEweights must vectors least length 2.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"LogisticIndepBeta(binDLE, DLEdose, DLEweights, data)  .DefaultLogisticIndepBeta()"},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) number subjects observed DLE, pseudo DLE responses, depending dose levels DLEdose. Elements binDLE must correspond elements DLEdose DLEweights. DLEdose (numeric) dose levels pseudo DLE responses. Elements DLEdose must correspond elements binDLE DLEweights. DLEweights (numeric) total number subjects treated dose levels DLEdose, pseudo weights. Elements DLEweights must correspond elements binDLE DLEdose. data (Data) input data update estimates model parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"pseudo data can interpreted obtain observations trial starts. can used express prior, .e. initial beliefs model parameters. pseudo data expressed following way. First, fix least two dose levels, ask experts' opinion many subjects treated dose levels number subjects observed DLE. dose level, number subjects observed DLE, divided total number subjects treated, probability occurrence DLE particular dose level. probabilities occurrence DLE based pseudo data independent follow Beta distributions. Therefore, joint prior probability density function probabilities can obtained. Hence, change variable, joint prior probability density function two parameters model can also obtained. addition, conjugate joint prior density function two parameters model used. details form joint prior posterior probability density functions, please refer Whitehead Willamson (1998).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) vector total numbers DLE responses. must least length 2 order elements must correspond values specified DLEdose DLEweights. DLEdose (numeric) vector dose levels corresponding must least length 2 order elements must correspond values specified binDLE DLEweights. DLEweights (integer) total number subjects treated pseudo dose level DLEdose. must least length 2 order elements must correspond values specified binDLE DLEdose. phi1 (number)  intercept model. slot used output display resulting prior posterior modal estimate intercept obtained based pseudo data () observed data/responses. phi2 (number)  slope model. slot used output display resulting prior posterior modal estimate slope obtained based pseudo data () observed data/responses. Pcov (matrix) refers 2x2 covariance matrix intercept (\\(phi1\\)) slope parameters (\\(phi2\\)) model. used output display resulting prior posterior covariance matrix \\(phi1\\) \\(phi2\\) obtained, based pseudo data () observed data responses. slot needed internal purposes.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"Typically, end users use .DefaultLogisticIndepBeta() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we used an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- Data(doseGrid = seq(25, 300, 25))  # Fix two dose levels 25 and 300 mg (DLEdose). # Total number of subjects treated in each of these levels is 3, (DLEweights). # The number of subjects observed with a DLE is 1.05 at dose 25 mg and 1.8 at dose 300 mg (binDLE). my_model1 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = emptydata )  # Use observed DLE responses to obtain posterior modal estimates. my_data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model2 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = my_data )"},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadane — LogisticKadane-class","title":"LogisticKadane — LogisticKadane-class","text":"LogisticKadane class logistic model parametrization Kadane et al. (1980).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadane — LogisticKadane-class","text":"","code":"LogisticKadane(theta, xmin, xmax)  .DefaultLogisticKadane()"},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadane — LogisticKadane-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ priors $$gamma ~ Unif(xmin, xmax).$$ $$rho0 ~ Unif(0, theta).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadane — LogisticKadane-class","text":"slots class, required creating model, target toxicity, well minimum maximum dose range. Note can different minimum maximum dose grid data later . Typically, end-users use .DefaultLogisticKadane() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticKadane-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadane — LogisticKadane-class","text":"","code":"my_model <- LogisticKadane(theta = 0.33, xmin = 1, xmax = 200)"},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"LogisticKadaneBetaGamma class logistic model parametrization Kadane et al. (1980), using beta gamma distribution model priors.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"LogisticKadaneBetaGamma(theta, xmin, xmax, alpha, beta, shape, rate)  .DefaultLogisticKadaneBetaGamma()"},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ prior gamma, $$gamma ~ Gamma(shape, rate).$$. prior rho0 = p(xmin), $$rho0 ~ Beta(alpha, beta).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"slots class, required creating model, LogisticKadane class. addition, shape parameters Beta prior distribution rho0 shape rate parameters Gamma prior distribution gamma, required creating prior model. Typically, end users use .Default() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"my_model <- LogisticKadaneBetaGamma(   theta = 0.3,   xmin = 0,   xmax = 7,   alpha = 1,   beta = 19,   shape = 0.5625,   rate = 0.125 )"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormal — LogisticLogNormal-class","title":"LogisticLogNormal — LogisticLogNormal-class","text":"LogisticLogNormal class usual logistic regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"LogisticLogNormal(mean, cov, ref_dose = 1)  .DefaultLogisticLogNormal()"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormal — LogisticLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormal — LogisticLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormal — LogisticLogNormal-class","text":"Typically, end users use .DefaultLogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 ) my_model #> An object of class \"LogisticLogNormal\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] -0.85  1.00 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]  1.0 -0.5 #> [2,] -0.5  1.0 #>  #> Slot \"prec\": #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 50 #>  #> Slot \"datamodel\": #> function() { #>       for (i in 1:nObs) { #>         logit(p[i]) <- alpha0 + alpha1 * log(x[i] / ref_dose) #>         y[i] ~ dbern(p[i]) #>       } #>     } #> <bytecode: 0x55659c2172b0> #> <environment: 0x55659a86eac8> #>  #> Slot \"priormodel\": #> function() { #>       theta ~ dmnorm(mean, prec) #>       alpha0 <- theta[1] #>       alpha1 <- exp(theta[2]) #>     } #> <bytecode: 0x55659c3fa5d0> #> <environment: 0x55659a86e898> #>  #> Slot \"modelspecs\": #> function(from_prior) { #>       ms <- list(mean = params@mean, prec = params@prec) #>       if (!from_prior) { #>         ms$ref_dose <- ref_dose #>       } #>       ms #>     } #> <bytecode: 0x55659c507c08> #> <environment: 0x55659a86e898> #>  #> Slot \"init\": #> function() { #>       list(theta = c(0, 1)) #>     } #> <bytecode: 0x55659c580948> #> <environment: 0x55659a86e898> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha0\" \"alpha1\" #>"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"LogisticLogNormalGrouped class logistic regression model mono combo arms simultaneous dose escalation design.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"","code":"LogisticLogNormalGrouped(mean, cov, ref_dose = 1)  .DefaultLogisticLogNormalGrouped()"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"continuous covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\) LogisticLogNormal. addition, \\(I_c\\) binary indicator covariate 1 combo arm 0 mono arm. model defined : $$logit[p(x)] = (alpha0 + I_c * delta0) + (alpha1 + I_c * delta1) * log(x / x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\), delta0 delta1 differences combo arm compared mono intercept slope parameters alpha0 alpha1. prior defined $$(alpha0, log(delta0), log(alpha1), log(delta1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"Typically, end users use .DefaultLogisticLogNormalGrouped() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"","code":"my_model <- LogisticLogNormalGrouped(   mean = c(-0.85, 0, 1, 0),   cov = diag(1, 4),   ref_dose = 50 ) my_model #> An object of class \"LogisticLogNormalGrouped\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] -0.85  0.00  1.00  0.00 #>  #> Slot \"cov\": #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> Slot \"prec\": #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 50 #>  #> Slot \"datamodel\": #> function() { #>       for (i in 1:nObs) { #>         logit(p[i]) <- (alpha0 + is_combo[i] * delta0) + #>           (alpha1 + is_combo[i] * delta1) * log(x[i] / ref_dose) #>         y[i] ~ dbern(p[i]) #>       } #>     } #> <bytecode: 0x55659cd8df40> #> <environment: 0x55659d5f35a0> #>  #> Slot \"priormodel\": #> function() { #>       theta ~ dmnorm(mean, prec) #>       alpha0 <- theta[1] #>       delta0 <- exp(theta[2]) #>       alpha1 <- exp(theta[3]) #>       delta1 <- exp(theta[4]) #>     } #> <bytecode: 0x55659ca28d20> #> <environment: 0x55659d5f35a0> #>  #> Slot \"modelspecs\": #> function(group, from_prior) { #>       ms <- list( #>         mean = params@mean, #>         prec = params@prec #>       ) #>       if (!from_prior) { #>         ms$ref_dose <- ref_dose #>         ms$is_combo <- as.integer(group == \"combo\") #>       } #>       ms #>     } #> <bytecode: 0x55659ceff810> #> <environment: 0x55659d5f35a0> #>  #> Slot \"init\": #> function() { #>       list(theta = c(0, 1, 1, 1)) #>     } #> <bytecode: 0x55659cf78320> #> <environment: 0x55659d5f35a0> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha0\" \"delta0\" \"alpha1\" \"delta1\" #>"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"LogisticLogNormalMixture class standard logistic model online mixture two bivariate log normal priors.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"LogisticLogNormalMixture(mean, cov, ref_dose, share_weight)  .DefaultLogisticLogNormalMixture()"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number). share_weight (proportion) prior weight share component.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"model can used data arising online informative component prior, time data trial main interest. Formally, achieved assuming probability DLT dose \\(x\\) given $$p(x) = \\pi * p1(x) + (1 - \\pi) * p2(x)$$ \\(\\pi\\) probability model \\(p(x)\\) model \\(p1(x)\\), informative component prior. model data arises parallel: doses xshare, DLT information yshare observed, total nObsshare data points (see DataMixture). hand, \\(1 - \\pi\\), probability separate model \\(p2(x)\\). components log normal prior distribution, can specified user, inherited LogisticLogNormal class.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"share_weight (proportion) prior weight share component \\(p_{1}(x)\\).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"Typically, end users use .DefaultLogNormalMixture() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"# Decide on the dose grid and MCMC options. dose_grid <- 1:80 my_options <- McmcOptions()  # Classic model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data <- Data(doseGrid = dose_grid) prior_samples <- mcmc(empty_data, my_model, my_options) plot(prior_samples, my_model, empty_data)   # Set up the mixture model and data share object. model_share <- LogisticLogNormalMixture(   share_weight = 0.1,   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data_share <- DataMixture(   doseGrid = dose_grid,   xshare = rep(c(10, 20, 40), each = 4),   yshare = rep(0L, 12), )  # Compare with the resulting prior model. prior_samples_share <- mcmc(empty_data_share, model_share, my_options) plot(prior_samples_share, model_share, empty_data_share)"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalSub — LogisticLogNormalSub-class","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"LogisticLogNormalSub class standard logistic model bivariate (log) normal prior subtractive dose standardization.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"LogisticLogNormalSub(mean, cov, ref_dose = 0)  .DefaultLogisticLogNormalSub()"},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"covariate dose \\(x\\) minus reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * (x - x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"Typically, end-users use .DefaultLogisticLogNormalSub() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"my_model <- LogisticLogNormalSub(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormal — LogisticNormal-class","title":"LogisticNormal — LogisticNormal-class","text":"LogisticNormal class usual logistic regression model bivariate normal prior intercept slope.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormal — LogisticNormal-class","text":"","code":"LogisticNormal(mean, cov, ref_dose = 1)  .DefaultLogisticNormal()"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormal — LogisticNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormal — LogisticNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormal — LogisticNormal-class","text":"Typically, end users use .DefaultLogisticNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormal — LogisticNormal-class","text":"","code":"# Define the dose-grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )  my_options <- McmcOptions(burnin = 10, step = 2, samples = 100)  samples <- mcmc(empty_data, my_model, my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>   [1] -2.9133354171 -1.3475832171  0.3480167383 -0.8938339234 -0.9540091127 #>   [6] -1.5001990172  0.9713531250 -1.0829390614  0.3659878370 -0.8976921514 #>  [11] -0.5262467234 -1.4990389519 -0.8642081655  0.6647774783 -0.5086413180 #>  [16]  0.1837927503 -0.6072308872 -1.7261177350 -1.2568243405  0.3130741947 #>  [21] -0.8159901663 -1.1194514874 -1.8140383224 -0.4061396657 -0.0005565323 #>  [26]  0.3167277989 -2.5539941826 -1.1560486258 -1.9451739935  0.2825534989 #>  [31] -1.1331515289 -0.8944024578 -1.7932359766  1.0073521188 -0.1654154567 #>  [36] -1.9188378184 -1.2510127259 -1.1369966614 -2.1902067545  0.2755550471 #>  [41] -0.7028752617  0.2416164891 -0.7928586438 -1.4021593416 -1.5084824458 #>  [46]  1.1665591473 -0.4470766852  0.1832418297 -1.4419513255 -0.4686822079 #>  [51] -0.7294759716 -0.5724577368 -1.7143850372 -0.7664835132 -1.2144334213 #>  [56] -0.2051707920 -0.8366142826 -0.4389592302 -1.1230875453 -0.7201344255 #>  [61] -0.4160044624 -0.8043055713 -1.3102280677  1.0367104667 -2.3964580001 #>  [66] -2.9396645540  0.3186084451 -2.0375805328 -1.0930835175 -1.3034022819 #>  [71] -1.5158153961 -1.5680947264 -0.3067948624 -0.5808985385 -0.5819991518 #>  [76] -1.5689696785  1.4740684907 -3.0646822555 -0.6313226097 -0.2618518188 #>  [81] -3.3066816487 -0.7873094091 -1.9932454958 -1.7811007143 -1.2483440935 #>  [86] -1.7784917041 -3.2401027667 -1.3829618333 -2.7209154981 -0.8904969868 #>  [91] -0.7728596000 -0.2344604653  1.1079515813 -2.2903766409  0.4351375801 #>  [96]  0.2248913343  0.1257747005 -0.8387909492 -0.4283925160  1.2358473790 #>  #> $alpha1 #>   [1]  2.59605737  2.76761765 -0.62096828  0.59478527  0.99679217  0.78279027 #>   [7]  1.54347963  1.06346571  1.45275504  0.58267316  1.80858934  1.20940617 #>  [13]  1.54428885 -0.10503062  1.18478317  0.43780652  2.30825933  1.10272832 #>  [19]  1.28201511  0.76565797  1.74633791  0.91575651  1.96996349  0.74828352 #>  [25]  0.05513803  1.26673671  0.65208054  0.63421794  1.58626194  2.00183667 #>  [31]  1.67487758  1.61453582  1.50850067  1.03741108  1.24165899  2.48411940 #>  [37]  1.38428972  0.08319444  1.19106423  0.97806184  1.30715882  0.08844204 #>  [43] -0.81707357  1.75352933  0.73373336  1.43305342  1.34743647  0.96873479 #>  [49]  1.57859768  1.81010289  1.28486593  1.19528122  0.16303788  0.92104972 #>  [55]  1.46476916  0.99662247  1.54095039  1.60692219  0.35104730  0.87985821 #>  [61]  1.21690425 -1.06184065  2.48561735 -1.97990623  0.96152927  0.90955892 #>  [67]  1.42196109  2.11556143  0.65649779  1.12678189  2.97770530  1.82125870 #>  [73] -0.40449687  0.41519472  1.08734638  2.19750525 -0.65856013  1.45033447 #>  [79]  1.81010561  1.99009395  2.31577608  0.50967476  1.66978215  0.95804341 #>  [85]  0.79581782  3.02315699  4.31881199  0.74667531  2.05931320 -0.13098109 #>  [91]  3.01007634  0.02096394  1.42993984  1.04374577 -0.04937329  0.46008528 #>  [97]  2.49843542  1.33602882 -0.34849053  0.01393149 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 210 #>  #> Slot \"burnin\": #> [1] 10 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"LogisticNormalFixedMixture class standard logistic regression model fixed mixture multiple bivariate (log) normal priors intercept slope parameters. weights normal priors fixed, hence additional model parameters introduced. type prior often used better approximate given posterior distribution, information given terms mixture.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"LogisticNormalFixedMixture(components, weights, ref_dose, log_normal = FALSE)  .DefaultLogisticNormalFixedMixture()"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive normalized sum 1. ref_dose (number) reference dose \\(x*\\) (strictly positive number). log_normal (flag) log normal prior specified, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ normal prior used $$(alpha0, log(alpha1)) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ log normal prior used. weights \\(w1, ..., wK\\) components fixed sum 1. slots class comprise list components parameters. Every single component contains mean vector covariance matrix bivariate normal distributions. Remaining slots weights components well reference dose. Moreover, special indicator slot specifies whether log normal prior used.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive must sum 1. ref_dose (positive_number) reference dose. log_normal (flag) log normal prior used, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"Typically, end-users use .DefaultLogisticNormalFixedMixture() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"my_model <- LogisticNormalFixedMixture(   components = list(     comp1 = ModelParamsNormal(       mean = c(-0.85, 1),       cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)     ),     comp2 = ModelParamsNormal(       mean = c(1, 1.5),       cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)     )   ),   weights = c(0.3, 0.7),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalMixture — LogisticNormalMixture-class","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"LogisticNormalMixture class standard logistic regression model mixture two bivariate normal priors intercept slope parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"LogisticNormalMixture(comp1, comp2, weightpar, ref_dose)  .DefaultLogisticNormalMixture()"},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. See ModelParamsNormal details. comp2 (ModelParamsNormal) bivariate normal prior specification second component. See ModelParamsNormal details. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w * Normal(mean1, cov1) + (1 - w) * Normal(mean2, cov2).$$ weight w first component assigned beta prior B(, b).","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. comp2 (ModelParamsNormal) bivariate normal prior specification second component. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (positive_number) reference dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"weight two normal priors model parameter, hence flexible mixture. type prior often used mixture minimal informative informative component, order make CRM robust data deviations informative component. Typically, end-users use .DefaultLogisticNormalMixture() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"my_model <- LogisticNormalMixture(   comp1 = ModelParamsNormal(     mean = c(-0.85, 1),     cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)   ),   comp2 = ModelParamsNormal(     mean = c(1, 1.5),     cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)   ),   weightpar = c(a = 1, b = 1),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":null,"dir":"Reference","previous_headings":"","what":"McmcOptions — McmcOptions-class","title":"McmcOptions — McmcOptions-class","text":"McmcOptions class three canonical MCMC options well Random Number Generator settings.","code":""},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"McmcOptions — McmcOptions-class","text":"","code":"McmcOptions(   burnin = 10000L,   step = 2L,   samples = 10000L,   rng_kind = NA_character_,   rng_seed = NA_integer_ )  .DefaultMcmcOptions()"},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"McmcOptions — McmcOptions-class","text":"burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burn-. samples (count) number resulting samples. rng_kind (string) name RNG type. Possible types : Wichmann-Hill, Marsaglia-Multicarry, Super-Duper, Mersenne-Twister. NA (default), RNG kind chosen [rjags]. rng_seed (number) RNG seed corresponding chosen rng_kind. must integer value NA (default), means seed chosen [rjags].","code":""},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"McmcOptions — McmcOptions-class","text":"iterations (count) number MCMC iterations. burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burnin. words, sample iteration = 1,...,iterations, saved (- burnin) mod step = 0. example, iterations = 6, burnin = 0 step = 2, samples iterations 2,4,6 saved. rng_kind (string) Random Number Generator (RNG) type used rjags. must one following four values: base::Wichmann-Hill, base::Marsaglia-Multicarry, base::Super-Duper, base::Mersenne-Twister, NA_character_. NA_character_ (default), RNG kind chosen rjags. rng_seed (number) Random Number Generator (RNG) seed used rjags chosen rng_kind. must integer scalar NA_integer_, means seed chosen rjags.","code":""},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"McmcOptions — McmcOptions-class","text":"Typically, end users use .DefaultMcmcOptions() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/McmcOptions-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"McmcOptions — McmcOptions-class","text":"","code":"# Set up MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. McmcOptions(burnin = 10000, step = 2, samples = 10000) #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 30000 #>  #> Slot \"burnin\": #> [1] 10000 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>"},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a minimally informative prior — MinimalInformative","title":"Construct a minimally informative prior — MinimalInformative","text":"function constructs minimally informative prior, captured LogisticNormal (LogisticLogNormal) object.","code":""},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"MinimalInformative(   dosegrid,   refDose,   threshmin = 0.2,   threshmax = 0.3,   probmin = 0.05,   probmax = 0.05,   ... )"},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a minimally informative prior — MinimalInformative","text":"dosegrid dose grid refDose reference dose threshmin toxicity probability threshold unlikely (see probmin) minimum dose (default: 0.2) threshmax toxicity probability threshold unlikely (see probmax) maximum dose (default: 0.3) probmin prior probability exceeding threshmin minimum dose (default: 0.05) probmax prior probability threshmax maximum dose (default: 0.05) ... additional arguments computations, see Quantiles2LogisticNormal, e.g. refDose logNormal=TRUE obtain minimal informative log normal prior.","code":""},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a minimally informative prior — MinimalInformative","text":"see Quantiles2LogisticNormal","code":""},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a minimally informative prior — MinimalInformative","text":"Based proposal Neuenschwander et al (2008, Statistics Medicine), minimally informative prior distribution constructed. required key input minimum (\\(d_{1}\\) notation Appendix .1 paper) maximum value (\\(d_{J}\\)) dose grid supplied function. threshmin probability threshold \\(q_{1}\\), probability DLT larger \\(q_{1}\\) 5% probability. Therefore \\(q_{1}\\) 95% quantile beta distribution hence \\(p_{1} = 0.95\\). Likewise, threshmax probability threshold \\(q_{J}\\), probability DLT smaller \\(q_{J}\\) 5% probability (\\(p_{J} = 0.05\\)). probabilities \\(1 - p_{1}\\) \\(p_{J}\\) can controlled arguments probmin probmax, respectively. Subsequently, doses supplied dosegrid argument, beta distributions set assumption prior medians linear log-dose logit scale, Quantiles2LogisticNormal used transform resulting quantiles approximating LogisticNormal (LogisticLogNormal) model. Note reference dose required computations.","code":""},{"path":"https://roche.github.io/crmPack/reference/MinimalInformative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"# Setting up a minimal informative prior  # max.time is quite small only for the purpose of showing the example. They  # should be increased for a real case. set.seed(132) coarseGrid <- c(0.1, 10, 30, 60, 100) minInfModel <- MinimalInformative(dosegrid = coarseGrid,                                   refDose=50,                                   threshmin=0.2,                                   threshmax=0.3,                                   control=## for real case: leave out control                                      list(max.time=0.1))  #> It: 1, obj value: 0.6727662311  # Plotting the result matplot(x=coarseGrid,         y=minInfModel$required,         type=\"b\", pch=19, col=\"blue\", lty=1,         xlab=\"dose\",         ylab=\"prior probability of DLT\") matlines(x=coarseGrid,          y=minInfModel$quantiles,          type=\"b\", pch=19, col=\"red\", lty=1) legend(\"right\",        legend=c(\"quantiles\", \"approximation\"),        col=c(\"blue\", \"red\"),        lty=1,        bty=\"n\")"},{"path":"https://roche.github.io/crmPack/reference/ModelEff-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelEff — ModelEff-class","title":"ModelEff — ModelEff-class","text":"ModelEff parent class efficacy models using pseudo data prior. dedicated efficacy models prior specified form pseudo data (data trial starts). data must obey convention DataDual class. refers observed efficacy/biomarker responses (w DataDual), dose levels responses observed (x DataDual), dose levels considered study (doseGrid DataDual), finally specifications DataDual class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelEff-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelEff — ModelEff-class","text":"","code":".DefaultModelEff()"},{"path":"https://roche.github.io/crmPack/reference/ModelEff-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelEff — ModelEff-class","text":"data (DataDual) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelEff-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelEff — ModelEff-class","text":"Typically, end users use .DefaultModelEff() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ModelLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelLogNormal — ModelLogNormal-class","title":"ModelLogNormal — ModelLogNormal-class","text":"ModelLogNormal class model reference dose bivariate normal prior model parameters alpha0 natural logarithm alpha1, .e.: $$(alpha0, log(alpha1)) ~ Normal(mean, cov),$$. Transformations log, e.g. identity, can specified priormodel slot. parameter alpha1 log-normal distribution default ensure positivity alpha1 guarantees exp(alpha1) > 1. slots class contain mean vector, covariance precision matrices bivariate normal distribution, well reference dose. Note precision matrix inverse covariance matrix JAGS. (\"normal\") model specific classes inherit class.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelLogNormal — ModelLogNormal-class","text":"","code":"ModelLogNormal(mean, cov, ref_dose = 1)  .DefaultModelLogNormal()"},{"path":"https://roche.github.io/crmPack/reference/ModelLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelLogNormal — ModelLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelLogNormal — ModelLogNormal-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (positive_number) reference dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelLogNormal — ModelLogNormal-class","text":"Typically, end users use .DefaultModelLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelParamsNormal — ModelParamsNormal-class","title":"ModelParamsNormal — ModelParamsNormal-class","text":"ModelParamsNormal class bivariate normal model parameters, .e. mean vector, covariance matrix precision matrix. precision matrix inverse covariance matrix JAGS computed internally object constructor function.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean, cov)  .DefaultModelParamsNormal()"},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) mean vector. cov (matrix) covariance matrix. prec (matrix) precision matrix, inverse matrix cov.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelParamsNormal — ModelParamsNormal-class","text":"Typically, end users use .ModelPAramsNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean = c(1, 6), cov = diag(2)) #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] 1 6 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> Slot \"prec\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>"},{"path":"https://roche.github.io/crmPack/reference/ModelPseudo-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelPseudo — ModelPseudo-class","title":"ModelPseudo — ModelPseudo-class","text":"ModelPseudo parent class models express prior form pseudo data (data trial starts).","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelPseudo-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelPseudo — ModelPseudo-class","text":"","code":".DefaultModelPseudo()"},{"path":"https://roche.github.io/crmPack/reference/ModelPseudo-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelPseudo — ModelPseudo-class","text":"Typically, end users use .DefaultModelPseudo() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ModelTox-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelTox — ModelTox-class","title":"ModelTox — ModelTox-class","text":"ModelTox parent class DLE (dose-limiting events) models using pseudo data prior. dedicated DLE models toxicity models prior specified form pseudo data (data trial starts). data must obey convention Data class. refers observed DLE responses (y Data), dose levels (x Data) responses observed, dose levels considered study (doseGrid Data), finally specifications Data class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelTox-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelTox — ModelTox-class","text":"","code":".DefaultModelTox()"},{"path":"https://roche.github.io/crmPack/reference/ModelTox-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelTox — ModelTox-class","text":"data (Data) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":"https://roche.github.io/crmPack/reference/ModelTox-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelTox — ModelTox-class","text":"Typically, end users use .DefaultModelTox() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/NextBest-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBest — NextBest-class","title":"NextBest — NextBest-class","text":"NextBest virtual class finding next best dose, specific next best dose classes inherit.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBest-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBest — NextBest-class","text":"","code":".DefaultNextBest()"},{"path":"https://roche.github.io/crmPack/reference/NextBest-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBest — NextBest-class","text":"Typically, end users use DefaultNextBest() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestDualEndpoint — NextBestDualEndpoint-class","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"NextBestDualEndpoint class next best dose based dual endpoint model.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"NextBestDualEndpoint(   target,   overdose,   max_overdose_prob,   target_relative = TRUE,   target_thresh = 0.01 )  .DefaultNextBestDualEndpoint()"},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition. target_relative (flag) see slot definition. target_thresh (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"rule, first admissible doses found, toxicity probability fall overdose category max_overdose_prob. Next, picks (remaining admissible doses) one maximizes probability target biomarker range. default (target_relative = TRUE) target specified relative maximum biomarker level across dose grid relative Emax parameter case parametric model selected (.e. DualEndpointBeta, DualEndpointEmax). However, target_relative = FALSE, absolute biomarker range can used target.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) biomarker target range needs reached. example, target range \\((0.8, 1.0)\\) target_relative = TRUE means target dose least \\(80\\%\\) maximum biomarker level. example, \\((0.5, 0.8)\\) mean target dose \\(50\\%\\) \\(80\\%\\) maximum biomarker level. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). max_overdose_prob (proportion) maximum overdose probability allowed. target_relative (flag) target specified relative? TRUE, target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. target_thresh (proportion) target probability threshold needs fulfilled target probability used deriving next best dose (default 0.01).","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"Typically, end users use .DefaultNextBestDualEndpoint() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"# Target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT) > 0.35 (safety). my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Now, using absolute target on the natural biomarker scale. my_next_best_absolute <- NextBestDualEndpoint(   target = c(200, 300),   overdose = c(0.35, 1),   max_overdose_prob = 0.25,   target_relative = FALSE )"},{"path":"https://roche.github.io/crmPack/reference/NextBestInfTheory-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestInfTheory — NextBestInfTheory-class","title":"NextBestInfTheory — NextBestInfTheory-class","text":"NextBestInfTheory class next best dose based information theory proposed https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestInfTheory — NextBestInfTheory-class","text":"","code":"NextBestInfTheory(target, asymmetry)  .DefaultNextBestInfTheory()"},{"path":"https://roche.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) see slot definition. asymmetry (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) target toxicity probability, except 0 1. asymmetry (number) value asymmetry exponent divergence function describes rate penalization overly toxic . must value \\((0, 2)\\) interval.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestInfTheory — NextBestInfTheory-class","text":"Typically, end users use .DefaultNextBestInfTheory() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMTD — NextBestMTD-class","title":"NextBestMTD — NextBestMTD-class","text":"NextBestMTD class next best dose based MTD estimate.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMTD — NextBestMTD-class","text":"","code":"NextBestMTD(target, derive)  .DefaultNextBestMTD()"},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) see slot definition. derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) target toxicity probability, except 0 1. derive (function) function derives final next best MTD estimate, based vector posterior MTD samples. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMTD — NextBestMTD-class","text":"Typically, end users use .DefaultNextBestMTD() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMTD — NextBestMTD-class","text":"","code":"# In the example below, the MTD is defined as the dose for which prob(DLE) = 0.33 # and we will use the 25th quantile of the posterior of MTD as our next best dose. next_best_mtd <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )"},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGain — NextBestMaxGain-class","title":"NextBestMaxGain — NextBestMaxGain-class","text":"NextBestMaxGain class find next best dose maximum gain value based pseudo DLT efficacy models without samples. based solely probabilities occurrence DLT values mean efficacy responses obtained using modal estimates DLT efficacy model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes (except EffFlexi).","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"NextBestMaxGain(prob_target_drt, prob_target_eot)  .DefaultNextBestMaxGain()"},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) target probability occurrence DLT used trial. prob_target_eot (proportion) target probability occurrence DLT used end trial.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMaxGain — NextBestMaxGain-class","text":"Typically, end users use .DefaultNextBestMaxGain() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"my_next_best <- NextBestMaxGain(0.35, 0.3)"},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"NextBestMaxGainSamples class find next best dose maximum gain value based pseudo DLT efficacy models DLT efficacy samples. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"NextBestMaxGainSamples(prob_target_drt, prob_target_eot, derive, mg_derive)  .DefaultNextBestMaxGainSamples()"},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"prob_target_drt (proportion) see slot definition NextBestMaxGain. prob_target_eot (proportion) see slot definition NextBestMaxGain. derive (function) see slot definition. mg_derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number. mg_derive (function) derives, based vector posterior dose samples give maximum gain value, final next best estimate dose gives maximum gain value. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"Typically, end users use .DefaultNextBestMaxGainSamples() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. # For `mg_derive` function (which takes the sample of doses which give the maximum # gain), we will use the 50% posterior quantile (the median or th 50th percentile) # of the sample. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )"},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMinDist — NextBestMinDist-class","title":"NextBestMinDist — NextBestMinDist-class","text":"NextBestMinDist class next best dose based minimum distance target probability.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"NextBestMinDist(target)  .DefaultNextBestMinDist()"},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) single target toxicity probability, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMinDist — NextBestMinDist-class","text":"Typically, end users use .DefaultNextBestMinDist() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestMinDist-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"# In the example below, the MTD is defined as the dose with the toxicity rate # with minimal distance to the target of 30%. next_best_min_dist <- NextBestMinDist(target = 0.3)"},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRM — NextBestNCRM-class","title":"NextBestNCRM — NextBestNCRM-class","text":"NextBestNCRM class next best dose finds next dose high posterior probability target toxicity interval.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"NextBestNCRM(target, overdose, max_overdose_prob)  .DefaultNextBestNCRM()"},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestNCRM — NextBestNCRM-class","text":"avoid numerical problems, dose selection algorithm implemented follows: First admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, maximum probability fall target category calculated. 5% (.e. just numerical error), corresponding dose next recommended dose. Otherwise, highest admissible dose next recommended dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) target toxicity interval (limits included). overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). used filter probability samples. max_overdose_prob (proportion) maximum overdose posterior probability allowed, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestNCRM — NextBestNCRM-class","text":"Typically, end users use .DefaultNextBestNCRM() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35,1]. Finally we would like to constrain the # probability of overdosing below 25%. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRMLoss — NextBestNCRMLoss-class","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"NextBestNCRMLoss class based NCRM rule loss function. class similar NextBestNCRM class, differences addition loss function re-defined toxicity intervals, see toxicity interval documentation note details. NCRM rule, first admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, loss function calculated, .e. losses %*% target. Finally, corresponding dose lowest loss function (Bayes risk) recommended next dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"NextBestNCRMLoss(   target,   overdose,   unacceptable = c(1, 1),   max_overdose_prob,   losses )  .DefaultNextBestNCRMLoss()"},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. unacceptable (numeric) see slot definition. max_overdose_prob (proportion) see slot definition NextBestNCRM. losses (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) target toxicity interval (limits included). probability range excluding 0 1. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included) excessive toxicity interval (lower limit excluded, upper limit included) unacceptable provided. probability range. used filter probability samples. unacceptable (numeric) unacceptable toxicity interval (lower limit excluded, upper limit included). must specified overdose include 1. Otherwise, c(1, 1) (default), essentially scalar equals 1. probability range. losses (numeric) vector specifying loss function. unacceptable provided, vector length must 4, otherwise 3.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"loss function vector either 3 4 values. loss function values must specified interval, -dosing, target toxicity, overdosing toxicity -dosing, target toxicity, overdosing (excessive) toxicity, unacceptable toxicity intervals. Typically, end users use .DefaultNextBestnCRMLoss() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35, 1]. We would like to constrain the probability # of overdosing below 25%. The loss function is c(1, 0, 1, 2). my_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.25,   losses = c(1, 0, 1, 2) )"},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"NextBestProbMTDLTE class finding next best dose selects dose highest probability toxicity rate less equal toxicity target. dose determined calculating posterior toxicity probability dose per iteration select maximum dose toxicity probability equal target. dose highest frequency selected MTD across iterations next best dose. Placebo considered calculation removed dose grid calculations.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"","code":"NextBestProbMTDLTE(target)  .DefaultNextBestProbMTDLTE()"},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"target (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"target (numeric) target toxicity probability.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"Typically, end users use .DefaultNextBestProbMTDLTE() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"","code":"# In the example below, the MTD is defined as the dose with the highest # probability of having a toxicity rate below 30%. next_best_prob_mtd_lte <- NextBestProbMTDLTE(target = 0.3)"},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"NextBestProbMTDMinDist class finding next best dose selects dose highest probability toxicity rate smallest distance toxicity target. dose determined calculating posterior toxicity probability dose per iteration select dose smallest toxicity probability distance target. dose highest frequency selected MTD across iterations next best dose. Placebo considered next dose reason used calculations. .e. placebo toxicity probability distance target calculated taken account determination next dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"","code":"NextBestProbMTDMinDist(target)  .DefaultNextBestProbMTDMinDist()"},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"target (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"target (numeric) target toxicity probability.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"Typically, end users use .DefaultNextBestProbMTDMinDist() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"","code":"# In the example below, the MTD is defined as the dose with the highest # probability of having a toxicity rate with minimal distance # to the target of 30%. next_best_prob_mtd_min_dist <- NextBestProbMTDMinDist(target = 0.3)"},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTD — NextBestTD-class","title":"NextBestTD — NextBestTD-class","text":"NextBestTD class find next best dose based pseudo DLT model without samples. Namely, find two next best doses, one allocation trial second final recommendation end trial without involving samples, .e. DLT responses incorporated dose-allocation. based solely probabilities occurrence DLT obtained using modal estimates model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model class.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTD — NextBestTD-class","text":"","code":".DefaultNextBestTD()  NextBestTD(prob_target_drt, prob_target_eot)"},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) target probability (except 0 1) occurrence DLT used trial. prob_target_eot (proportion) target probability (except 0 1) occurrence DLT used end trial.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestTD — NextBestTD-class","text":"Typically, end users use .DefaultNextBestTD() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTD — NextBestTD-class","text":"","code":"my_next_best <- NextBestTD(0.35, 0.3)"},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTDsamples — NextBestTDsamples-class","title":"NextBestTDsamples — NextBestTDsamples-class","text":"NextBestTDsamples class find next best dose based Pseudo DLT model samples. Namely, find two next best doses, one allocation trial second final recommendation end trial. Hence, two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"NextBestTDsamples(prob_target_drt, prob_target_eot, derive)  .DefaultNextBestTDsamples()"},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTDsamples — NextBestTDsamples-class","text":"prob_target_drt (proportion) see slot definition NextBestTD. prob_target_eot (proportion) see slot definition NextBestTD. derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTDsamples — NextBestTDsamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestTDsamples — NextBestTDsamples-class","text":"Typically, end users use .DefaultNextBestTDsamples() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. my_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )"},{"path":"https://roche.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestThreePlusThree — NextBestThreePlusThree-class","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"NextBestThreePlusThree class next best dose implements classical 3+3 dose recommendation. input required, hence class slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"NextBestThreePlusThree()  .DefaultNextBestThreePlusThree()"},{"path":"https://roche.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"Typically, end users use .DefaultNextBestThreePlusThree() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"# Next best dose class object using the classical 3+3 design. my_next_best <- NextBestThreePlusThree()"},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParExpPrior — OneParExpPrior-class","title":"OneParExpPrior — OneParExpPrior-class","text":"OneParExpPrior class standard CRM exponential prior power parameter skeleton prior probabilities. implementation version one-parameter CRM (O’Quigley et al. 1990).","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"OneParExpPrior(skel_probs, dose_grid, lambda)  .DefaultOneParExpPrior()"},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_probs see slot definition. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. lambda see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. lambda (number) rate parameter prior exponential distribution theta.","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OneParExpPrior — OneParExpPrior-class","text":"Typically, end users use .DefaultOneparExpPrior() function. Typically, end users use .DefaultOneParLogNormalPrior() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParExpPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"my_model <- OneParExpPrior(   skel_probs = c(0.1, 0.3, 0.5, 0.7, 0.9),   dose_grid = 1:5,   lambda = 2 )"},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParLogNormalPrior — OneParLogNormalPrior-class","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"OneParLogNormalPrior class standard CRM normal prior log power parameter skeleton prior probabilities.","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"OneParLogNormalPrior(skel_probs, dose_grid, sigma2)  .DefaultOneParLogNormalPrior()"},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"instance OneParLogNormalPrior class","code":""},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"my_model <- OneParLogNormalPrior(   skel_probs = seq(from = 0.1, to = 0.9, length = 5),   dose_grid = 1:5,   sigma2 = 2 )"},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormal — ProbitLogNormal-class","title":"ProbitLogNormal — ProbitLogNormal-class","text":"ProbitLogNormal class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"ProbitLogNormal(mean, cov, ref_dose = 1)  .DefaultProbitLogNormal()"},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormal — ProbitLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormal — ProbitLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormal — ProbitLogNormal-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible. Typically, end users use .DefaultProbitLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"my_model <- ProbitLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 7.2 )"},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormalRel — ProbitLogNormalRel-class","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"ProbitLogNormalRel class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"ProbitLogNormalRel(mean, cov, ref_dose = 1)  .DefaultProbitLogNormalRel()"},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"covariate dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * x/x*,$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible. Typically, end users use .DefaultProbitLogNormalRel() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"my_model <- ProbitLogNormalRel(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )"},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","title":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","text":"class captures trial simulations design using DLE efficacy responses. design model ModelTox class efficacy model EffFlexi class contains slots GeneralSimulations, PseudoSimulations PseudoDualSimulations object. comparison parent class PseudoDualSimulations, contains additional slots capture sigma2betaW estimates.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","text":"sigma2betaWest vector final posterior mean sigma2betaW estimates","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"Initialization function 'PseudoDualFlexiSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"","code":"PseudoDualFlexiSimulations(sigma2betaWest, ...)"},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"sigma2betaWest please refer PseudoDualFlexiSimulations class object ... additional parameters PseudoDualSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualFlexiSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"PseudoDualFlexiSimulations object","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class PseudoDualSimulations — PseudoDualSimulations-class","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"class captures trial simulations design using DLE efficacy responses. design model ModelTox class efficacy model ModelEff class (except EffFlexi class). contains slots GeneralSimulations PseudoSimulations object. comparison parent class PseudoSimulations, contains additional slots capture dose-efficacy curve sigma2 estimates.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"","code":".DefaultPseudoDualSimulations()"},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"fitEff list final values. DLE efficacy samples generated, contains final fitted values. DLE efficacy samples used, contains modal estimates parameters two models posterior estimates probabilities occurrence DLE expected efficacy responses. FinalGstarEstimates vector final estimates Gstar end simulations. FinalGstarAtDoseGrid vector final estimates Gstar dose Grid end simulations FinalGstarCIs list 95% credibility interval final estimates Gstar FinalGstarRatios vector ratios CI, ratio upper lower 95% credibility interval final estimates Gstar FinalOptimalDose vector final optimal dose, minimum final TDtargetEndOfTrial estimates Gstar estimates FinalOptimalDoseAtDoseGrid vector final optimal dose, minimum final TDtargetEndOfTrial estimates Gstar estimates dose Grid sigma2est vector final posterior mean sigma2 estimates","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"Typically, end users use .DefaultPseudoDualSimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"Initialization function 'DualPseudoSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"","code":"PseudoDualSimulations(   fitEff,   FinalGstarEstimates,   FinalGstarAtDoseGrid,   FinalGstarCIs,   FinalGstarRatios,   FinalOptimalDose,   FinalOptimalDoseAtDoseGrid,   sigma2est,   ... )"},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"fitEff please refer PseudoDualSimulations class object FinalGstarEstimates please refer PseudoDualSimulations class object FinalGstarAtDoseGrid please refer PseudoDualSimulations class object FinalGstarCIs please refer PseudoDualSimulations class object FinalGstarRatios please refer PseudoDualSimulations class object FinalOptimalDose please refer PseudoDualSimulations class object FinalOptimalDoseAtDoseGrid please refer PseudoDualSimulations class object sigma2est please refer PseudoDualSimulations class object ... additional parameters PseudoSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"PseudoDualSimulations object","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"contains slots PseudoSimulationsSummary object. addition slots parent class PseudoSimulationsSummary, contains four slots efficacy model fit information.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"","code":".DefaultPseudoDualSimulationsSummary()"},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"targetGstar target dose level gain value maximum targetGstarAtDoseGrid dose level dose Grid closest Gstar GstarSummary six-number table summary (lowest, 25th, 50th (median), 75th percentile, mean highest value) final Gstar values obtained across simulations ratioGstarSummary six-number summary table ratios upper lower 95% credibility intervals final Gstar across simulations EffFitAtDoseMostSelected fitted expected mean efficacy value dose often selected meanEffFit list mean, lower (2.5%) upper (97.5%) quantiles fitted expected efficacy value dose level.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"Typically, end users use .DefaultPseudoDualSimulationsSummary() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class PseudoSimulations — PseudoSimulations-class","title":"Class PseudoSimulations — PseudoSimulations-class","text":"class captures trial simulations designs using pseudo model. design DLE responses model ModelTox class object. contains slots GeneralSimulations object. Additional slots fit stopReasons compared general class GeneralSimulations.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class PseudoSimulations — PseudoSimulations-class","text":"","code":".DefaultPseudoSimulations()"},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class PseudoSimulations — PseudoSimulations-class","text":"fit list final values. samples involved, final fitted values. samples involved, included final modal estimates model parameters posterior estimates probabilities occurrence DLE. FinalTDtargetDuringTrialEstimates vector final estimates (last estimate ) TDtargetDuringTrial end simulations/trial stops FinalTDtargetEndOfTrialEstimates vector final estimates last estimate TDtargetEndOfTrial trial stops FinalTDtargetDuringTrialAtDoseGrid vector dose levels dose grid closest final TDtargetDuringTrial estimates FinalTDtargetEndOfTrialAtDoseGrid vector  dose levels dose grid closest final TDtargetEndOfTrial estimates FinalTDEOTCIs list 95% credibility interval final estimates TDtargetEndOfTrial FinalTDEOTRatios vector ratios CI, ratio upper lower 95% credibility intervals final estimates TDtargetEndOfTrial FinalCIs list final 95% credibility intervals TDtargetEndofTrial estimates final optimal dose estimates DLE efficacy responses incorporated simulations FinalRatios vector final ratios, ratios upper lower 95% credibility interval final estimates TDtargetEndOfTrial final optimal dose estimates (DLE efficacy responses incorporated) simulations stopReasons add slot description","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class PseudoSimulations — PseudoSimulations-class","text":"Typically, end users use .DefaultPseudoSimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"Initialization function 'PseudoSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"","code":"PseudoSimulations(   fit,   FinalTDtargetDuringTrialEstimates,   FinalTDtargetEndOfTrialEstimates,   FinalTDtargetDuringTrialAtDoseGrid,   FinalTDtargetEndOfTrialAtDoseGrid,   FinalTDEOTCIs,   FinalTDEOTRatios,   FinalCIs,   FinalRatios,   stopReasons,   ... )"},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"fit please refer PseudoSimulations class object FinalTDtargetDuringTrialEstimates please refer PseudoSimulations class object FinalTDtargetEndOfTrialEstimates please refer PseudoSimulations class object FinalTDtargetDuringTrialAtDoseGrid please refer PseudoSimulations class object FinalTDtargetEndOfTrialAtDoseGrid please refer PseudoSimulations class object FinalTDEOTCIs please refer PseudoSimulations class object FinalTDEOTRatios please refer PseudoSimulations class object FinalCIs please refer PseudoSimulations class object FinalRatios please refer PseudoSimulations class object stopReasons please refer PseudoSimulations class object ... additional parameters GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"PseudoSimulations object","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/reference/PseudoSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"targetEndOfTrial target probability DLE wanted end trial targetDoseEndOfTrial dose level corresponds target probability DLE wanted end trial, TDEOT targetDoseEndOfTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted end trial targetDuringTrial target probability DLE wanted trial targetDoseDuringTrial dose level corresponds target probability DLE wanted trial. TDDT targetDoseDuringTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted trial TDEOTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want end trial across simulations TDDTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want trial across simulations FinalDoseRecSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final optimal doses, either TDEOT DLE response incorporated escalation procedure minimum TDEOT Gstar DLE efficacy responses incorporated, across simulations ratioTDEOTSummary six-number summary table final ratios upper lower 95% credibility intervals final TDEOTs across simulations FinalRatioSummary six-number summary table final ratios upper lower 95% credibility intervals final optimal doses across simulations #@slot doseRec dose level recommend subsequent study nsim number simulations propDLE proportions DLE trials meanToxRisk mean toxicity risks patients doseSelected doses selected MTD (targetDoseEndOfTrial) toxAtDosesSelected true toxicity doses selected propAtTargetEndOfTrial Proportion trials selecting doseGrid closest MTD, targetDoseEndOfTrial propAtTargetDuringTrial Proportion trials selecting doseGrid closest targetDoseDuringTrial doseMostSelected dose often selected MTD obsToxRateAtDoseMostSelected observed toxicity rate dose often selected nObs number patients overall nAboveTargetEndOfTrial number patients treated targetDoseEndOfTrial nAboveTargetDuringTrial number patients treated targetDoseDuringTrial doseGrid dose grid used fitAtDoseMostSelected fitted toxicity rate dose often selected meanFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level","code":""},{"path":"https://roche.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"function uses generalized simulated annealing optimize LogisticNormal model close possible given prior quantiles.","code":""},{"path":"https://roche.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"","code":"Quantiles2LogisticNormal(   dosegrid,   refDose,   lower,   median,   upper,   level = 0.95,   logNormal = FALSE,   parstart = NULL,   parlower = c(-10, -10, 0, 0, -0.95),   parupper = c(10, 10, 10, 10, 0.95),   seed = 12345,   verbose = TRUE,   control = list(threshold.stop = 0.01, maxit = 50000, temperature = 50000, max.time =     600) )"},{"path":"https://roche.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"dosegrid dose grid refDose reference dose lower lower quantiles median medians upper upper quantiles level credible level (lower, upper) intervals (default: 0.95) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used parstart starting values parameters. default, determined medians supplied. parlower lower bounds parameters (intercept alpha slope beta, corresponding standard deviations correlation.) parupper upper bounds parameters seed seed random number generation verbose verbose? (default) control additional options optimisation routine, see GenSA details","code":""},{"path":"https://roche.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"list best approximating model (LogisticNormal LogisticLogNormal), resulting quantiles, required quantiles distance required quantiles, well final parameters (used running algorithm second time)","code":""},{"path":"https://roche.github.io/crmPack/reference/Report.html","id":null,"dir":"Reference","previous_headings":"","what":"A Reference Class to represent sequentially updated reporting objects. — Report","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"Reference Class represent sequentially updated reporting objects.","code":""},{"path":"https://roche.github.io/crmPack/reference/Report.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"object object report df data frame columns sequentially added dfNames names strings sequentially added","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"RuleDesign — RuleDesign-class","title":"RuleDesign — RuleDesign-class","text":"RuleDesign class rule-based designs. difference class Design class RuleDesign contain model, stopping increments slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RuleDesign — RuleDesign-class","text":"","code":"RuleDesign(nextBest, cohort_size, data, startingDose)  .DefaultRuleDesign()  ThreePlusThreeDesign(doseGrid)"},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RuleDesign — RuleDesign-class","text":"nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition. doseGrid (numeric) dose grid used (sorted).","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"RuleDesign — RuleDesign-class","text":"ThreePlusThreeDesign(): creates new 3+3 design object dose grid.","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"RuleDesign — RuleDesign-class","text":"nextBest (NextBest) find next best dose. cohort_size (CohortSize) rules cohort sizes. data (Data) specifies dose grid, previous data, etc. startingDose (number) starting dose, must lie dose grid data.","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"RuleDesign — RuleDesign-class","text":"Typically, end users use .DefaultRuleDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/RuleDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RuleDesign — RuleDesign-class","text":"","code":"# Specify the design to run simulations. The design comprises a model, # the escalation rule, starting data, a cohort size and a starting dose.  # Initialing a 3+3 design with constant cohort size of 3 and starting dose equal 5. my_design <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80)),   startingDose = 5 ) # Initialing a 3+3 design with constant cohort size of 3 and starting dose equal 8. my_design <- ThreePlusThreeDesign(doseGrid = c(8, 10, 15, 25, 35, 50, 80))"},{"path":"https://roche.github.io/crmPack/reference/SafetyWindow-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindow — SafetyWindow-class","title":"SafetyWindow — SafetyWindow-class","text":"SafetyWindow class safety window.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindow-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindow — SafetyWindow-class","text":"","code":".DefaultSafetyWindow()"},{"path":"https://roche.github.io/crmPack/reference/SafetyWindow-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindow — SafetyWindow-class","text":"Typically, end users use .DefaultSafetyWindow() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowConst — SafetyWindowConst-class","title":"SafetyWindowConst — SafetyWindowConst-class","text":"SafetyWindowConst class safety window length used gap kept constant.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"SafetyWindowConst(gap, follow, follow_min)  .DefaultSafetyWindowConst()"},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap (integer) vector, constant gap patients. follow (count) long follow patient. period time patient cohort needs followed next cohort opens. follow_min (count) minimum follow . least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindowConst — SafetyWindowConst-class","text":"Typically, end users use .DefaultSafetyWindowConst() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"# This is to have along the study constant parameters settings of safety window # length, regardless of the cohort size. my_win_len <- SafetyWindowConst(   gap = c(7, 5, 3),   follow = 7,   follow_min = 14 )"},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowSize — SafetyWindowSize-class","title":"SafetyWindowSize — SafetyWindowSize-class","text":"SafetyWindowSize class safety window length based cohort size. class used decide rolling rule clinical perspective.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"SafetyWindowSize(gap, size, follow, follow_min)  .DefaultSafetyWindowSize()"},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap see slot definition. size see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap (list) observed period previous patient next patient can dosed. used follows. instance, cohort size 4 want specify three time intervals four consecutive patients, .e. 7 units time 1st 2nd patient, 5 units 2nd 3rd one, finally 3 units 3rd 4th one, , gap = list(c(7L, 5L, 3L)). Sometimes, want interval 1st 2nd patient increased safety consideration rest time intervals remain constant, regardless cohort size . , gap = list(c(7L, 3L)) package automatically repeat last element vector remaining time intervals. size (integer) vector left bounds relevant cohort size intervals. used follows. instance, want change gap based cohort size, .e. time interval 1st 2nd patient = 9 units time rest time intervals 5 units time cohort size equal larger 4. time interval 1st 2nd patient = 7 units time rest time intervals 3 units time cohort size smaller 4, specify size = c(0L, 4L). means, right bound intervals exclusive interval, last interval goes last value infinity. follow (count) period time patient cohort needs followed next cohort opens. follow_min (count) least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindowSize — SafetyWindowSize-class","text":"Typically, end users use .DefaultSafetyWindowSize() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"# Rule for having patient gap (7,3,3,3,...) for cohort size < 4, and # patient gap (9,5,5,5...) for cohort size >= 4. my_window_len <- SafetyWindowSize(   gap = list(c(7, 3), c(9, 5)),   size = c(1, 4),   follow = 7,   follow_min = 14 )"},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Samples — Samples-class","title":"Samples — Samples-class","text":"Samples class store MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Samples — Samples-class","text":"","code":"Samples(data, options)  .DefaultSamples()"},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Samples — Samples-class","text":"data see slot definition. options see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Samples — Samples-class","text":"data (list) MCMC samples parameter. entry list must vector (case scalar parameter) matrix (case vector-valued parameter) samples. case matrix, every row separate sample, columns correspond dimension parameter. options (McmcOptions) MCMC options used generate samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Samples — Samples-class","text":"Typically, end users use .DefaultSamples() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Samples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Samples — Samples-class","text":"","code":"# The MCMC options that were used to generate the samples. my_options <- McmcOptions(   burnin = 1000,   step = 2,   samples = 1000 )  # Create an object of class 'Samples' # Here the parameters 'alpha' and 'beta' are randomly generated. Of course, in # a real example these would be a samples coming from MCMC procedures. my_samples <- Samples(   data = list(alpha = rnorm(1000), beta = rnorm(1000)),   options = my_options )"},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulations — Simulations-class","title":"Simulations — Simulations-class","text":"class captures trial simulations model based designs. Additional slots fit, stop_reasons, stop_report,additional_stats compared general class GeneralSimulations.","code":""},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulations — Simulations-class","text":"","code":"Simulations(fit, stop_reasons, stop_report, additional_stats, ...)  .DefaultSimulations()"},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulations — Simulations-class","text":"fit (list) see slot definition. stop_reasons (list) see slot definition. stop_report see Simulations additional_stats (list) see slot definition. ... additional parameters GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Simulations — Simulations-class","text":"fit (list) final fits stop_reasons (list) stopping reasons simulation run stop_report matrix stopping rule outcomes additional_stats list additional statistical summary","code":""},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulations — Simulations-class","text":"Typically, end users use .DefaultSimulations() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Simulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulations — Simulations-class","text":"","code":"data <- list(   Data(     x = 1:2,     y = 0:1,     doseGrid = 1:2,     ID = 1L:2L,     cohort = 1L:2L   ),   Data(     x = 3:4,     y = 0:1,     doseGrid = 3:4,     ID = 1L:2L,     cohort = 1L:2L   ) )  doses <- c(1, 2)  seed <- as.integer(123)  fit <- list(   c(0.1, 0.2),   c(0.3, 0.4) )  stop_report <- matrix(c(TRUE, FALSE), nrow = 2)  stop_reasons <- list(\"A\", \"B\")  additional_stats <- list(a = 1, b = 1)  simulations <- Simulations(   fit = fit,   stop_report = stop_report,   stop_reasons = stop_reasons,   additional_stats = additional_stats,   data,   doses,   seed )"},{"path":"https://roche.github.io/crmPack/reference/SimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of model-based simulations output — SimulationsSummary-class","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"addition slots parent class GeneralSimulationsSummary, contains two slots model fit information.","code":""},{"path":"https://roche.github.io/crmPack/reference/SimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"","code":".DefaultSimulationsSummary()"},{"path":"https://roche.github.io/crmPack/reference/SimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/reference/SimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"stop_report matrix stopping rule outcomes additional_stats list additional statistical summary fitAtDoseMostSelected fitted toxicity rate dose often selected meanFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level","code":""},{"path":"https://roche.github.io/crmPack/reference/SimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"Typically, end users use .DefaultSimulationsSummary() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/Stopping-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Stopping — Stopping-class","title":"Stopping — Stopping-class","text":"Stopping class stopping rules.","code":""},{"path":"https://roche.github.io/crmPack/reference/Stopping-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Stopping — Stopping-class","text":"report_label (string) label stopping report. meaning parameter twofold. equal NA_character_ (default), report_label used report . Otherwise, specified empty character (.e. character(0)) user constructor, default, class-specific label created slot. Finally, remaining cases, user can provide custom label.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAll — StoppingAll-class","title":"StoppingAll — StoppingAll-class","text":"StoppingAll class testing stopping rule consists many single stopping rules turn objects class Stopping. single stopping rules must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAll — StoppingAll-class","text":"","code":"StoppingAll(stop_list, report_label = NA_character_)  .DefaultStoppingAll()"},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) see slot definition. report_label (string)  see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) list stopping rules. report_label label reporting","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingAll — StoppingAll-class","text":"Typically, end users use .DefaultStoppingAll() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAll-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAll — StoppingAll-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAll`) which would then be # summarized by the `all` function, meaning that the study would be stopped only # if all of the single stopping rules are `TRUE`. my_stopping <- StoppingAll(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAny — StoppingAny-class","title":"StoppingAny — StoppingAny-class","text":"StoppingAny class testing stopping rule consists many single stopping rules turn objects class Stopping. least one single stopping rule must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAny — StoppingAny-class","text":"","code":"StoppingAny(stop_list, report_label = NA_character_)  .DefaultStoppingAny()"},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) see slot definition. report_label (string) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) list stopping rules. report_label label reporting","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingAny — StoppingAny-class","text":"Typically, end users use .DefaultStoppingAny() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingAny-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAny — StoppingAny-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAny`) which would then be # summarized by the `any` function, meaning that the study would be stopped if # any of the single stopping rules is `TRUE`. my_stopping <- StoppingAny(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"StoppingCohortsNearDose class stopping based number cohorts near next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"StoppingCohortsNearDose(   nCohorts = 2L,   percentage = 50,   report_label = NA_character_ )  .DefaultStoppingCohortsNearDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) see slot definition. percentage (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) number required cohorts. percentage (number) percentage (including 0 100) within next best dose cohorts must lie.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"Typically, end users use .DefaultStoppingCohortsNearDose() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"# Here, is the rule for stopping the study if at least 3 cohorts were dosed # at a dose within (1 +/- 0.2) of the next best dose. my_stopping <- StoppingCohortsNearDose(   nCohorts = 3,   percentage = 0.2 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingHighestDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingHighestDose — StoppingHighestDose-class","title":"StoppingHighestDose — StoppingHighestDose-class","text":"StoppingHighestDose class stopping based highest dose. , stopping occurs highest dose reached.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"StoppingHighestDose(report_label = NA_character_)  .DefaultStoppingHighestDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingHighestDose — StoppingHighestDose-class","text":"report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingHighestDose — StoppingHighestDose-class","text":"Typically, end users use .DefaultStoppingHighestDose() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"# The following stopping rule is met when: # - next proposed dose is highest dose, and # - there are already at least 3 patients on that dose, and # - we are sure that this dose is safe, e.g. the probability to be in (0%, 20%) # interval of the DLT rate is above 50%. my_stopping <- StoppingHighestDose() &   StoppingPatientsNearDose(nPatients = 3, percentage = 0) &   StoppingTargetProb(target = c(0, 0.2), prob = 0.5)  # We note that this rule would then need to be combined with the other standard # stopping rules, when the MTD is found based on being near e.g. a 30% DLT # probability or having reached maximal sample size, in the manner of: # stop_rule <- stop_high | stop_low | stop_sample_size # nolintr."},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingList — StoppingList-class","title":"StoppingList — StoppingList-class","text":"StoppingList class testing stopping rule consists many single stopping rules turn objects class Stopping. summary slot stores function takes logical vector size stop_list returns single logical value. example, function specified summary function, stopping rules defined stop_list must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingList — StoppingList-class","text":"","code":"StoppingList(stop_list, summary)  .DefaultStoppingList()"},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingList — StoppingList-class","text":"stop_list (list) see slot definition. summary (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingList — StoppingList-class","text":"stop_list (list) list stopping rules. summary (function) summary function combine results stopping rules single result.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingList — StoppingList-class","text":"Typically, end users use .DefaultStoppingList() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingList-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingList — StoppingList-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingList`) which will then be # summarized (in this specific example) with the `any` function, meaning that # the study would be stopped if any of the single stopping rules is `TRUE`. my_stopping <- StoppingList(   stop_list = c(my_stopping1, my_stopping2, my_stopping3),   summary = any )"},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"StoppingLowestDoseHSRBeta class stopping based Hard Safety Rule using Beta posterior distribution Beta(,b) prior Bin-Beta model based observed data lowest dose level. rule triggered first dose considered toxic (.e. threshold probability) based observed data lowest dose level Beta(,b) prior distribution. default prior Beta(1,1). case placebo used, rule evaluated second dose dose grid, .e. lowest non-placebo dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.95,   a = 1,   b = 1,   report_label = NA_character_ )  .DefaultStoppingLowestDoseHSRBeta()"},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) target toxicity. prob (proportion) threshold probability lowest dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"stopping rule independent underlying model. Typically, end users use .DefaultStoppingLowestDoseHSRBeta() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"# Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(0.5,0.5) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9,   a = 0.5,   b = 0.5 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDCV — StoppingMTDCV-class","title":"StoppingMTDCV — StoppingMTDCV-class","text":"StoppingMTDCV class stopping rule based precision MTD calculated coefficient variation (CV) MTD. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"StoppingMTDCV(target = 0.3, thresh_cv = 40, report_label = NA_character_)  .DefaultStoppingMTDCV()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) see slot definition. thresh_cv (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) toxicity target MTD (except 0 1). thresh_cv (number) threshold (percentage > 0) CV considered accurate enough stop trial. stopping occurs CV less equal tresh_cv.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMTDCV — StoppingMTDCV-class","text":"Typically, end users use .DefaultStoppingMTDCV() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"# Stopping the study if the MTD estimation is precise enough, i.e. if robust # coefficient of variation of the MTD is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)"},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDdistribution — StoppingMTDdistribution-class","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"StoppingMTDdistribution class stopping based posterior distribution MTD. used cases stopping occurs probability MTD > thresh * next_dose greater equal prob, next_dose recommended next best dose. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"StoppingMTDdistribution(   target = 0.33,   thresh = 0.5,   prob = 0.9,   report_label = NA_character_ )  .DefaultStoppingMTDdistribution()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) see slot definition. thresh (proportion) see slot definition. prob (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) target toxicity probability (except 0 1) defining MTD. thresh (proportion) threshold (except 0 1) relative recommended next best dose. prob (proportion) required minimum probability, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"Typically, end users use .DefaultStoppingMTDDistribution() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"# As example, here is the rule for stopping the study if there is at least 0.9 # probability that MTD > 0.5 * next_dose. Here MTD is defined as the dose for # which prob(DLT) = 0.33 my_stopping <- StoppingMTDdistribution(   target = 0.33,   thresh = 0.5,   prob = 0.9 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"StoppingMaxGainCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate : (1) target dose (.e. dose corresponds given target probability occurrence DLT prob_target), (2) max gain dose (.e. dose gives maximum gain), depending one two smaller.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"StoppingMaxGainCIRatio(   target_ratio = 5,   prob_target = 0.3,   report_label = NA_character_ )  .DefaultStoppingMaxGainCIRatio()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) .DefaultStoppingMaxGainCIRatio() #> An object of class \"StoppingMaxGainCIRatio\" #> Slot \"target_ratio\": #> [1] 5 #>  #> Slot \"prob_target\": #> [1] 0.3 #>  #> Slot \"report_label\": #> [1] NA #>"},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinCohorts — StoppingMinCohorts-class","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"StoppingMinCohorts class stopping based minimum number cohorts.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"StoppingMinCohorts(nCohorts = 2L, report_label = NA_character_)  .DefaultStoppingMinCohorts()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) minimum required number cohorts.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"Typically, end users use .DefaultStoppingMinCohorts() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"# As example, here is the rule for stopping the study if at least 6 cohorts # were already dosed. my_stopping <- StoppingMinCohorts(nCohorts = 6)"},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinPatients — StoppingMinPatients-class","title":"StoppingMinPatients — StoppingMinPatients-class","text":"StoppingMinPatients class stopping based minimum number patients","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"StoppingMinPatients(nPatients = 20L, report_label = NA_character_)  .DefaultStoppingMinPatients()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) minimum allowed number patients.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMinPatients — StoppingMinPatients-class","text":"Typically, end users use .DefaultStoppingMinPatients() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"# As example, here is the rule for stopping the study if at least 20 patients # were already dosed my_stopping <- StoppingMinPatients(nPatients = 20)"},{"path":"https://roche.github.io/crmPack/reference/StoppingMissingDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMissingDose — StoppingMissingDose-class","title":"StoppingMissingDose — StoppingMissingDose-class","text":"StoppingMissingDose class stopping based NA returned next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMissingDose — StoppingMissingDose-class","text":"","code":"StoppingMissingDose(report_label = NA_character_)  .DefaultStoppingMissingDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMissingDose — StoppingMissingDose-class","text":"report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMissingDose — StoppingMissingDose-class","text":"Typically, end users use .DefaultStoppingMissingDose() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMissingDose — StoppingMissingDose-class","text":"","code":"# The rule for stopping the study if NA or Placebo is returned as # next best dose. my_stopping <- StoppingMissingDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"StoppingPatientsNearDose class stopping based number patients near next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"StoppingPatientsNearDose(   nPatients = 10L,   percentage = 50,   report_label = NA_character_ )  .DefaultStoppingPatientsNearDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) see slot definition. percentage (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) number required patients. percentage (number) percentage (including 0 100) within next best dose patients must lie.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"Typically, end users use .DefaultStoppingPatientsNearDose() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"# As example, here is the rule for stopping the study if at least 9 patients # were dosed at a dose within (1 +/- 0.2) of the next best dose.  my_stopping <- StoppingPatientsNearDose(   nPatients = 9,   percentage = 20 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingSpecificDose — StoppingSpecificDose-class","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"StoppingSpecificDose class testing stopping rule specific dose dose grid next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80,   report_label = NA_character_ )  .DefaultStoppingSpecificDose()"},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) see slot definition. dose (number) see slot definition. report_label (string NA)  see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) stopping rule available package. dose (positive_number) dose defined part dose grid data.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"Typically, end users use .DefaultStoppingSpecificDose() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"# Stop if highest dose 80 is safe. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 )  # Stop if lowest dose 10 is toxic. lowest_dose_toxic <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0.3, 1), prob = 0.8),   dose = 10 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTDCIRatio — StoppingTDCIRatio-class","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"StoppingTDCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate target dose (.e. dose corresponds given target probability occurrence DLT prob_target).","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"StoppingTDCIRatio(   target_ratio = 5,   prob_target = 0.3,   report_label = NA_character_ )  .DefaultStoppingTDCIRatio()"},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"Typically, end users use .DefaultStoppingTDCIRatio() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingTDCIRatio(   target_ratio = 5,   prob_target = 0.3 )"},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"StoppingTargetBiomarker class stopping based probability target biomarker.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.3,   is_relative = TRUE,   report_label = NA_character_ )  .DefaultStoppingTargetBiomarker()"},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) see slot definition. prob (proportion) see slot definition. is_relative (flag) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) biomarker target range needs reached. example, target = c(0.8, 1.0) is_relative = TRUE means target dose least 80% maximum biomarker level. is_relative (flag) target relative? (default), target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. prob (proportion) required target probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"Typically, end users use .DefaultStoppingTargetBiomarker() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"# Stopping the study if there is at least 0.5 probability that the biomarker # (efficacy) is within the biomarker target range of [0.9, 1.0] (relative to the # maximum for the biomarker).  my_stopping <- StoppingTargetBiomarker(target = c(0.9, 1), prob = 0.5)"},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetProb — StoppingTargetProb-class","title":"StoppingTargetProb — StoppingTargetProb-class","text":"StoppingTargetProb class stopping based probability DLT rate target toxicity interval.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.4,   report_label = NA_character_ )  .DefaultStoppingTargetProb()"},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) see slot definition. prob (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) target toxicity interval, e.g. c(0.2, 0.35). prob (proportion) required target toxicity probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTargetProb — StoppingTargetProb-class","text":"Typically, end users use .DefaultStoppingTargetProb() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"# As example, here is the rule for stopping the study if the posterior # probability that [0.2 =< Prob(DLT | dose) <= 0.35] for the next best dose # is above 0.5. my_stopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)"},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TDDesign — TDDesign-class","title":"TDDesign — TDDesign-class","text":"TDDesign class design based DLT responses using ModelTox class model (.e. LogisticIndepBeta) without MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TDDesign — TDDesign-class","text":"","code":"TDDesign(   model,   stopping,   increments,   pl_cohort_size = CohortSizeConst(0L),   ... )  .DefaultTDDesign()"},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TDDesign — TDDesign-class","text":"model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TDDesign — TDDesign-class","text":"model (ModelTox) pseudo DLT model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TDDesign — TDDesign-class","text":"Typically, end users use .DefaultTDDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TDDesign — TDDesign-class","text":"","code":"empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # The escalation rule. my_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  my_size <- CohortSizeConst(size = 3)  # The increments for the dose-escalation process: #  the maximum increase of 200% for doses up to the maximum dose in grid, #  the maximum increase of 200% for dose above the maximum dose in grid. my_increments <- IncrementsRelative(   intervals = range(empty_data@doseGrid),   increments = c(2, 2) )  # Stop when the maximum sample size of 36 patients is reached. my_stopping <- StoppingMinPatients(nPatients = 36)  # The design with all the above information and starting with a dose of 25. # This design incorporates only DLT responses and no DLT samples are involved # during the simulation. design <- TDDesign(   model = my_model,   stopping = my_stopping,   increments = my_increments,   nextBest = my_next_best,   cohort_size = my_size,   data = empty_data,   startingDose = 25 )"},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TDsamplesDesign — TDsamplesDesign-class","title":"TDsamplesDesign — TDsamplesDesign-class","text":"TDsamplesDesign class design based DLT responses using ModelTox class model (.e. LogisticIndepBeta) well MCMC samples obtained model.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TDsamplesDesign — TDsamplesDesign-class","text":"","code":"TDsamplesDesign(   model,   stopping,   increments,   pl_cohort_size = CohortSizeConst(0L),   ... )  .DefaultTDsamplesDesign()"},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TDsamplesDesign — TDsamplesDesign-class","text":"model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TDsamplesDesign — TDsamplesDesign-class","text":"model (ModelTox) pseudo DLT model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TDsamplesDesign — TDsamplesDesign-class","text":"Typically, end users use .DefaultTDsamplesDesign() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TDsamplesDesign — TDsamplesDesign-class","text":"","code":"empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # The escalation rule. my_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  my_size <- CohortSizeConst(size = 3)  # The increments for the dose-escalation process: #  the maximum increase of 200% for doses up to the maximum dose in grid, #  the maximum increase of 200% for dose above the maximum dose in grid. my_increments <- IncrementsRelative(   intervals = range(empty_data@doseGrid),   increments = c(2, 2) )  # Stop when the maximum sample size of 36 patients is reached. my_stopping <- StoppingMinPatients(nPatients = 36)  # The design with all the above information and starting with a dose of 25. design <- TDsamplesDesign(   model = my_model,   stopping = my_stopping,   increments = my_increments,   nextBest = my_next_best,   cohort_size = my_size,   data = empty_data,   startingDose = 25 )"},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TITELogisticLogNormal — TITELogisticLogNormal-class","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"TITELogisticLogNormal class TITE-CRM based logistic regression model using bivariate normal prior intercept log slope parameters. class inherits LogisticLogNormal.","code":""},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"TITELogisticLogNormal(weight_method = \"linear\", ...)  .DefaultTITELogisticLogNormal()"},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper.","code":""},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"Typically, end users use .DefaultTITELogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"my_model <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"linear\" )  my_model1 <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"adaptive\" )"},{"path":"https://roche.github.io/crmPack/reference/Validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate — Validate","title":"Validate — Validate","text":"Validate class Reference Class help programming validation new S4 classes.","code":""},{"path":"https://roche.github.io/crmPack/reference/Validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate — Validate","text":"Starting empty msg vector, check returning FALSE vector gets new element - string explaining failure validation.","code":""},{"path":"https://roche.github.io/crmPack/reference/Validate.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Validate — Validate","text":"msg (character) cumulative messages.","code":""},{"path":"https://roche.github.io/crmPack/reference/Validate.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Validate — Validate","text":"check(test, string = \"\") Check whether test TRUE; , return NULL. Otherwise, add string message cumulative messages vector msg. result() Return either cumulative messages vector msg (contains error messages checks), NULL, msg empty (.e. checks successful).","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"method combining two atomic stopping rules","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"# S4 method for Stopping,Stopping &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"## Example of combining two atomic stopping rules with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping <- myStopping1 & myStopping2"},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"method combining atomic stopping list","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"# S4 method for Stopping,StoppingAll &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"e1 Stopping object e2 StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"modified StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <-  myStopping3 & (myStopping1 | myStopping2 )"},{"path":"https://roche.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"method combining stopping list atomic","code":""},{"path":"https://roche.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"# S4 method for StoppingAll,Stopping &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"e1 StoppingAll object e2 Stopping object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"modified StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 | myStopping2 ) & myStopping3"},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate posterior with (log) normal distribution — approximate","title":"Approximate posterior with (log) normal distribution — approximate","text":"reproduce resultant approximate model future exactly, include seed = xxxx call approximate.","code":""},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"approximate(object, model, data, ...)  # S4 method for Samples approximate(   object,   model,   data,   points = seq(from = min(data@doseGrid), to = max(data@doseGrid), length = 5L),   refDose = median(points),   logNormal = FALSE,   verbose = TRUE,   create_plot = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate posterior with (log) normal distribution — approximate","text":"object Samples object model GeneralModel object data Data object ... additional arguments (see methods) points optional parameter, gives dose values approximation rely (default: 5 values equally spaced minimum maximum dose grid) refDose reference dose used (default: median points) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used verbose verbose (progress statements)? (default) create_plot add ggplot2 object return value (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate posterior with (log) normal distribution — approximate","text":"list containing approximation model , requested, ggplot2 object containing graphical representation fitted model","code":""},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Approximate posterior with (log) normal distribution — approximate","text":"approximate(Samples): ... argument can transport additional arguments Quantiles2LogisticNormal, e.g. order control approximation quality, etc.","code":""},{"path":"https://roche.github.io/crmPack/reference/approximate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"# nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs!  # Initialize a model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get posterior for all model parameters options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Approximate the posterior distribution with a bivariate normal # max.time and maxit are very small only for the purpose of showing the example. They # should be increased for a real case. set.seed(94) approximation <- approximate(   object = samples,   model = model,   data = data,   logNormal = TRUE,   control = list(     threshold.stop = 0.1,     max.time = 1,     maxit = 1   ) )  posterior <- approximation$model  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/assertions.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional Assertions for checkmate — assertions","title":"Additional Assertions for checkmate — assertions","text":"provide additional assertion functions can used together checkmate functions. described individual help pages linked .","code":""},{"path":"https://roche.github.io/crmPack/reference/assertions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional Assertions for checkmate — assertions","text":"Depending function prefix. assert_ functions return object invisibly successful, otherwise throw error message. check_ functions return TRUE successful, otherwise string error message. test_ functions just return TRUE FALSE.","code":""},{"path":[]},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"biomarker(xLevel, model, samples, ...)  # S4 method for integer,DualEndpoint,Samples biomarker(xLevel, model, samples, ...)"},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"xLevel (integer) levels doses patients given w.r.t dose grid. See Data details. model (DualEndpoint) model. samples (Samples) samples model's parameters store value biomarker levels doses dose grid. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker levels.","code":""},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"function simply returns specific columns (indices equal xLevel) biomarker samples matrix, included samples object.","code":""},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker(xLevel = integer, model = DualEndpoint, samples = Samples):","code":""},{"path":"https://roche.github.io/crmPack/reference/biomarker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"# Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(1L, 2L, 3L, 4L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L),   w = c(     0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6, 0.52, 0.54,     0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 500 ) my_samples <- mcmc(my_data, my_model, my_options)  # Obtain the biomarker levels (samples) for the second dose from the dose grid, # which is 0.5. biomarker(   xLevel = 2L,   model = my_model,   samples = my_samples ) #>   [1] 0.1375535 0.2960029 0.3716799 0.3668818 0.4176325 0.4594279 0.5456154 #>   [8] 0.4003239 0.4713629 0.4527454 0.4460017 0.4101264 0.4538080 0.2838323 #>  [15] 0.3195938 0.3286258 0.2806709 0.3432156 0.3811990 0.4557960 0.3970473 #>  [22] 0.5119133 0.3634919 0.3195076 0.3250728 0.3230108 0.3815743 0.3938252 #>  [29] 0.4086916 0.4035369 0.3565481 0.4372811 0.3801568 0.4168872 0.5612396 #>  [36] 0.5909748 0.4906517 0.6188417 0.6318520 0.5612342 0.4671850 0.4920590 #>  [43] 0.6520309 0.6719456 0.5195073 0.5309092 0.4243711 0.3871548 0.4216539 #>  [50] 0.4476152 0.4746939 0.4769298 0.4677904 0.4731037 0.4433863 0.4357034 #>  [57] 0.4341553 0.4946514 0.4765389 0.4557704 0.4568250 0.4838050 0.4816022 #>  [64] 0.4623248 0.3950520 0.3260572 0.2947823 0.2158613 0.1318275 0.1544125 #>  [71] 0.3514262 0.4339163 0.4340861 0.4181374 0.4244671 0.5649929 0.5967897 #>  [78] 0.5448197 0.5765955 0.5208588 0.5317020 0.4699071 0.4547724 0.4721792 #>  [85] 0.4320075 0.4110007 0.4999707 0.5226583 0.4516077 0.3209885 0.3770245 #>  [92] 0.3536723 0.2886770 0.3559565 0.3103426 0.3463586 0.3265377 0.4584270 #>  [99] 0.4082398 0.3557076 0.3673834 0.4359602 0.4346811 0.4455272 0.4367393 #> [106] 0.4500648 0.3764266 0.3907089 0.3962608 0.4007199 0.4121328 0.3247118 #> [113] 0.2993072 0.2615945 0.3195642 0.3184777 0.3464249 0.3627192 0.4410998 #> [120] 0.3741244 0.3894985 0.4138790 0.4400058 0.3068483 0.4586242 0.3626655 #> [127] 0.4105837 0.4776012 0.5087050 0.5638766 0.4942461 0.4416710 0.3921199 #> [134] 0.3822616 0.3717160 0.3192957 0.3866195 0.3716960 0.4840745 0.5039619 #> [141] 0.6303866 0.6207378 0.6883544 0.6778323 0.5850420 0.5825727 0.6815055 #> [148] 0.5921588 0.5490791 0.5147927 0.5222427 0.6106073 0.5301473 0.4089091 #> [155] 0.4164907 0.4449728 0.4796812 0.4888837 0.6362289 0.5784456 0.4810921 #> [162] 0.4860618 0.5112859 0.4978248 0.6101984 0.5715268 0.5595436 0.5666766 #> [169] 0.5443794 0.3591286 0.3044751 0.3170489 0.4335795 0.4988173 0.4048669 #> [176] 0.3534465 0.4142889 0.4112745 0.4725054 0.4603705 0.4337545 0.4158011 #> [183] 0.3819792 0.2663527 0.3177653 0.3243260 0.3688508 0.3643701 0.4746445 #> [190] 0.4317965 0.4127604 0.4137876 0.4865882 0.5532881 0.6137326 0.5478737 #> [197] 0.5490101 0.5240344 0.4954209 0.3956684 0.4461920 0.3965055 0.4079211 #> [204] 0.3407093 0.2937478 0.2335660 0.2622801 0.2379961 0.3201411 0.4135681 #> [211] 0.3943192 0.4700053 0.4823153 0.5512933 0.5393277 0.4895289 0.4709067 #> [218] 0.3847638 0.3391048 0.2645235 0.3755108 0.4772932 0.4083060 0.4906207 #> [225] 0.4944511 0.4874674 0.5121526 0.6064162 0.5717806 0.4202571 0.2836920 #> [232] 0.4719267 0.4389167 0.3646335 0.4166874 0.4553625 0.5412524 0.4287620 #> [239] 0.4235828 0.4194564 0.4150843 0.3875133 0.3372189 0.3210807 0.3821469 #> [246] 0.3729308 0.4031748 0.4588049 0.5890842 0.5923721 0.5467592 0.4795510 #> [253] 0.3491979 0.4590211 0.5090242 0.4847635 0.5357480 0.5164778 0.4236356 #> [260] 0.3667649 0.4888926 0.4367272 0.4685743 0.4374566 0.3790234 0.3404062 #> [267] 0.3966953 0.3877823 0.3217624 0.3334340 0.4092652 0.3788487 0.1851350 #> [274] 0.3112066 0.4590498 0.4917690 0.4866234 0.5162868 0.4858204 0.4695470 #> [281] 0.3994065 0.3943563 0.3810931 0.4081854 0.4086666 0.4019524 0.4904057 #> [288] 0.4398043 0.4454565 0.4369523 0.4943344 0.5167008 0.4745367 0.3510062 #> [295] 0.3263014 0.3701029 0.3094748 0.3622988 0.3067105 0.3346666 0.3350646 #> [302] 0.3022041 0.2903789 0.3117111 0.3070070 0.2841569 0.3010678 0.2599508 #> [309] 0.3952414 0.3820060 0.3428895 0.4018859 0.3627411 0.3646505 0.4020065 #> [316] 0.4914223 0.3856776 0.4179897 0.3748777 0.3815539 0.3115086 0.1596280 #> [323] 0.3064026 0.3774228 0.4598154 0.4796264 0.4901114 0.5044414 0.6038580 #> [330] 0.5349068 0.6040347 0.5338166 0.5294479 0.4921355 0.6404614 0.4206995 #> [337] 0.5348608 0.5199775 0.3495225 0.2917689 0.3832771 0.4619325 0.4658926 #> [344] 0.4046444 0.4467490 0.4138678 0.3892592 0.4136318 0.2807762 0.3722180 #> [351] 0.4229459 0.4959588 0.3579381 0.4607694 0.4079496 0.4527712 0.5736441 #> [358] 0.4877423 0.3840744 0.3479311 0.4121746 0.4097833 0.3574874 0.3326550 #> [365] 0.3269974 0.3898486 0.3825431 0.3570393 0.3000988 0.3394751 0.3723486 #> [372] 0.3771678 0.3697407 0.3345718 0.3614137 0.4566486 0.4129624 0.4484703 #> [379] 0.4808410 0.4366628 0.4151486 0.4134942 0.3517382 0.5066622 0.4400097 #> [386] 0.4218926 0.3805296 0.4463861 0.3362453 0.3242138 0.3990188 0.2843048 #> [393] 0.2951566 0.3572925 0.3654378 0.4077738 0.5215422 0.4731354 0.4617522 #> [400] 0.3634826 0.4195077 0.4530366 0.4064412 0.4843804 0.4487421 0.4622702 #> [407] 0.4099088 0.4013895 0.3493175 0.4264058 0.4604544 0.5063362 0.4791954 #> [414] 0.4318016 0.3666500 0.4101524 0.4725245 0.3813358 0.3656476 0.4474029 #> [421] 0.4033477 0.4749895 0.4576861 0.5243637 0.5771567 0.5074814 0.4698489 #> [428] 0.3821703 0.4436523 0.3773382 0.3432678 0.3553005 0.3980092 0.4343439 #> [435] 0.3761966 0.4334063 0.3154136 0.3519206 0.3791309 0.4667952 0.5548900 #> [442] 0.5012021 0.4464334 0.3914519 0.2937428 0.3025583 0.3294322 0.4033609 #> [449] 0.3976014 0.4860241 0.4725849 0.3892833 0.5137581 0.5209700 0.5000009 #> [456] 0.3832384 0.4087048 0.4864331 0.4953257 0.3746557 0.5174616 0.5889677 #> [463] 0.5986998 0.6061744 0.5824634 0.6184460 0.5813745 0.5222101 0.6041778 #> [470] 0.4951665 0.3753035 0.3383527 0.5352204 0.4134474 0.4518687 0.4445346 #> [477] 0.4027504 0.5051896 0.4657873 0.3365441 0.1970343 0.3243106 0.3636618 #> [484] 0.3485050 0.3386768 0.4247709 0.3336909 0.2385745 0.4049301 0.3914029 #> [491] 0.3904647 0.3770955 0.3980346 0.3993835 0.4551752 0.5302344 0.7233277 #> [498] 0.5475544 0.4564193 0.2083399"},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if All Arguments Are Equal — check_equal","title":"Check if All Arguments Are Equal — check_equal","text":"Elements ... must numeric vectors scalars. function performs element--element comparison first object provided ... every object ... returns TRUE comparisons equal within given tolerance FALSE otherwise. Elements ... must numeric vectors scalars. function performs element--element comparison first object provided ... every object ... throws error .","code":""},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if All Arguments Are Equal — check_equal","text":"","code":"check_equal(..., tol = sqrt(.Machine$double.eps))  assert_equal(   ...,   tol = sqrt(.Machine$double.eps),   .var.name = vname(x),   add = NULL )"},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if All Arguments Are Equal — check_equal","text":"... (numeric) vectors compared tol (numeric) maximum difference tolerated judging equality .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if All Arguments Are Equal — check_equal","text":"TRUE element--element differences less tolerance magnitude, FALSE otherwise. list(...), invisibly.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if All Arguments Are Equal — check_equal","text":"missing infinite values ..., function returns FALSE, regardless values elements .... elements ... length, FALSE returned. missing infinite values ..., function throws error, regardless values elements .... elements ... length, error thrown.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if All Arguments Are Equal — check_equal","text":"","code":"check_equal(1:2, 1:2) # TRUE #> [1] TRUE check_equal(1:2, 2:3) # \"Not all equal\" #> [1] \"Not all equal\" check_equal(Inf, Inf) # \"Not all equal\" #> [1] \"Not all entries finite\" check_equal(0.01, 0.02) # \"Not all equal\" #> [1] \"Not all equal\" check_equal(0.01, 0.02, tol = 0.05) # TRUE #> [1] TRUE check_equal(1, c(1, 1)) # \"Not all equal\" #> [1] \"Not all of same length\" assert_equal(1:2, 1:2) # no error assert_equal(0.01, 0.02, tol = 0.05) # no error"},{"path":"https://roche.github.io/crmPack/reference/check_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if vectors are of compatible lengths — check_length","title":"Check if vectors are of compatible lengths — check_length","text":"Two vectors compatible size : least one vector size 1 vectors size.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(x, len)  assert_length(x, len, .var.name = checkmate::vname(x), add = NULL)  test_length(x, len)"},{"path":"https://roche.github.io/crmPack/reference/check_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if vectors are of compatible lengths — check_length","text":"x () first vector, object length() function defined. len (count) length second vector. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if vectors are of compatible lengths — check_length","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(1:5, 1) #> [1] TRUE check_length(1:5, 6) #> [1] \"x is of length 5 which is not allowed; the allowed lengths are: 1 or 6\" check_length(1:5, 5) #> [1] TRUE check_length(10, 1) #> [1] TRUE check_length(10, 9) #> [1] TRUE"},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability vector — check_probabilities","title":"Check if an argument is a probability vector — check_probabilities","text":"Check every element given numerical vector matrix represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"check_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  assert_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   .var.name = checkmate::vname(x),   add = NULL )  test_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  expect_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability vector — check_probabilities","text":"x (numeric) vector matrix numerical values check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . len [integer(1)] Exact expected length x. unique [logical(1)] Must values unique? Default FALSE. sorted [logical(1)] Elements must sorted ascending order. Missing values ignored. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability vector — check_probabilities","text":"TRUE successful, otherwise string error message.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if an argument is a probability vector — check_probabilities","text":"missing non-finite values x, function returns FALSE, regardless values elements x.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_probabilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"x <- c(0, 0.2, 0.1, 0.3, 1) check_probabilities(x) #> [1] TRUE check_probabilities(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probabilities(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/reference/check_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a single probability value — check_probability","title":"Check if an argument is a single probability value — check_probability","text":"Check given value represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(x, bounds_closed = TRUE)  assert_probability(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability(x, bounds_closed = TRUE)  expect_probability(x, bounds_closed = TRUE, info = NULL, label = vname(x))"},{"path":"https://roche.github.io/crmPack/reference/check_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a single probability value — check_probability","text":"x (number) single value check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a single probability value — check_probability","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_probability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(0.5) #> [1] TRUE check_probability(0, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability(0, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/reference/check_probability_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability range — check_probability_range","title":"Check if an argument is a probability range — check_probability_range","text":"Check given numerical interval represents probability range, sub-interval (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probability_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"check_probability_range(x, bounds_closed = TRUE)  assert_probability_range(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability_range(x, bounds_closed = TRUE)  expect_probability_range(   x,   bounds_closed = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/reference/check_probability_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability range — check_probability_range","text":"x (number) interval check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_probability_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability range — check_probability_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_probability_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"x <- c(0, 0.2) check_probability_range(x) #> [1] TRUE check_probability_range(rev(x)) #> [1] \"Must be sorted\" check_probability_range(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability_range(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/reference/check_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a numerical range — check_range","title":"Check that an argument is a numerical range — check_range","text":"argument x numerical range (conditions must met): object type: integer double. vector length two value first number less second number. Equalness allowed unique flag set TRUE. Lower bound interval greater equal lower upper bound interval less equal upper. contains finite (given finite TRUE) non-missing values.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  assert_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  expect_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/reference/check_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a numerical range — check_range","text":"x [] Object check. lower [numeric(1)] Lower value elements x must greater equal . upper [numeric(1)] Upper value elements x must lower equal . finite [logical(1)] Check finite values? Default FALSE. unique [logical(1)] Must values unique? Default FALSE. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/reference/check_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a numerical range — check_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/check_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(c(1, 5)) #> [1] TRUE check_range(c(-5, 1)) #> [1] TRUE check_range(c(4, 1)) #> [1] \"x must be a valid numerical range. Must be sorted\" check_range(c(1, 1)) #> [1] \"x must be a valid numerical range. Contains duplicated values, position 2\" check_range(c(1, 1), unique = FALSE) #> [1] TRUE check_range(1:3) #> [1] \"x must be a valid numerical range. Must have length 2, but has length 3\""},{"path":"https://roche.github.io/crmPack/reference/crmPack-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-oriented implementation of CRM designs — crmPack-package","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Object-oriented implementation CRM designs","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPack-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Sabanes Bove D, Yeung WY, Palermo G, Jaki T (2019). \"Model-Based Dose Escalation Designs R crmPack.\" Journal Statistical Software, 89(10), 1-22. doi:10.18637/jss.v089.i10 (URL: http://doi.org/10.18637/jss.v089.i10).","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPack-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Daniel Sabanes Bove daniel.sabanesbove@gmx.net, W Wai Yin Yeung winnie.yeung@roche.com Giuseppe Palermo giuseppe.palermo@roche.com, Thomas Jaki jaki.thomas@gmail.com","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackExample.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the example pdf for crmPack — crmPackExample","title":"Open the example pdf for crmPack — crmPackExample","text":"Calling helper function open example.pdf document, residing doc subfolder package installation directory.","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackExample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the example pdf for crmPack — crmPackExample","text":"","code":"crmPackExample()"},{"path":"https://roche.github.io/crmPack/reference/crmPackExample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the example pdf for crmPack — crmPackExample","text":"nothing","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackExample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the example pdf for crmPack — crmPackExample","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackHelp.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the browser with help pages for crmPack — crmPackHelp","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"convenience function opens browser help pages crmPack.","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackHelp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"","code":"crmPackHelp()"},{"path":"https://roche.github.io/crmPack/reference/crmPackHelp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"nothing","code":""},{"path":"https://roche.github.io/crmPack/reference/crmPackHelp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/reference/dapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function to Subsets of Data Frame. — dapply","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"dapply splits data df subsets defined f, applies function FUN subset. results row-binded returned data.frame object.","code":""},{"path":"https://roche.github.io/crmPack/reference/dapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"dapply(df, f, FUN, ...)"},{"path":"https://roche.github.io/crmPack/reference/dapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"df (data frame) data set divided groups. f (factor formula list) factor sense .factor(f) defines grouping, list factors case interaction used grouping. f can also formula form ~ g1 + ... + gk split interaction variables g1, ..., gk. parameter passed directly split() function. FUN (function) function applied subset df defined f. ... parameters passed lapply(), used applying function FUN groups defined f.","code":""},{"path":"https://roche.github.io/crmPack/reference/dapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"data.frame object results FUN.","code":""},{"path":"https://roche.github.io/crmPack/reference/dapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"df <- data.frame(   dose = c(0.1, 6, 6, 5, 0.1, 5, 6, 6),   cohort = c(\"B\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\") )  dapply(   df,   f = ~cohort,   FUN = function(coh) {     data.frame(my_cohort = coh$cohort[1], my_max = max(coh$dose))   } ) #>   my_cohort my_max #> 1         A      5 #> 2         B      6  dapply(   df,   f = ~cohort,   FUN = function(coh) {     coh$dose <- sort(coh$dose, decreasing = TRUE)     coh   } ) #>   dose cohort #> 1  5.0      A #> 2  5.0      A #> 3  0.1      A #> 4  6.0      B #> 5  6.0      B #> 6  6.0      B #> 7  6.0      B #> 8  0.1      B"},{"path":"https://roche.github.io/crmPack/reference/dinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the density of Inverse gamma distribution — dinvGamma","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"Compute density Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/reference/dinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"","code":"dinvGamma(x, a, b, log = FALSE, normalize = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/dinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"x vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution log logical; TRUE, probabilities p given log(p) normalize logical; TRUE, output normalized","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing the Doses for a given independent variable, Model and Samples — dose","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"function computes dose reaching specific target value given variable dose depends . meaning variable depends type model. instance, single agent dose escalation model pseudo DLE (dose-limiting events)/toxicity model, variable represents probability occurrence DLE. efficacy models, represents expected efficacy. doses computed based samples model parameters (samples).","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"dose(x, model, samples, ...)  # S4 method for numeric,LogisticNormal,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormal,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormalSub,Samples dose(x, model, samples)  # S4 method for numeric,ProbitLogNormal,Samples dose(x, model, samples)  # S4 method for numeric,ProbitLogNormalRel,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormalGrouped,Samples dose(x, model, samples, group)  # S4 method for numeric,LogisticKadane,Samples dose(x, model, samples)  # S4 method for numeric,LogisticKadaneBetaGamma,Samples dose(x, model, samples)  # S4 method for numeric,LogisticNormalMixture,Samples dose(x, model, samples)  # S4 method for numeric,LogisticNormalFixedMixture,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormalMixture,Samples dose(x, model, samples)  # S4 method for numeric,DualEndpoint,Samples dose(x, model, samples)  # S4 method for numeric,LogisticIndepBeta,Samples dose(x, model, samples)  # S4 method for numeric,LogisticIndepBeta,missing dose(x, model)  # S4 method for numeric,Effloglog,missing dose(x, model)  # S4 method for numeric,EffFlexi,Samples dose(x, model, samples)  # S4 method for numeric,OneParLogNormalPrior,Samples dose(x, model, samples)  # S4 method for numeric,OneParExpPrior,Samples dose(x, model, samples)"},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"x (proportion numeric) value independent variable dose depends. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, x must size sample. model (GeneralModel ModelPseudo) model. samples (Samples) samples model's parameters used compute resulting doses. Can also missing models. ... model specific parameters samples used. group (character factor) LogisticLogNormalGrouped, indicating whether calculate dose mono combo arm.","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"number numeric vector doses. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length prob.","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() function computes doses corresponding value given independent variable, using samples model parameter(s). work multivariate model parameters, assume model specific dose() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose(x = numeric, model = LogisticNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalSub, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormalRel, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalGrouped, samples = Samples): method LogisticLogNormalGrouped needs group argument addition. dose(x = numeric, model = LogisticKadane, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticKadaneBetaGamma, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalFixedMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = DualEndpoint, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = Effloglog, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = EffFlexi, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). method x must scalar. dose(x = numeric, model = OneParLogNormalPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x). dose(x = numeric, model = OneParExpPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x).","code":""},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() prob() methods inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/dose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = my_model, samples = my_samples) #>  [1]  60.70536  60.70536  35.57130  35.57130  35.57130  35.57130  35.57130 #>  [8]  35.57130 108.42931 108.42931 108.42931  92.73341  92.73341  17.97250 #> [15]  17.97250  17.97250  87.21243  87.21243  87.21243  87.21243  # Create data from the 'Data' (or 'DataDual') class. dlt_data <- Data(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = dlt_data )  # Get samples from posterior. dlt_sample <- mcmc(data = dlt_data, model = dlt_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = dlt_model, samples = dlt_sample) #>  [1]     10.07613     10.07613     22.15191 850756.88704     48.50700 #>  [6]     48.50700     48.50700     72.06078     72.06078     72.06078 #> [11]   2590.71936    155.17055    155.17055    155.17055    212.47066 #> [16]    156.91934    234.83714    234.83714    196.82793     90.86247 dose(x = c(0.45, 0.6), model = dlt_model) #> [1] 144.6624 247.7348"},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Function for a Given Model Type — doseFunction","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"function returns dose() method computes dose reaching specific target value given independent variable, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"doseFunction(model, ...)  # S4 method for GeneralModel doseFunction(model, ...)  # S4 method for ModelPseudo doseFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"model (GeneralModel ModelPseudo) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"dose() method computes doses.","code":""},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"doseFunction(GeneralModel): doseFunction(ModelPseudo):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/doseFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  dose_fun <- doseFunction(my_model, alpha0 = 2, alpha1 = 3) dose_fun(0.6) #> [1] 29.38579"},{"path":"https://roche.github.io/crmPack/reference/dose_grid_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Grid Range — dose_grid_range","title":"Getting the Dose Grid Range — dose_grid_range","text":"function returns vector length two minimum maximum dose grid. returns c(-Inf, Inf) range determined, happens dose grid empty. User can choose whether placebo dose () counted .","code":""},{"path":"https://roche.github.io/crmPack/reference/dose_grid_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Grid Range — dose_grid_range","text":"","code":"dose_grid_range(object, ...)  # S4 method for Data dose_grid_range(object, ignore_placebo = TRUE)  # S4 method for DataOrdinal dose_grid_range(object, ignore_placebo = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/dose_grid_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Grid Range — dose_grid_range","text":"object (Data) object dose grid. ... arguments passed class-specific methods. ignore_placebo (flag) placebo dose () counted?","code":""},{"path":"https://roche.github.io/crmPack/reference/dose_grid_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Grid Range — dose_grid_range","text":"numeric vector containing minimum maximum doses grid c(-Inf, Inf).","code":""},{"path":"https://roche.github.io/crmPack/reference/dose_grid_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Dose Grid Range — dose_grid_range","text":"","code":"my_data <- Data(   x = c(10, 50, 90, 100, 0.001, 20, 30, 30),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(1L, 2L, 3L, 4L, 5L, 5L, 6L, 6L),   doseGrid = c(0.001, seq(from = 10, to = 100, by = 10)),   placebo = TRUE ) dose_grid_range(my_data) #> [1]  10 100 dose_grid_range(my_data, ignore_placebo = FALSE) #> [1] 1e-03 1e+02 data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  dose_grid_range(data) #> [1]  10 100"},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"function computes value expected efficacy specified dose level, based model specific parameters. model parameters (samples) obtained based prior specified form pseudo data combined observed responses ().","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"efficacy(dose, model, samples, ...)  # S4 method for numeric,Effloglog,Samples efficacy(dose, model, samples)  # S4 method for numeric,Effloglog,missing efficacy(dose, model)  # S4 method for numeric,EffFlexi,Samples efficacy(dose, model, samples)"},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"dose (numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (ModelEff) efficacy model pseudo data prior. samples (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... model specific parameters samples used.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"numeric vector values expected efficacy. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy() function computes expected efficacy given doses, using samples model parameter(s). work multivariate model parameters, assume model specific efficacy() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy(dose = numeric, model = Effloglog, samples = Samples): compute expected efficacy specified dose level, based samples Effloglog model parameters. efficacy(dose = numeric, model = Effloglog, samples = missing): compute expected efficacy specified dose level, based Effloglog model parameters. model parameters (except dose) present model object. efficacy(dose = numeric, model = EffFlexi, samples = Samples): compute expected efficacy specified dose level, based samples EffFlexi model parameters. given dose dose vector outside dose grid range, NA_real returned dose warning thrown.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/efficacy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"# Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (in flexible form for prior) and efficacy samples.  # Empty data (i.e. no observed data), dose grid only. my_data <- DataDual(doseGrid = seq(25, 300, 25))  my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_options <- McmcOptions(   burnin = 100, step = 2, samples = 200, rng_kind = \"Mersenne-Twister\", rng_seed = 94 )  my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Efficacy for dose 75. efficacy(dose = 75, model = my_model, samples = my_samples) #>   [1]   9.07133091   1.53424048  11.07308839   6.74968857  -2.87681905 #>   [6]  -0.52774208   0.98461243   8.07698912  -2.44894407  -5.85523700 #>  [11]  11.31738072  -5.20839309  -3.53568739   1.84098767   2.63215398 #>  [16]   1.08547205  -1.14150225  -1.17196071  -4.07450990   3.83602092 #>  [21]  -1.51766461   9.58344159  12.66103757  -4.07515232   4.55952976 #>  [26]   3.07600733  -0.45143577  12.68867587  -0.79739141  -6.60007580 #>  [31]   6.08270229  -5.09099874   1.30242100  -1.38790974   2.11417328 #>  [36]   8.37133821   1.50986899   6.84880575   5.43897499   2.79542447 #>  [41]  11.45417302   2.06748782   1.35245992  -1.23701296   7.91038987 #>  [46]   6.51728419  -5.90538823   0.50485996   4.46024145  -6.19234053 #>  [51]  -1.03422769  -4.60878828  -7.09786728   6.77762041  -7.80093619 #>  [56]  -0.35335674   0.06016899   5.09042210  -1.08931226  -5.13714299 #>  [61] -11.25227813   6.94417969  -0.18607453   6.70974746   7.07740656 #>  [66]   1.81144127  -1.46201083  -3.59961582   5.98766120  -3.06347907 #>  [71]   1.48952524  -3.87648489   9.53195596  -5.09183042   2.55946664 #>  [76]   5.36514495   3.35805663   4.04528900  -2.47968051   2.38776563 #>  [81]   3.30544598   6.08668755   8.10409159  -2.86897901  -2.56968895 #>  [86]  -2.71078157   6.57400099  -0.64078913  -0.77931969   0.44535965 #>  [91]   2.48733763   1.62006538   5.18380783  15.91917003  14.37031355 #>  [96]  -4.95225083  -0.11454594   3.37173952   4.36757735   9.93988922 #> [101]   0.14708030   0.66970048   2.93648731   6.62081659  -5.72655553 #> [106]   7.32219826   3.85369534  -5.64247557   3.26712563   1.53773741 #> [111]   5.36646375  -2.24826433   1.53796441  -1.47481547   5.66412948 #> [116]  -0.08562487   0.92285513   6.54480180   2.76592451   9.04534245 #> [121]   2.67298217   9.37451070   3.31718865  -4.39655806  -2.77475285 #> [126]   0.73845209  -1.14838485  -0.04538310  13.15372079  -8.24336360 #> [131]   1.00955294   3.84117706   7.63816224   7.15423998  -0.31603848 #> [136]  -5.15339494   4.46319473   0.61902688   1.75161458  -3.48460935 #> [141]   1.03111557   7.35215316  14.50755214   0.45564792  -0.33913496 #> [146]  -1.04517173   8.55653204  -0.33228919   7.57900504   5.90623049 #> [151]   0.95421800   9.08101740   9.43334290  -7.55120809  -2.72471203 #> [156]  -7.35230299   3.70368743   3.84477094   4.16388471  -1.68082994 #> [161]  -1.92123896   2.04731124  -2.26118158   1.72862392  -1.79117652 #> [166]   3.04772415   1.34065202   6.35926350  -1.78732266  -3.18937218 #> [171]  -5.18426934   6.64292813   0.21495831  -5.04417938  -3.64536665 #> [176]   6.97433099   4.69569241  10.84773802  10.07835651   7.98940931 #> [181]  -1.64566370  -6.87224825  -4.75312374  -1.98193506  11.94430550 #> [186]   7.12994070  11.82172904   5.74335173   4.51767170   1.09675636 #> [191]   5.90817166  -1.89174876  -0.15421814   2.06690552   1.63930492 #> [196]   3.77873641   2.64667197   9.84146185   2.29768549  -0.54599122  # Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (linear log-log efficacy) and no samples. my_model_ll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 0 )  efficacy(dose = 75, model = my_model_ll) #> [1] 1.885121"},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"function returns efficacy() function computes expected efficacy given dose level, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"efficacyFunction(model, ...)  # S4 method for ModelEff efficacyFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"model (ModelEff) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacy() function computes expected efficacy.","code":""},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacyFunction(ModelEff):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/efficacyFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"my_data <- DataDual(   doseGrid = c(0.001, seq(25, 300, 25)),   placebo = TRUE )  my_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 2 )  eff_fun <- efficacyFunction(my_model, theta1 = -4.8, theta2 = 3.7) eff_fun(30) #> [1] -0.2011775"},{"path":"https://roche.github.io/crmPack/reference/enable_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Verbose Logging — enable_logging","title":"Verbose Logging — enable_logging","text":"family wrappers selected futile.logger functions control logging mechanism crmPack. crmPack uses futile.logger package logging purposes. messages logged crmPack logged crmPack logger futile.logger::TRACE level. Hence, enabling verbose logging means logging threshold set futile.logger::TRACE crmPack logger, disabling verbose logging means set futile.logger::FATAL.","code":""},{"path":"https://roche.github.io/crmPack/reference/enable_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verbose Logging — enable_logging","text":"","code":"enable_logging()  disable_logging()  is_logging_enabled()  log_trace(msg, ..., capture = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/enable_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verbose Logging — enable_logging","text":"msg message log ... Optional arguments populate format string capture Capture print output variables instead interpolate","code":""},{"path":"https://roche.github.io/crmPack/reference/enable_logging.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verbose Logging — enable_logging","text":"enable_logging(): simple wrapper futile.logger::flog.threshold() enables crmPack verbose logging setting logging threshold futile.logger::TRACE crmPack logger. disable_logging(): simple wrapper futile.logger::flog.threshold() disables crmPack verbose logging setting logging threshold futile.logger::FATAL crmPack logger. is_logging_enabled(): simple wrapper futile.logger::flog.logger() checks whether current threshold level crmPack logger verbose, futile.logger::TRACE. returns TRUE current logging level verbose, FALSE otherwise. log_trace(): simple wrapper futile.logger::flog.trace() prints log message crmPack logger.","code":""},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain hypothetical trial course table for a design — examine","title":"Obtain hypothetical trial course table for a design — examine","text":"generic function takes design generates dataframe showing beginning several hypothetical trial courses design. means, generated dataframe one can read : many cohorts required optimal case (DLTs observed) order reach highest dose specified dose grid (stopping rule fulfilled) assuming DLTs observed certain dose level, next recommended dose possible number DLTs observed actual relative increments used cases whether trial stop certain cohort Examining \"single trial\" behavior dose escalation design first important step evaluating design, replaced studying solely operating characteristics \"many trials\". cohort sizes also taken design, assuming DLTs occur dose listed.","code":""},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"examine(object, ..., maxNoIncrement = 100L)  # S4 method for Design examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)  # S4 method for RuleDesign examine(object, ..., maxNoIncrement = 100L)  # S4 method for DADesign examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)"},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain hypothetical trial course table for a design — examine","text":"object design (Design RuleDesign object) want examine ... additional arguments (see methods) maxNoIncrement maximum number contiguous next doses 0 DLTs , .e. increment (default 100) mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used","code":""},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain hypothetical trial course table for a design — examine","text":"data frame","code":""},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtain hypothetical trial course table for a design — examine","text":"examine(Design): Examine model-based CRM examine(RuleDesign): Examine rule-based design examine(DADesign): Examine model-based CRM","code":""},{"path":"https://roche.github.io/crmPack/reference/examine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"# Define the dose-grid. emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25))   # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )   my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  my_options <- McmcOptions(   burnin = 10, step = 1, samples = 20, rng_kind = \"Super-Duper\",   rng_seed = 94 )  examine(my_design, my_options) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20 FALSE       100 #> 6   10    1        5 FALSE       -50 #> 7   20    0       25 FALSE        25 #> 8   20    1       20 FALSE         0  # Example where examine stops because stopping rule already fulfilled. my_stopping4 <- StoppingMinPatients(nPatients = 3) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping4  my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  examine(my_design, mcmcOptions = my_options) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20  TRUE       100 #> 6   10    1        5  TRUE       -50  # Example where examine stops because infinite looping # (note that here a very low threshold is used for the parameter # \"maxNoIncrement\" in \"examine\" to keep the execution time short). my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.00001) )  my_stopping <- (my_stopping1 & my_stopping2) | StoppingMissingDose()  design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  examine(my_design, mcmcOptions = my_options, maxNoIncrement = 2) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20  TRUE       100 #> 6   10    1        5  TRUE       -50 # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = emptydata,   startingDose = 5 )  # Examine the design set.seed(4235) examine(myDesign) #>    dose DLTs nextDose  stop increment #> 1     5    0       10 FALSE       100 #> 2     5    1        5 FALSE         0 #> 3     5    2       NA  TRUE        NA #> 4     5    3       NA  TRUE        NA #> 5    10    0       15 FALSE        50 #> 6    10    1       10 FALSE         0 #> 7    10    2        5 FALSE       -50 #> 8    10    3        5 FALSE       -50 #> 9    15    0       25 FALSE        67 #> 10   15    1       15 FALSE         0 #> 11   15    2       10 FALSE       -33 #> 12   15    3       10 FALSE       -33 #> 13   25    0       35 FALSE        40 #> 14   25    1       25 FALSE         0 #> 15   25    2       15 FALSE       -40 #> 16   25    3       15 FALSE       -40 #> 17   35    0       50 FALSE        43 #> 18   35    1       35 FALSE         0 #> 19   35    2       25 FALSE       -29 #> 20   35    3       25 FALSE       -29 #> 21   50    0       80 FALSE        60 #> 22   50    1       50 FALSE         0 #> 23   50    2       35 FALSE       -30 #> 24   50    3       35 FALSE       -30 # nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(doseGrid = c(   0.1, 0.5, 1, 1.5, 3, 6,   seq(from = 10, to = 80, by = 2) ), Tmax = 60) # Initialize the mDA-CRM model npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 ) # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping2 <- StoppingMinPatients(nPatients = 50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  # Initialize the design design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )  set.seed(4235) # MCMC parameters are set to small values only to show this example. They should be # increased for a real case. # This procedure will take a while. options <- McmcOptions(   burnin = 10,   step = 1,   samples = 100,   rng_kind = \"Mersenne-Twister\",   rng_seed = 12 ) testthat::expect_warning(   result <- examine(design, mcmcOptions = options, maxNoIncrement = 2),   \"Stopping because 2 times no increment\" )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit method for the Samples class — fit","title":"Fit method for the Samples class — fit","text":"Note new generic function necessary fitted function allows first argument object appear signature. need also arguments signature.","code":""},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit method for the Samples class — fit","text":"","code":"fit(object, model, data, ...)  # S4 method for Samples,GeneralModel,Data fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,DualEndpoint,DataDual fit(object, model, data, quantiles = c(0.025, 0.975), middle = mean, ...)  # S4 method for Samples,LogisticIndepBeta,Data fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,Effloglog,DataDual fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,EffFlexi,DataDual fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit method for the Samples class — fit","text":"object Samples object model GeneralModel object data Data object ... passed prob() method. points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit method for the Samples class — fit","text":"data frame required information (see method details)","code":""},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit method for the Samples class — fit","text":"fit(object = Samples, model = GeneralModel, data = Data): method returns data frame dose, middle, lower upper quantiles dose-toxicity curve fit(object = Samples, model = DualEndpoint, data = DataDual): method returns data frame dose, middle, lower upper quantiles, dose-tox dose-biomarker (suffix \"Biomarker\") curves, grid points (Note currently grid points can used, DualEndpointRW models allow ) fit(object = Samples, model = LogisticIndepBeta, data = Data): method return data frame dose, middle lower upper quantiles dose-DLE curve using DLE samples “LogisticIndepBeta” model class fit(object = Samples, model = Effloglog, data = DataDual): method returns data frame dose, middle, lower, upper quantiles dose-efficacy curve using efficacy samples “Effloglog” model class fit(object = Samples, model = EffFlexi, data = DataDual): method returns data frame dose, middle, lower upper quantiles dose-efficacy curve using efficacy samples “EffFlexi” model class","code":""},{"path":"https://roche.github.io/crmPack/reference/fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit method for the Samples class — fit","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses fitted <- fit(object = samples,               model = model,               data = data,               quantiles=c(0.025, 0.975),               middle=mean)   # ---------------------------------------------- # A different example using a different model ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!   model <- LogisticIndepBeta(binDLE=c(1.05,1.8),                            DLEweights=c(3,3),                            DLEdose=c(25,300),                            data=data) options <- McmcOptions(burnin=100,                        step=2,                        samples=200) ## samples must be from 'Samples' class (object slot in fit) samples <- mcmc(data,model,options)  fitted <- fit(object=samples, model=model, data=data)  # nolint end # nolint start  # Create some data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses fitted <- fit(object = samples,               model = model,               data = data,               quantiles=c(0.025, 0.975),               middle=mean)  # nolint end ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-DLE curve ## at all dose levels using a DLE sample, a DLE model and the data ## samples must be from 'Samples' class (object slot) ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'Model' or 'ModelTox' class e.g using 'LogisticIbdepBeta' model class model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ## samples must be from 'Samples' class (object slot in fit) samples<-mcmc(data,model,options)  fit(object=samples, model=model,data=data) #>    dose    middle      lower     upper #> 1    25 0.2362155 0.08981218 0.4190492 #> 2    50 0.3682220 0.20111117 0.5781557 #> 3    75 0.4575540 0.27620943 0.6661194 #> 4   100 0.5223768 0.33161940 0.7239995 #> 5   125 0.5717475 0.37825701 0.7709958 #> 6   150 0.6107229 0.40917199 0.8141918 #> 7   175 0.6423542 0.42871110 0.8437866 #> 8   200 0.6685943 0.44575657 0.8651832 #> 9   225 0.6907535 0.46059389 0.8819519 #> 10  250 0.7097445 0.47392655 0.8953912 #> 11  275 0.7262234 0.48877922 0.9063659 #> 12  300 0.7406746 0.51041966 0.9148683 ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, a pseudo efficacy model and the data ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel<-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0) ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) Effsamples <- mcmc(data=data,model=Effmodel,options=options) fit(object=Effsamples, model=Effmodel,data=data) #>    dose   middle      lower    upper #> 1    25 0.465844 -0.1165332 1.007491 #> 2    50 0.822886  0.3886473 1.180275 #> 3    75 1.003435  0.5768330 1.403713 #> 4   100 1.121531  0.6228397 1.630016 #> 5   125 1.208159  0.6601782 1.787815 #> 6   150 1.276017  0.6894266 1.902756 #> 7   175 1.331491  0.7064292 2.018253 #> 8   200 1.378223  0.6925712 2.105017 #> 9   225 1.418476  0.6806345 2.173231 #> 10  250 1.453748  0.6701746 2.233005 #> 11  275 1.485081  0.6687583 2.286102 #> 12  300 1.513225  0.6801521 2.333796 # nolint start  ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, the 'EffFlexi' efficacy model and the data ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)  ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) Effsamples <- mcmc(data=data,model=Effmodel,options=options) fit(object=Effsamples, model=Effmodel,data=data) #>    dose    middle      lower     upper #> 1    25 0.7036011  0.6866660 0.7158120 #> 2    50 0.4494999  0.4100730 0.5051847 #> 3    75 0.5795760  0.5125865 0.6297975 #> 4   100 0.6321164 -1.3094061 2.4041159 #> 5   125 0.5879013 -1.3602565 2.2919075 #> 6   150 0.5246635  0.5162698 0.5419775 #> 7   175 0.6355070 -1.7183340 3.1674019 #> 8   200 0.8103666 -3.1066777 5.2791132 #> 9   225 1.0235281 -4.1707667 5.8087216 #> 10  250 1.4342934 -4.1558082 6.0408674 #> 11  275 1.9401852 -1.9698781 5.1282467 #> 12  300 2.5119573  2.5075891 2.5129950  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/fitGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"Get fitted values gain values dose levels based given pseudo DLE model, DLE sample, pseudo efficacy model, Efficacy sample data. method returns data frame dose, middle, lower upper quantiles gain value samples","code":""},{"path":"https://roche.github.io/crmPack/reference/fitGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"","code":"fitGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples,DataDual fitGain(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://roche.github.io/crmPack/reference/fitGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"DLEmodel DLE pseudo model ModelTox class object DLEsamples DLE samples Samples class object Effmodel efficacy pseudo model ModelEff class object Effsamples efficacy samples Samples class object data data input DataDual class object ... additional arguments methods points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://roche.github.io/crmPack/reference/fitGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"fitGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples,   data = DataDual ): method returns data frame dose, middle, lower, upper quantiles gain values obtained given DLE efficacy samples","code":""},{"path":"https://roche.github.io/crmPack/reference/fitGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"","code":"##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values ## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and ## a efficacy sample ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model Effmodel<-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0) ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) Effsamples <- mcmc(data=data,model=Effmodel,options=options)  fitGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,         Effmodel=Effmodel, Effsamples=Effsamples,data=data) #>    dose    middle      lower     upper #> 1    25 0.3438477 -0.1699007 0.8544627 #> 2    50 0.5987149  0.2547977 0.9663746 #> 3    75 0.6767000  0.3040261 1.0822600 #> 4   100 0.7013123  0.2964078 1.1623733 #> 5   125 0.7042382  0.2695312 1.2074615 #> 6   150 0.6972572  0.2438631 1.2303285 #> 7   175 0.6855757  0.2240500 1.2498266 #> 8   200 0.6717347  0.2064641 1.2612999 #> 9   225 0.6570509  0.1851396 1.2673728 #> 10  250 0.6422299  0.1680738 1.2696973 #> 11  275 0.6276542  0.1555099 1.2693313 #> 12  300 0.6135277  0.1446233 1.2668871 ##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values ## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and ## a efficacy sample ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model Effmodel<-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0) ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) Effsamples <- mcmc(data=data,model=Effmodel,options=options)  fitGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,         Effmodel=Effmodel, Effsamples=Effsamples,data=data) #>    dose    middle      lower     upper #> 1    25 0.3442700 -0.2511183 0.9175569 #> 2    50 0.6051121  0.2599777 1.0301263 #> 3    75 0.6827104  0.3462284 1.0908986 #> 4   100 0.7050072  0.3326112 1.1992161 #> 5   125 0.7057281  0.2824561 1.2516880 #> 6   150 0.6972930  0.2543596 1.3306478 #> 7   175 0.6849992  0.2131238 1.3920869 #> 8   200 0.6712913  0.1845311 1.4412821 #> 9   225 0.6573428  0.1655045 1.4802234 #> 10  250 0.6437208  0.1457352 1.5127283 #> 11  275 0.6306888  0.1270349 1.5067852 #> 12  300 0.6183552  0.1115851 1.4874941"},{"path":"https://roche.github.io/crmPack/reference/fitPEM.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"Get fitted DLT free survival (piecewise exponential model). function returns data frame dose, middle, lower upper quantiles PEM curve. hazard=TRUE,","code":""},{"path":"https://roche.github.io/crmPack/reference/fitPEM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )  # S4 method for Samples,DALogisticLogNormal,DataDA fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/fitPEM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"object mcmc samples model mDA-CRM model data data input, DataDA class object quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean hazard hazard time plotted based PEM? (default) Otherwise ... ... additional arguments methods","code":""},{"path":"https://roche.github.io/crmPack/reference/fitPEM.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"fitPEM(object = Samples, model = DALogisticLogNormal, data = DataDA): method works DALogisticLogNormal model class.","code":""},{"path":"https://roche.github.io/crmPack/reference/fitPEM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"# nolint start  # Create the data data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   ID = 1L:8L,   cohort = as.integer(c(1:5, 6, 6, 6)),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 )  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior <- function(k) {   npiece_ / (data@Tmax * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 )  # Obtain the posterior  options <- McmcOptions(   burnin = 10,   step = 2,   samples = 1e2 )  set.seed(94) samples <- mcmc(data, model, options)   # Extract the posterior mean hazard (and empirical 2.5 and 97.5 percentile) # for the piecewise exponential model # If hazard=FALSE, the posterior PEM will be plot fitted <- fitPEM(   object = samples,   model = model,   data = data,   middle = mean,   hazard = TRUE,   quantiles = c(0.25, 0.75) )  # nolint end"},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"","code":"gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for numeric,ModelTox,Samples,ModelEff,Samples gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for numeric,ModelTox,missing,Effloglog,missing gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)"},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample. Otherwise, dose must size sample. model_dle (ModelTox) pseudo DLE (dose-limiting events)/toxicity model. samples_dle (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. model_eff (ModelEff) efficacy model pseudo data prior. samples_eff (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"gain values.","code":""},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"function computes gain values given dose level, pseudo DLE Efficacy models well given DLE Efficacy samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = Samples,   model_eff = ModelEff,   samples_eff = Samples ): gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = missing,   model_eff = Effloglog,   samples_eff = missing ): Compute gain value given dose level, pseudo DLE Efficacy models without DLE Efficacy samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/gain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"","code":"# Obtain the gain value for a given dose, a pseudo DLE and efficacy models # as well as DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  samples_dle <- mcmc(emptydata, model_dle, mcmc_opts)  # Efficacy model (Effloglog) and samples. model_effloglog <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  samples_effloglog <- mcmc(emptydata, model_effloglog, mcmc_opts)  # Gain values for dose level 75 and Effloglog efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effloglog,   samples_eff = samples_effloglog ) #>   [1] 0.6408328 0.9328737 1.3317937 0.9755601 1.5632863 0.6305203 0.9138837 #>   [8] 1.3243097 1.6300890 0.6922057 0.6948791 1.1977047 0.7107659 1.3493244 #>  [15] 1.1315107 0.5192456 1.6181089 1.1255197 0.6139932 1.1130316 0.2994175 #>  [22] 0.7625404 0.2999797 0.8641572 1.2187100 1.2814324 0.3824490 0.9207420 #>  [29] 1.1403403 0.3695379 1.4697527 0.9047391 0.4072838 0.4086533 0.9336283 #>  [36] 1.0253846 1.2746207 1.2389333 1.5941384 1.1963421 0.5599394 0.5972302 #>  [43] 1.0144189 0.8002580 0.4502802 1.1163495 0.5809296 1.4244017 0.9590778 #>  [50] 1.2828274 1.5297917 0.8138715 0.7212816 1.4461675 1.0349981 0.7453069 #>  [57] 1.0210496 1.2419379 1.3741230 1.0986051 0.8758285 1.1735655 0.5976080 #>  [64] 0.8904322 1.6233541 0.8059716 1.4919759 1.1787462 1.0145394 1.3836082 #>  [71] 1.2268082 1.1704848 1.2750769 0.9169179 0.5963439 1.5454189 0.7963324 #>  [78] 1.7116639 0.9309376 0.9485817 0.9387339 1.1573696 0.6048362 0.9319197 #>  [85] 1.1612720 0.9907762 0.9403920 1.1415660 1.3232608 0.9664984 0.6543996 #>  [92] 0.9952130 0.8423264 1.0979808 0.7735316 1.0236896 0.3128155 0.7172526 #>  [99] 1.2987465 1.3156077 0.8861968 0.8041023 1.3887307 0.7626237 1.0574967 #> [106] 0.5654114 0.9387753 1.1332396 1.3187461 1.3750455 1.2840815 1.0980457 #> [113] 0.5106619 0.3654438 0.9253451 0.8131477 0.9423602 1.2746120 1.4926014 #> [120] 1.2882855 0.9578128 0.6690747 1.7255752 0.6915817 1.1805667 1.5462893 #> [127] 1.4799990 1.2547675 1.4885465 1.5331700 0.8000799 0.9242831 0.8972873 #> [134] 0.5822894 1.4211837 1.4711264 1.0189077 1.1383444 0.5706135 1.3398664 #> [141] 0.6468929 0.4029541 1.3724370 1.1276486 1.0439208 1.5059942 1.3998324 #> [148] 0.1770508 1.4076756 1.1154960 1.5349931 1.0484810 1.4391473 0.4710791 #> [155] 0.5403335 0.7005458 1.8050641 1.4848396 0.7156361 1.3325150 0.7362993 #> [162] 1.3438726 0.8285547 0.3849198 1.5678709 1.2341540 0.5106456 0.2668566 #> [169] 0.5504141 1.3424511 0.9247626 1.0576609 1.3647710 1.7021687 1.6352920 #> [176] 0.3140200 1.0421455 1.1013259 1.5020743 0.6462236 1.4313372 1.3540828 #> [183] 0.7369552 0.6403422 0.9502782 1.2130977 0.7939327 1.1204203 1.1277037 #> [190] 1.3037997 0.3774526 1.2877474 0.9799113 0.8576480 1.0937620 1.1248835 #> [197] 1.2573625 1.4749750 0.8422842 1.3569855  # Efficacy model (EffFlexi) and samples. model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  samples_effflexi <- mcmc(emptydata, model_effflexi, mcmc_opts)  # Gain values for dose level 75 and EffFlexi efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effflexi,   samples_eff = samples_effflexi ) #>   [1] -3.641258479 -0.166594269  2.829620278  0.373952783 -0.531216668 #>   [6] -0.849105460 -0.065925460  3.754745902 -2.791016053 -1.147059424 #>  [11] -1.622033918  2.597111740  1.197175328  1.369203404  2.781684703 #>  [16]  0.962836870  0.211708598  0.973357798 -1.811698890  3.131962728 #>  [21] -0.389066338  2.691613664  0.042115612 -0.943475453  0.096550011 #>  [26]  1.572014038  0.857323140  3.656854731  4.916892544 -0.050870353 #>  [31]  7.615495164  6.990399000  0.189376787  1.216857254  2.122802942 #>  [36] -0.343985681 -2.044233401  0.405325747 -4.692310210  0.183203671 #>  [41]  1.751732491  2.472171778  3.907644282  0.509817220  0.963978404 #>  [46] -1.910024280  2.548437823  3.584017283 -2.961184300  5.625251529 #>  [51]  1.411365107  1.823892403 -0.555407059  2.214243352  5.325509511 #>  [56]  3.230107442 -0.180554045 -1.519353539  4.392940449 -0.324944427 #>  [61]  1.937776867  4.713343578  0.002247316  3.826853736  2.683337672 #>  [66] -0.992753550 -1.479189994  3.914210627  3.570068719 -2.851355623 #>  [71]  1.326984049 -0.689519459  1.802278904  3.385245313  1.734210398 #>  [76]  2.017888700 -0.782043480  1.546538605  1.576855927 -2.485716994 #>  [81]  1.739378275 -0.097576690  1.330695648 -0.641331468 -2.137687696 #>  [86]  3.549640751 -5.127964328 -2.174882417  0.374979399 -0.439305187 #>  [91]  2.640830551  7.110037040 -0.355985551  0.748719357  1.057974680 #>  [96] -2.568168383  0.837028308  4.035940395 -2.650119496  2.069409492 #> [101]  0.168311973 -0.354353317 -0.945395850  0.042061322 -1.886457022 #> [106]  0.480350580 -1.311068287  1.189967273 -0.357601100  5.239007064 #> [111]  4.423448654  5.845130739 -0.844561461  1.896738757 -2.956209402 #> [116]  0.466760455 -3.277578269  4.374041653  2.898278267  2.501704743 #> [121]  0.347510835  0.037178121  6.489170359  6.496274308  2.145448273 #> [126]  6.512057312  2.766912660  0.715474276 -4.413271023 -0.770319686 #> [131]  0.814217755  0.918800050  3.731321024 -0.218731762 -0.464509686 #> [136] -0.426412729 -0.208224708 -1.318230637  0.595482918  2.551353508 #> [141]  2.526157319  0.873345642 -2.385976068 -3.150363936 -0.720407718 #> [146] -0.589728368  2.352961488  0.987534174  1.044477211  3.451487245 #> [151]  7.431615588 -0.459645433  4.732831808  1.766993618 -1.165560079 #> [156] -0.887049698 -7.853038676 -2.497354236  2.770452213  5.268456605 #> [161] -0.097615890  2.467869827  2.685456166  2.494766869  2.567079551 #> [166]  8.717333592 -1.737184651 -0.528517049  4.013972818  1.902246000 #> [171]  3.727450039 -3.394227948 -0.874971561  2.259698149  6.547521168 #> [176]  0.918450022  2.950616237 -1.445793249  3.845205913  1.820144472 #> [181]  3.163183920  0.222833102 -0.428068347  0.478277681  3.585246116 #> [186]  4.655750990  2.230958985  2.182741536  5.235442639 -0.754730037 #> [191]  0.857802805  2.543688576 -0.414278366  1.772843364 -5.108692368 #> [196] -1.306825956  1.140343944  3.245963440  1.547776394 -0.642978970  # Obtain the gain value for a given dose, a pseudo DLE and efficacy models # without DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) data <- Data(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  # Efficacy model and samples. model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Gain value for dose level 75. gain(   dose = 75,   model_dle = model_dle,   model_eff = model_eff ) #> [1] 1.020657"},{"path":"https://roche.github.io/crmPack/reference/get-Samples-character-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"specify pos parameter like extract Samples object","code":""},{"path":"https://roche.github.io/crmPack/reference/get-Samples-character-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# S4 method for Samples,character get(x, pos = -1L, envir = NULL, mode = NULL, inherits = NULL)"},{"path":"https://roche.github.io/crmPack/reference/get-Samples-character-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"x Samples object pos name parameter envir vectorial parameters, can give indices elements like extract. NULL, whole vector samples returned mode used inherits used","code":""},{"path":"https://roche.github.io/crmPack/reference/get-Samples-character-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"data frame suitable use ggmcmc","code":""},{"path":"https://roche.github.io/crmPack/reference/get-Samples-character-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # now extract the alpha0 samples (intercept of the regression model) alpha0samples <- get(samples, \"alpha0\")  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/getEff.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"method extracts efficacy responses subjects categorizes respect DLT, .e. DLT DLT. efficacy responses reported together corresponding dose levels.","code":""},{"path":"https://roche.github.io/crmPack/reference/getEff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"getEff(object, ...)  # S4 method for DataDual getEff(object, no_dlt = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/getEff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"object (DataDual) object responses dose levels extracted. ... arguments passed class-specific methods. no_dlt (flag) DLT responses returned? Otherwise, responses returned.","code":""},{"path":"https://roche.github.io/crmPack/reference/getEff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"list efficacy responses categorized DLT value.","code":""},{"path":"https://roche.github.io/crmPack/reference/getEff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"# Example data. data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Get the efficacy response and their corresponding dose levels # categorized by the DLT. getEff(data) #> $x_no_dlt #> [1]  25  50  25  50  75 150 #>  #> $w_no_dlt #> [1] 0.31 0.42 0.59 0.45 0.60 0.52 #>  #> $x_dlt #> [1] 300 250 #>  #> $w_dlt #> [1] 0.7 0.6 #>"},{"path":"https://roche.github.io/crmPack/reference/getMinInfBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the minimal informative unimodal beta distribution — getMinInfBeta","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"defined Neuenschwander et al (2008), function computes parameters minimal informative unimodal beta distribution, given request p-quantile q, .e. X ~ (, b) Pr(X <= q) = p.","code":""},{"path":"https://roche.github.io/crmPack/reference/getMinInfBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"","code":"getMinInfBeta(p, q)"},{"path":"https://roche.github.io/crmPack/reference/getMinInfBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"p probability (> 0 < 1) q quantile (> 0 < 1)","code":""},{"path":"https://roche.github.io/crmPack/reference/getMinInfBeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"two resulting beta parameters b list","code":""},{"path":"https://roche.github.io/crmPack/reference/get_result_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Obtain Simulation Results List — get_result_list","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"function fun can use variables visible . names variables given vector vars.","code":""},{"path":"https://roche.github.io/crmPack/reference/get_result_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"","code":"get_result_list(fun, nsim, vars, parallel, n_cores)"},{"path":"https://roche.github.io/crmPack/reference/get_result_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"fun (function) simulation function single iteration, takes single parameter iteration index. nsim number simulations conducted. vars names variables. parallel simulation runs parallelized across clusters computer? n_cores many cores used parallel computing?","code":""},{"path":"https://roche.github.io/crmPack/reference/get_result_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"list simulation results (one iteration corresponds one list element).","code":""},{"path":"https://roche.github.io/crmPack/reference/h_add_dlts.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Add Randomly Generated DLTs During Simulations — h_add_dlts","title":"Helper Function to Add Randomly Generated DLTs During Simulations — h_add_dlts","text":"Helper Function Add Randomly Generated DLTs Simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/h_add_dlts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Add Randomly Generated DLTs During Simulations — h_add_dlts","text":"","code":"h_add_dlts(data, dose, truth, cohort_size, first_separate)"},{"path":"https://roche.github.io/crmPack/reference/h_add_dlts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Add Randomly Generated DLTs During Simulations — h_add_dlts","text":"data (Data) data start . dose (number) current dose. truth (function) defines true probability DLT dose. cohort_size (CohortSize) cohort size rule use. first_separate (flag) whether first patient enrolled separately.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_add_dlts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Add Randomly Generated DLTs During Simulations — h_add_dlts","text":"updated data.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_all_equivalent.html","id":null,"dir":"Reference","previous_headings":"","what":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"helper function ensures default tolerance level equal 1e-10, ignores names attributes. contrast .equal(), always returns logical type object.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_all_equivalent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"","code":"h_all_equivalent(target, current, tolerance = 1e-10)"},{"path":"https://roche.github.io/crmPack/reference/h_all_equivalent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"target (numeric) target values. current (numeric) current values. tolerance (number) relative differences smaller reported.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_all_equivalent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"TRUE target current differ desired tolerance without looking names attributes, FALSE otherwise.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_barplot_percentages.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience function to make barplots of percentages — h_barplot_percentages","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"Convenience function make barplots percentages","code":""},{"path":"https://roche.github.io/crmPack/reference/h_barplot_percentages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"","code":"h_barplot_percentages(x, description, xaxisround = 0)"},{"path":"https://roche.github.io/crmPack/reference/h_barplot_percentages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"x vector samples description xlab string xaxisround rounding xaxis labels (default: 0, .e. integers used)","code":""},{"path":"https://roche.github.io/crmPack/reference/h_barplot_percentages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"ggplot2 object","code":""},{"path":"https://roche.github.io/crmPack/reference/h_blind_plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Blind Plot Data — h_blind_plot_data","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"Helper Function Blind Plot Data","code":""},{"path":"https://roche.github.io/crmPack/reference/h_blind_plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"","code":"h_blind_plot_data(df, blind, has_placebo, pbo_dose)"},{"path":"https://roche.github.io/crmPack/reference/h_blind_plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"df (GeneralData) data blinded blind (flag) data blinded? has_placebo (flag) data contain placebo dose? pbo_dose (positive_number) dose taken placebo. Ignored has_placebo FALSE","code":""},{"path":"https://roche.github.io/crmPack/reference/h_blind_plot_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"blinded data","code":""},{"path":"https://roche.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":null,"dir":"Reference","previous_headings":"","what":"calculate percentage of true stopping rules for report label output — h_calc_report_label_percentage","title":"calculate percentage of true stopping rules for report label output — h_calc_report_label_percentage","text":"calculates true column means converts output percentages combining output report label; output passed show() output cat console","code":""},{"path":"https://roche.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calculate percentage of true stopping rules for report label output — h_calc_report_label_percentage","text":"","code":"h_calc_report_label_percentage(stop_report)"},{"path":"https://roche.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calculate percentage of true stopping rules for report label output — h_calc_report_label_percentage","text":"stop_report object summary method","code":""},{"path":"https://roche.github.io/crmPack/reference/h_check_fun_formals.html","id":null,"dir":"Reference","previous_headings":"","what":"Checking Formals of a Function — h_check_fun_formals","title":"Checking Formals of a Function — h_check_fun_formals","text":"helper function checks whether given function fun required allowed arguments. argument check based names arguments. logic verified .","code":""},{"path":"https://roche.github.io/crmPack/reference/h_check_fun_formals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checking Formals of a Function — h_check_fun_formals","text":"","code":"h_check_fun_formals(fun, mandatory = NULL, allowed = NULL)"},{"path":"https://roche.github.io/crmPack/reference/h_check_fun_formals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checking Formals of a Function — h_check_fun_formals","text":"fun (function) function name whose argument names checked. mandatory (character NULL) names arguments must present fun. mandatory specified NULL (default) requirement ignored. allowed (character NULL) names arguments allowed fun. Names belong allowed simply allowed. allowed parameter independent mandatory, sense mandatory specified character vector, repeated allowed. allowed specified NULL (default), means must arguments fun (except ones specified mandatory).","code":""},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"Workarounds allow package continue work running covr minimal changes package code.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"","code":"h_covr_active()  h_covr_detrace(expr)  h_is_covr_trace(expr)  h_covr_detrace_call(expr)"},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"expr (language) R expression call test strip covr trace counters.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"logical value transformed expression calls covr:::count removed.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"using covr, source code package objects modified add callbacks expression log execution. Given arbitrary expression, :   code modified executing package code look like:   functions used stripping expressions code package continues work intended running tests part running covr calculate package coverage. method non-exhaustive, covering subset covr's tracing behaviors necessary package.","code":"expr if (TRUE) {   covr:::count(\"file.R:1:2:3:4:5:6:7:8\")   expr }"},{"path":"https://roche.github.io/crmPack/reference/h_covr_helpers.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"h_covr_active(): Determine whether covr currently running h_covr_detrace(): Remove covr traces expression h_is_covr_trace(): Determine whether current expression covr-modified expression h_covr_detrace_call(): Extract original expression covr-modified expression","code":""},{"path":"https://roche.github.io/crmPack/reference/h_default_if_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the default value for an empty object — h_default_if_empty","title":"Getting the default value for an empty object — h_default_if_empty","text":"simple helper function sets default value empty object, object length() function returns 0L.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_default_if_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the default value for an empty object — h_default_if_empty","text":"","code":"h_default_if_empty(x, default)"},{"path":"https://roche.github.io/crmPack/reference/h_default_if_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the default value for an empty object — h_default_if_empty","text":"x ()  object handle. can object length() function defined. default ()  default value x object.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_default_if_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the default value for an empty object — h_default_if_empty","text":"","code":"h_default_if_empty(character(0), default = \"default label\") #> [1] \"default label\" h_default_if_empty(\"custom label\", default = \"default label\") #> [1] \"custom label\" h_default_if_empty(NA, default = \"default label\") #> [1] NA"},{"path":"https://roche.github.io/crmPack/reference/h_find_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"simple wrapper findInterval() function invokes findInterval(), takes output replaces elements \\(0\\) value custom number specified replacement argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_find_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(..., replacement = -Inf)"},{"path":"https://roche.github.io/crmPack/reference/h_find_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"... Arguments passed base::findInterval x numeric. vec numeric, sorted (weakly) increasingly, length N,     say. rightmost.closed logical; true, rightmost interval,     vec[N-1] .. vec[N] treated closed, see . .inside logical; true, returned indices coerced     1,...,N-1, .e., 0 mapped 1     N N-1. left.open logical; true intervals open left     closed right; formulas , \\(\\le\\)     swapped \\(<\\) (\\(>\\) \\(\\ge\\)),     rightmost.closed means ‘leftmost closed’.  may     useful, e.g., survival analysis computations. replacement (number) custom number used replacement \\(0\\). Default -Inf.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_find_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(1, c(2, 4, 6)) #> [1] -Inf h_find_interval(3, c(2, 4, 6)) #> [1] 1 h_find_interval(1, c(2, 4, 6), replacement = -1) #> [1] -1"},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Formatting Using C-style Formats — h_format_number","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"helper function conditionally formats number formatC() function using \"E\" format specific number digits given user. number formatted absolute value less 0.001 greater 10000. Otherwise, number formatted. Additionally, custom prefix suffix can appended character string formatted number, changes marked.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(x, digits = 5, prefix = \"\", suffix = \"\")"},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"x (number) number formatted. digits (function) desired number significant digits. prefix (string) prefix added front formatted number. suffix (string) suffix appended formatted number.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"Either formatted x string unchanged x formatting condition met.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_format_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(50000) #> [1] \"5.00000E+04\" h_format_number(50000, prefix = \"P\", suffix = \"S\") #> [1] \"P5.00000E+04S\""},{"path":"https://roche.github.io/crmPack/reference/h_group_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Together Mono and Combo Data — h_group_data","title":"Group Together Mono and Combo Data — h_group_data","text":"used simulation method DesignGrouped combine separately generated data sets mono combo arms fit combined logistic regression model. Hence ID cohort information relevant arbitrarily assigned avoid problems DataGrouped validation.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_group_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Together Mono and Combo Data — h_group_data","text":"","code":"h_group_data(mono_data, combo_data)"},{"path":"https://roche.github.io/crmPack/reference/h_group_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Together Mono and Combo Data — h_group_data","text":"mono_data (Data) mono data. combo_data (Data) combo data.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_group_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Together Mono and Combo Data — h_group_data","text":"DataGrouped object containing mono_data combo_data, arbitrary ID cohort slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check which elements are in a given range — h_in_range","title":"Check which elements are in a given range — h_in_range","text":"simple helper function tests whether elements given vector matrix within specified interval.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check which elements are in a given range — h_in_range","text":"","code":"h_in_range(x, range = c(0, 1), bounds_closed = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/h_in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check which elements are in a given range — h_in_range","text":"x (numeric) vector matrix elements test. range (numeric) interval, .e. sorted two-elements vector. bounds_closed (logical) bounds range treated closed? can scalar vector length two. scalar, value applies lower bound range[1] upper bound range[2]. vector two flags, first flag corresponds lower bound , second upper bound .","code":""},{"path":"https://roche.github.io/crmPack/reference/h_in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check which elements are in a given range — h_in_range","text":"logical vector matrix length equal length x, every element x, indicates whether given element x range.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check which elements are in a given range — h_in_range","text":"","code":"x <- 1:4 h_in_range(x, range = c(1, 3)) #> [1]  TRUE  TRUE  TRUE FALSE h_in_range(x, range = c(1, 3), bounds_closed = FALSE) #> [1] FALSE  TRUE FALSE FALSE h_in_range(x, range = c(1, 3), bounds_closed = c(FALSE, TRUE)) #> [1] FALSE  TRUE  TRUE FALSE mat <- matrix(c(2, 5, 3, 10, 4, 9, 1, 8, 7), nrow = 3) h_in_range(mat, range = c(1, 5)) #>      [,1]  [,2]  [,3] #> [1,] TRUE FALSE  TRUE #> [2,] TRUE  TRUE FALSE #> [3,] TRUE FALSE FALSE"},{"path":"https://roche.github.io/crmPack/reference/h_info_theory_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the Information Theoretic Distance — h_info_theory_dist","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"Helper function provides value divergence given equation (7) reference https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_info_theory_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(prob, target, asymmetry)"},{"path":"https://roche.github.io/crmPack/reference/h_info_theory_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"prob (numeric) vector matrix probabilities DLT occurring. target (number ) single target probability DLT. asymmetry (number) describes rate penalization overly toxic , range 0 2.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_info_theory_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(c(0.5, 0.2), 0.4, 1.2) #> [1] 0.040000 0.329877"},{"path":"https://roche.github.io/crmPack/reference/h_is_positive_definite.html","id":null,"dir":"Reference","previous_headings":"","what":"Testing Matrix for Positive Definiteness — h_is_positive_definite","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"helper function checks whether given numerical matrix x positive-definite square matrix given size, without missing values. function used test given matrix covariance matrix, since every symmetric positive semi-definite matrix covariance matrix.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_is_positive_definite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"","code":"h_is_positive_definite(x, size = 2, tol = 1e-08)"},{"path":"https://roche.github.io/crmPack/reference/h_is_positive_definite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"x (matrix) matrix checked. size (integer) size square matrix x checked . tol (number) given tolerance number used check whether eigenvalue positive . eigenvalue considered positive greater tol.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_is_positive_definite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"TRUE given matrix positive-definite, FALSE otherwise.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_is_positive_definite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"positive definiteness test implemented function based following characterization valid real matrices: symmetric matrix positive-definite eigenvalues positive. function eigenvalue considered positive greater tol.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":null,"dir":"Reference","previous_headings":"","what":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"helper function appends dummy value given slots GeneralData class object, total number observations (indicated object@nObs) equals 1. Otherwise, object changed.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"h_jags_add_dummy(object, where, dummy = 0)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"object (GeneralData) object dummy values added. (character) names slots object dummy number appended. dummy (number) dummy number appended selected slots object. Default 0.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"GeneralData object slots updated dummy number.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"main motivation behind function related JAGS. one observation, data passed correctly JAGS, .e. e.g. x y treated like scalars data file. Therefore necessary add dummy values vectors case change number observations (nObs), addition zeros affect results JAGS computations.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_add_dummy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"# Create some data of class 'Data' my_data <- Data(   x = 0.1,   y = 0,   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  my_data_2 <- Data(   x = c(0.1, 0.5),   y = c(0, 1),   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Append dummy to `x` and `y`. h_jags_add_dummy(my_data, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.0 #>  #> Slot \"y\": #> [1] 0 0 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 #>  #> Slot \"cohort\": #> [1] 1 #>  #> Slot \"nObs\": #> [1] 1 #>   # Append dummy to `x` and `y`. No effect as `my_data_2@nObs != 1`. h_jags_add_dummy(my_data_2, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.5 #>  #> Slot \"y\": #> [1] 0 1 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 2 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 #>  #> Slot \"cohort\": #> [1] 1 2 #>  #> Slot \"nObs\": #> [1] 2 #>"},{"path":"https://roche.github.io/crmPack/reference/h_jags_extract_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"simple helper function extracts sample rjags::mcarray.object S3 class object. rjags::mcarray.object object used rjags::jags.samples() function represent MCMC output JAGS model.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_extract_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"","code":"h_jags_extract_samples(x)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_extract_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"x rjags::mcarray.object object.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting Data for JAGS — h_jags_get_data","title":"Getting Data for JAGS — h_jags_get_data","text":"simple helper function prepares object data argument rjags::jags.model(), invoked mcmc() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"h_jags_get_data(model, data, from_prior)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting Data for JAGS — h_jags_get_data","text":"model (GeneralModel) input model. data (GeneralData) input data. from_prior (flag) sample prior ? case data appended output, .e. variables required model@priormodel model returned data.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  jags_data <- h_jags_get_data(my_model, my_data, from_prior = FALSE) jags_data #> $nObs #> [1] 8 #>  #> $y #> [1] 0 0 0 0 0 0 1 0 #>  #> $x #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> $mean #> [1] -0.85  1.00 #>  #> $prec #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #> $ref_dose #> [1] 56 #>"},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_model_inits.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"simple helper function prepares object inits argument rjags::jags.model(), invoked mcmc() method. inits argument specifies initial values model parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"h_jags_get_model_inits(model, data)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"model (GeneralModel) input model. data (GeneralData) input data.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"list starting values parameters required initialized MCMC JAGS sampler.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  h_jags_get_model_inits(model = my_model, data = my_data) #> $theta #> [1] 0 1 #>"},{"path":"https://roche.github.io/crmPack/reference/h_jags_join_models.html","id":null,"dir":"Reference","previous_headings":"","what":"Joining JAGS Models — h_jags_join_models","title":"Joining JAGS Models — h_jags_join_models","text":"helper function joins two JAGS models way body second model appended body first model (order). , first, body-extended model returned. arguments model1, model2 model functions () combined way.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_join_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Joining JAGS Models — h_jags_join_models","text":"","code":"h_jags_join_models(model1, model2)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_join_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Joining JAGS Models — h_jags_join_models","text":"model1 (function) first model join. model2 (function) second model join.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_join_models.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Joining JAGS Models — h_jags_join_models","text":"joined models.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_join_models.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Joining JAGS Models — h_jags_join_models","text":"model1 model2 functions must multi-expression body, .e. braced expression(s). Environments attributes function bodies preserved way joining.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Writing JAGS Model to a File — h_jags_write_model","title":"Writing JAGS Model to a File — h_jags_write_model","text":"function converts R function JAGS model text writes given file. \"model text\" conversion, format numbers absolute value less 0.001 greater 10000 changed. numbers converted scientific format specified number significant digits using formatC() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"h_jags_write_model(model, file = NULL, digits = 5)"},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writing JAGS Model to a File — h_jags_write_model","text":"model (function) function containing JAGS model. file (string NULL) name file (including optional path) model saved. NULL, file created R_crmPack folder placed temporary directory indicated tempdir() function. digits (count) desired number significant digits numbers used JAGS input, see formatC().","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writing JAGS Model to a File — h_jags_write_model","text":"name file model saved.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Writing JAGS Model to a File — h_jags_write_model","text":"JAGS syntax allows truncation specification like dnorm(...) (...), illegal R. overcome incompatibility, use dummy operator \\%_\\% (...), .e. dnorm(...) \\%_\\% (...) model's code. dummy operator \\%_\\% removed just saving JAGS code file. Due technical issues related conversion numbers scientific format, required body model function contain TEMP_NUM_PREF_ _TEMP_NUM_SUF character constants body.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_jags_write_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"# Some model function my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  h_jags_write_model(my_model, digits = 5) #> [1] \"/tmp/RtmpzrVlgJ/R_crmPack/jags_model_fun1db742de575.txt\""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"simple helper function takes DualEndpoint object updates use_fixed, priormodel, modelspecs, init, sample slots regard given parameter dose-biomarker relationship \\(f(x)\\) defined DualEndpointBeta class. update solely depends whether given parameter's value param fixed-valued scalar two-elements numeric vector. later case, assumed param represents two parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). See help page DualEndpointBeta class details.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"","code":"h_model_dual_endpoint_beta(   param,   param_name,   param_suffix = c(\"_low\", \"_high\"),   priormodel = NULL,   de )"},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"param (numeric) value given param_name parameter dose-biomarker relationship function \\(f(x)\\). Either fixed-valued scalar vector two elements parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). param_name (string) name parameter \\(f(x)\\), whose value depends param. param_suffix (character) two suffixes appended elements param_name used updating modelspecs. value argument ignored param scalar. priormodel (function NULL) function representing JAGS prior specification appended existing de@priormodel specification param scalar. Otherwise, de@priormodel remains unchanged. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"DualEndpoint model updated use_fixed, priormodel, modelspecs, init, sample slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard DLT biomarker correlation rho.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"","code":"h_model_dual_endpoint_rho(use_fixed, rho, comp)"},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"use_fixed (flag) indicates whether fixed value DLT biomarker correlation rho used . rho supposed fixed value, prior distribution scaled Beta family used. See details , rho argument. rho (numeric) DLT biomarker correlation. must either fixed value (-1 1), named vector two elements, named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"list updated model components.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard biomarker regression variance sigma2W.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"","code":"h_model_dual_endpoint_sigma2W(use_fixed, sigma2W, comp)"},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"use_fixed (flag) indicates whether fixed value biomarker regression variance sigma2W used . sigma2W supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2W argument. sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"list updated model components.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"simple helper function takes DualEndpoint object updates priormodel, modelspecs, init, sample slots according random walk variance.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"","code":"h_model_dual_endpoint_sigma2betaW(use_fixed, sigma2betaW, de)"},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"use_fixed (flag) indicates whether fixed value sigma2betaW used . sigma2betaW supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2betaW argument. sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"DualEndpoint model updated priormodel, modelspecs, init, sample slots.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"Helper function gets eligible doses dose grid. eligible doses doses exceed given doselimit. placebo design, safety allows (.e. least one non-placebo dose exceed dose limit), placebo dose excluded eligible doses.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"h_next_best_eligible_doses(dose_grid, doselimit, placebo, levels = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo. levels (flag) TRUE levels eligible doses returned, otherwise, doses (default).","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"numeric vector eligible doses eligible dose levels levels flag TRUE.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"dose_grid <- c(0.001, seq(25, 200, 25)) h_next_best_eligible_doses(dose_grid, 79, TRUE) #> [1] 25 50 75 h_next_best_eligible_doses(dose_grid, 24, TRUE) #> [1] 0.001"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Helper function nextBest-NextBestMaxGain() method. computes 95% credibility intervals given target dose max gain dose. also returns ratio upper lower bounds interval.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"","code":"h_next_best_mg_ci(dose_target, dose_mg, prob_target, placebo, model, model_eff)"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"dose_target (number) target dose estimate. dose_mg (number) dose corresponding maximum gain. prob_target (proportion) target DLT probability. placebo (flag) TRUE first dose level dose grid used considered placebo. needed adjust max gain dose using efficacy constant value. placebo used, model_eff@const added dose_mg. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Yeung, W.Y., Whitehead, J., Reigner, B., Beyer, U., Diack, Ch., Jaki, T. (2015), Bayesian adaptive dose-escalation procedures binary continuous responses utilizing gain function, Pharmaceutical Statistics, doi:10.1002/pst.1706","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"Helper function given target doses finds dose grid closest target. four different targets context nextBest-NextBestMaxGain() method: \\(min(`dose_mg`, `dose_target_drt`)\\), dose_mg, dose_target_drt dose_target_eot.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"","code":"h_next_best_mg_doses_at_grid(   dose_target_drt,   dose_target_eot,   dose_mg,   dose_grid,   doselimit,   placebo )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"dose_target_drt (number) target dose estimate trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"Helper function creates plot nextBest-NextBestMaxGain() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"","code":"h_next_best_mg_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   max_gain,   next_dose,   doselimit,   data,   model,   model_eff )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mg_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. max_gain (number) maximum gain estimate. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. data (DataDual) data object dose grid fetched. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"Helper function creates plot nextBest-NextBestMaxGainSamples() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"","code":"h_next_best_mgsamples_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   dose_mg_samples,   next_dose,   doselimit,   dose_grid_range )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_mg_samples (numeric) every sample, dose (dose grid) gives maximum gain value. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. dose_grid_range (numeric) dose grid range.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"Helper function creates plot nextBest-NextBestNCRMLoss() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"","code":"h_next_best_ncrm_loss_plot(   prob_mat,   posterior_loss,   max_overdose_prob,   dose_grid,   max_eligible_dose_level,   doselimit,   next_dose,   is_unacceptable_specified )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"prob_mat (numeric) matrix probabilities grid doses given interval. is_unacceptable_specified TRUE, must 4 intervals (columns) prob_mat: underdosing, target, excessive, unacceptable. Otherwise, must 3 intervals (columns): underdosing, target, overdose. Number rows must equal number doses grid. posterior_loss (numeric) posterior losses. max_overdose_prob (number) maximum overdose posterior probability allowed. dose_grid (numeric) dose grid. max_eligible_dose_level (number) maximum eligible dose level dose_grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose. is_unacceptable_specified (flag) unacceptable interval specified?","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_td_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"Helper function creates plot nextBest-NextBestTD() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_td_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"","code":"h_next_best_td_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   data,   prob_dlt,   doselimit,   next_dose )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_td_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. data (Data) data object dose grid fetched. prob_dlt (numeric) DLT probabilities doses grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"Helper function creates plot nextBest-NextBestTDsamples() method.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"","code":"h_next_best_tdsamples_plot(   dose_target_drt_samples,   dose_target_eot_samples,   dose_target_drt,   dose_target_eot,   dose_grid_range,   nextBest,   doselimit,   next_dose )"},{"path":"https://roche.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"dose_target_drt_samples (numeric) vector -trial samples. dose_target_eot_samples (numeric) vector end--trial samples. dose_target_drt (number) target -trial estimate. dose_target_eot (number) target end--trial estimate. dose_grid_range (numeric) range dose grid. nextBest (NextBestTDsamples) rule next best dose. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_null_if_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting NULL for NA — h_null_if_na","title":"Getting NULL for NA — h_null_if_na","text":"simple helper function replaces NA object NULL object.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_null_if_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(x)"},{"path":"https://roche.github.io/crmPack/reference/h_null_if_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting NULL for NA — h_null_if_na","text":"x () atomic object length 1. definition \"atomic\", see .atomic().","code":""},{"path":"https://roche.github.io/crmPack/reference/h_null_if_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting NULL for NA — h_null_if_na","text":"NULL x NA, otherwise, x.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_null_if_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(NA) #> NULL"},{"path":"https://roche.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"Used dose_grid_range-Data dose_grid_range-DataOrdinal","code":""},{"path":"https://roche.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"","code":"h_obtain_dose_grid_range(object, ignore_placebo)"},{"path":"https://roche.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"object (Data DataOrdinal) object dose grid range required ignore_placebo (flag) placebo dose () counted?","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"helper function prepares ggplot geom reference lines separating different cohorts plot Data class object. Lines either vertical horizontal green color longdash type.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"","code":"h_plot_data_cohort_lines(cohort, placebo, vertical = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"cohort (integer) cohort indices. placebo (flag) placebo included doses? , function returns NULL object case doses given cohort equal need separate . vertical (flag) line vertical? Otherwise horizontal.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"geom object returned placebo equal TRUE one unique values cohort. Otherwise, function returns NULL object.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Data for Plotting — h_plot_data_df","title":"Preparing Data for Plotting — h_plot_data_df","text":"helper function prepares data.frame object based Data class object. resulting data frame used plot function Data class objects.  method transforms GeneralData  objects tibble suitable plotting ggplot2 methods","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Data for Plotting — h_plot_data_df","text":"","code":"h_plot_data_df(data, ...)  h_plot_data_df(data, ...)  # S4 method for Data h_plot_data_df(data, blind = FALSE, legend = TRUE, ...)  # S4 method for DataOrdinal h_plot_data_df(data, blind = FALSE, legend = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Data for Plotting — h_plot_data_df","text":"data (Data) object data extracted converted data frame. ... arguments passed data.frame constructor. can e.g. extra column_name = value pair based slot x (case might subclass Data) appear Data. blind (flag) data blinded? TRUE, cohort, DLTs assigned first subjects cohort. addition, placebo () set active dose level cohort. legend (flag) Display legend toxicity categories","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preparing Data for Plotting — h_plot_data_df","text":"data.frame object values plot. data.frame containing columns patient, cohort, dose toxicity grade data.frame object columns patient, ID, cohort, dose toxicity.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_plot_data_df.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Preparing Data for Plotting — h_plot_data_df","text":"h_plot_data_df(Data): method Data. h_plot_data_df(DataOrdinal): Class specific method DataOrdinal","code":""},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursively Apply a Function to a List — h_rapply","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function recursively iterates \"list-like\" object checks whether element given class. , replaces element result execution given function. Otherwise, element length greater 1 (.e. scalar), replaces element result h_rapply(), recursively called element. remaining case, , element given class scalar, element remains unchanged.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"h_rapply(x, fun, classes, ...)"},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursively Apply a Function to a List — h_rapply","text":"x () \"list-like\" object subsetting operator [[ defined. fun (function) function one \"principal\" argument, passing arguments via .... classes (character) class names. ... arguments passed function fun.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursively Apply a Function to a List — h_rapply","text":"\"list-like\" object similar structure x.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function conceptually similar rapply() function. However, differs rapply() two major ways. First, h_rapply() limited objects type list expression . can \"list-like\" object type subsetting operator [[ defined. can , example, object type language, often obtained body() function. second difference flexibility rapply() result structured available h_rapply() user. , h_rapply() element x, class included classes, replaced result applying fun element. behavior corresponds rapply() invoked fixed = replace. function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_rapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"# Some model function. my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  # Replace format of numbers using `formatC` function. h_rapply(   x = body(my_model),   fun = formatC,   classes = c(\"integer\", \"numeric\"),   digits = 3,   format = \"E\" ) #> { #>     alpha0 <- mean(\"1.000E+00\":\"1.000E+01\") #>     alpha1 <- \"6.000E+05\" #> }"},{"path":"https://roche.github.io/crmPack/reference/h_slots.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Slots from a S4 Object — h_slots","title":"Getting the Slots from a S4 Object — h_slots","text":"helper function extracts requested slots S4 class object. simple wrapper methods::slot() function.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_slots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Slots from a S4 Object — h_slots","text":"","code":"h_slots(object, names, simplify = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/h_slots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Slots from a S4 Object — h_slots","text":"object (S4) object formally defined S4 class. names (character) vector names slots fetched. function assumes every element names, exists slot name object. simplify (flag) output simplified? effect single slot extracted, .e. names just single string.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_slots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Slots from a S4 Object — h_slots","text":"list slots extracted object according names, single slot simplification required possible.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a named vector of type numeric — h_test_named_numeric","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"simple helper function tests whether object named numerical vector.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(   x,   subset.of = NULL,   must.include = NULL,   permutation.of = NULL,   identical.to = NULL,   disjunct.from = NULL,   lower = 0 + .Machine$double.xmin,   finite = TRUE,   any.missing = FALSE,   len = 2,   ... )"},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"x () object check. subset.[character] Names provided x must subset set subset.. must.include [character] Names provided x must superset set must.include. permutation.[character] Names provided x must permutation set permutation.. Duplicated names permutation.stripped duplicated names x thus lead failed check. Use argument instead identical.order names relevant. identical.[character] Names provided x must identical vector identical.. Use argument instead permutation.order names relevant. disjunct.[character] Names provided x must may present vector disjunct.. lower [numeric(1)] Lower value elements x must greater equal . finite [logical(1)] Check finite values? Default FALSE. .missing [logical(1)] vectors missing values allowed? Default TRUE. len [integer(1)] Exact expected length x. ... parameters passed checkmate::test_numeric().","code":""},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"TRUE x named vector type numeric, otherwise FALSE.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"function based checkmate::test_numeric() checkmate::test_names() functions.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_test_named_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(1:2, permutation.of = c(\"a\", \"b\")) #> [1] FALSE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"a\", \"b\")) #> [1] TRUE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"b\", \"a\")) #> [1] TRUE"},{"path":"https://roche.github.io/crmPack/reference/h_unpack_stopit.html","id":null,"dir":"Reference","previous_headings":"","what":"unpack stopping rules and return list — h_unpack_stopit","title":"unpack stopping rules and return list — h_unpack_stopit","text":"recursively unpack nested stopping rules logical value label given","code":""},{"path":"https://roche.github.io/crmPack/reference/h_unpack_stopit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"unpack stopping rules and return list — h_unpack_stopit","text":"","code":"h_unpack_stopit(stopit_tree)"},{"path":"https://roche.github.io/crmPack/reference/h_unpack_stopit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"unpack stopping rules and return list — h_unpack_stopit","text":"stopit_tree object simulate method","code":""},{"path":"https://roche.github.io/crmPack/reference/h_validate_combine_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Combining S4 Class Validation Results — h_validate_combine_results","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"simple helper function combines two outputs calls result() function placed slot Validate() reference class.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_validate_combine_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(v1, v2)"},{"path":"https://roche.github.io/crmPack/reference/h_validate_combine_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"v1 (logical character) output result() function Validate() reference class, combined v2. v2 (logical character) output result() function Validate() reference class, combined v1.","code":""},{"path":"https://roche.github.io/crmPack/reference/h_validate_combine_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(TRUE, \"some_message\") #> [1] \"some_message\""},{"path":"https://roche.github.io/crmPack/reference/h_validate_common_data_slots.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"Helper Function performing validation Common Data DataOrdinal","code":""},{"path":"https://roche.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"","code":"h_validate_common_data_slots(object)"},{"path":"https://roche.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"object (Data DataOrdinal) object validated","code":""},{"path":"https://roche.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"Validate object containing result validation","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a probability range — is.probRange","title":"Predicate checking for a probability range — is.probRange","text":"Predicate checking probability range","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a probability range — is.probRange","text":"","code":"is.probRange(x, bounds = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/is.probRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a probability range — is.probRange","text":"x object checked bounds whether include bounds 0 1 (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a probability range — is.probRange","text":"Returns TRUE x probability range","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a probability — is.probability","title":"Predicate checking for a probability — is.probability","text":"Predicate checking probability","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a probability — is.probability","text":"","code":"is.probability(x, bounds = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/is.probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a probability — is.probability","text":"x object checked bounds whether include bounds 0 1 (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/is.probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a probability — is.probability","text":"Returns TRUE x probability","code":""},{"path":"https://roche.github.io/crmPack/reference/is.range.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a numeric range — is.range","title":"Predicate checking for a numeric range — is.range","text":"Predicate checking numeric range","code":""},{"path":"https://roche.github.io/crmPack/reference/is.range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a numeric range — is.range","text":"","code":"is.range(x)"},{"path":"https://roche.github.io/crmPack/reference/is.range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a numeric range — is.range","text":"x object checked","code":""},{"path":"https://roche.github.io/crmPack/reference/is.range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a numeric range — is.range","text":"Returns TRUE x numeric range","code":""},{"path":"https://roche.github.io/crmPack/reference/is.wholenumber.html","id":null,"dir":"Reference","previous_headings":"","what":"checks for whole numbers (integers) — is.wholenumber","title":"checks for whole numbers (integers) — is.wholenumber","text":"checks whole numbers (integers)","code":""},{"path":"https://roche.github.io/crmPack/reference/is.wholenumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checks for whole numbers (integers) — is.wholenumber","text":"","code":"is.wholenumber(x, tol = .Machine$double.eps^0.5)"},{"path":"https://roche.github.io/crmPack/reference/is.wholenumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checks for whole numbers (integers) — is.wholenumber","text":"x numeric vector tol tolerance","code":""},{"path":"https://roche.github.io/crmPack/reference/is.wholenumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"checks for whole numbers (integers) — is.wholenumber","text":"TRUE FALSE element x","code":""},{"path":"https://roche.github.io/crmPack/reference/logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for logit function — logit","title":"Shorthand for logit function — logit","text":"Shorthand logit function","code":""},{"path":"https://roche.github.io/crmPack/reference/logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for logit function — logit","text":"","code":"logit(x)"},{"path":"https://roche.github.io/crmPack/reference/logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for logit function — logit","text":"x function argument","code":""},{"path":"https://roche.github.io/crmPack/reference/logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for logit function — logit","text":"logit(x)","code":""},{"path":"https://roche.github.io/crmPack/reference/match_within_tolerance.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for value matching with tolerance — match_within_tolerance","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"modified version match supports tolerance.","code":""},{"path":"https://roche.github.io/crmPack/reference/match_within_tolerance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"","code":"match_within_tolerance(x, table)"},{"path":"https://roche.github.io/crmPack/reference/match_within_tolerance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"x values matched table values matched ","code":""},{"path":"https://roche.github.io/crmPack/reference/match_within_tolerance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"vector length x empty vector table empty.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the Maximum Possible Next Dose — maxDose","title":"Determine the Maximum Possible Next Dose — maxDose","text":"function determines upper limit next dose based incrementsand data.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the Maximum Possible Next Dose — maxDose","text":"","code":"maxDose(increments, data, ...)  # S4 method for IncrementsRelative,Data maxDose(increments, data, ...)  # S4 method for IncrementsRelativeDLT,Data maxDose(increments, data, ...)  # S4 method for IncrementsRelativeDLTCurrent,Data maxDose(increments, data, ...)  # S4 method for IncrementsRelativeParts,DataParts maxDose(increments, data, ...)  # S4 method for IncrementsDoseLevels,Data maxDose(increments, data, ...)  # S4 method for IncrementsHSRBeta,Data maxDose(increments, data, ...)  # S4 method for IncrementsMin,Data maxDose(increments, data, ...)"},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the Maximum Possible Next Dose — maxDose","text":"increments (Increments) rule next best dose. data (Data) input data. ... additional arguments without method dispatch.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the Maximum Possible Next Dose — maxDose","text":"number, maximum possible next dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the Maximum Possible Next Dose — maxDose","text":"maxDose(increments = IncrementsRelative, data = Data): determine maximum possible next dose based relative increments. maxDose(increments = IncrementsRelativeDLT, data = Data): determine maximum possible next dose based relative increments determined DLTs far. maxDose(increments = IncrementsRelativeDLTCurrent, data = Data): determine maximum possible next dose based relative increments determined DLTs current cohort. maxDose(increments = IncrementsRelativeParts, data = DataParts): determine maximum possible next dose based relative increments well part 1 beginning part 2. maxDose(increments = IncrementsDoseLevels, data = Data): determine maximum possible next dose based number dose grid levels. , max dose determined one level equal : base dose level + level increment. base dose level level last dose grid level maximum dose applied, defined increments object. Find IncrementsDoseLevels. maxDose(increments = IncrementsHSRBeta, data = Data): determine maximum possible next dose escalation. maxDose(increments = IncrementsMin, data = Data): determine maximum possible next dose based multiple increment rules, taking minimum across individual increments.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxDose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the Maximum Possible Next Dose — maxDose","text":"","code":"# Example of usage for `IncrementsRelative` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:40) )  # Define a rule for dose increments which allows for: #  - doubling the dose if the last dose was below 20, #  - increasing the dose by 33% of the last dose, only if the last dose was #    above or equal to 20. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLT` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, seq(from = 10, to = 80, by = 2)) )  # Define a rule for dose increments which allows for: #  - doubling the dose if no DLTs were yet observed, #  - increasing the dose by 33% if 1 or 2 DLTs were already observed, #  - increasing the dose by 20% if at least 3 DLTs were already observed. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLTCurrent` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Define a rule for dose increments which allows for: #  - doubling the dose if no DLTs were observed in current (i.e. last) cohort, #  - only increasing the dose by 33% if 1 or 2 DLTs were observed in current cohort, #  - only increasing the dose by 20% if at least 3 DLTs were observed in current cohort. my_increments <- IncrementsRelativeDLTCurrent(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeParts` maxDose class.  # Create an object of class `DataParts`. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 10),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) )  my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 )  max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsDoseLevels` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 12, 12, 12, 16, 16, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1),   ID = 1:14,   cohort = c(1, 2, 3, 4, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:30) )  # In this first example we define a rule for dose increments which allows for # maximum skip one dose level, that is 2 dose levels higher than the last dose # given. my_increments_1 <- IncrementsDoseLevels(levels = 2, basis_level = \"last\")  # Based on the rule above, the maximum dose allowed is: max_dose_1 <- maxDose(my_increments_1, data = my_data)  # In this second example we define a rule for dose increments which allows for # maximum skip one dose level, that is 2 dose levels higher than the max dose # given. my_increments_2 <- IncrementsDoseLevels(levels = 2, basis_level = \"max\")  # Based on the rule above, the maximum dose allowed is: max_dose_2 <- maxDose(my_increments_2, data = my_data)  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8, 6, 6, 6),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8,       seq(from = 10, to = 80, by = 2)     ) ) #> Used default patient IDs!  # In this example we define a rule for dose increments that limits the further # dose escalation to doses below 6, because dose 6 is above the probability # toxicity threshold. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)  # Based on the rule above, we then calculate the maximum dose allowed. my_next_max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLTCurrent` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:80) )  # Here, we combine two different increment rules.  # The first rule allows for: #  - doubling the dose if no DLTs were observed at the current dose, #  - increasing the dose by 33% if 1 or 2 DLTs were observed at the current dose, #  - increasing the dose by 22% if 3 or more DLTs were observed. my_increments_1 <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # The second rule allows for: #  - doubling the dose if the current dose is <20, #  - increasing the dose by 33% if the current dose is >=20. my_increments_2 <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Finally, the maximum dose allowed is computed by taking the minimum dose from # the maximum doses computed by the two rules. my_increments <- IncrementsMin(   increments_list = list(my_increments_1, my_increments_2) ) max_dose <- maxDose(my_increments, my_data)"},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking maximum sizes.","code":""},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"maxSize(...)  # S4 method for CohortSize maxSize(...)"},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMax","code":""},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"maxSize(CohortSize): method combining cohort size rules taking maximum","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/maxSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the maximum of the sample sizes of # the single rules mySize <- maxSize(mySize1, mySize2)"},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining Posterior Samples for all Model Parameters — mcmc","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"function actually runs JAGS MCMC machinery produce posterior samples model parameters required derived values. generic function, customized versions may conveniently defined specific subclasses GeneralData, GeneralModel, McmcOptions input.","code":""},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"mcmc(data, model, options, ...)  # S4 method for GeneralData,GeneralModel,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointRW,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointBeta,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointEmax,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,OneParLogNormalPrior,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,OneParExpPrior,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for DataMixture,GeneralModel,McmcOptions mcmc(   data,   model,   options,   from_prior = data@nObs == 0L & data@nObsshare == 0L,   ... )  # S4 method for Data,LogisticIndepBeta,McmcOptions mcmc(data, model, options, ...)  # S4 method for DataDual,Effloglog,McmcOptions mcmc(data, model, options, ...)  # S4 method for DataDual,EffFlexi,McmcOptions mcmc(data, model, options, ...)"},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"data (GeneralData) input data. model (GeneralModel) input model. options (McmcOptions) MCMC options. ... used. from_prior (flag) sample prior ? Default TRUE number observations data 0. models might necessary specify manually though.","code":""},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"posterior samples, object class Samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"mcmc(data = GeneralData, model = GeneralModel, options = McmcOptions): Standard method uses JAGS. mcmc(data = GeneralData, model = DualEndpointRW, options = McmcOptions): Standard method uses JAGS. DualEndpointRW model, required least two (case random walk prior first order biomarker level) three doses grid. mcmc(data = GeneralData, model = DualEndpointBeta, options = McmcOptions): Standard method uses JAGS. DualEndpointBeta model, required value ref_dose_beta slot greater maximum dose grid. requirement comes definition beta function used model dose-biomarker relationship DualEndpointBeta model. requirement must least one dose grid. mcmc(data = GeneralData, model = DualEndpointEmax, options = McmcOptions): Standard method uses JAGS. DualEndpointEmax model, required least one dose grid. mcmc(data = GeneralData, model = OneParLogNormalPrior, options = McmcOptions): Standard method uses JAGS. OneParLogNormalPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = GeneralData, model = OneParExpPrior, options = McmcOptions): Standard method uses JAGS. OneParExpPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = DataMixture, model = GeneralModel, options = McmcOptions): Method DataMixture different from_prior default mcmc(data = Data, model = LogisticIndepBeta, options = McmcOptions): Obtain posterior samples model parameters based pseudo 'LogisticsIndepBeta' DLE model. joint prior posterior probability density function intercept \\(\\phi_1\\) (phi1) slope \\(\\phi_2\\) (phi2) given Whitehead Williamson (1998) TsuTakawa (1975). However, since asymptotically, joint posterior probability density bivariate normal use bivariate normal distribution generate posterior samples intercept slope parameters. prior samples intercept slope bivariate normal distribution mean covariance matrix given Whitehead Williamson (1998) used. mcmc(data = DataDual, model = Effloglog, options = McmcOptions): Obtain posterior samples model parameters Efficacy log log model. Given value \\(\\nu\\), precision efficacy responses, joint prior posterior probability intercept \\(\\theta_1\\) (theta1) slope \\(\\theta_2\\) (theta2) bivariate normal distribution.  \\(\\nu\\) (nu), precision efficacy responses either fixed value gamma distribution. gamma distribution used, samples nu first generated. mean nu samples used generate samples intercept slope parameters model mcmc(data = DataDual, model = EffFlexi, options = McmcOptions): Obtain posterior samples estimates Efficacy Flexible form. mcmc procedure based described Lang Brezger (2004) samples mean efficacy responses dose levels, samples sigma2 \\(sigma^2\\), variance efficacy response samples sigma2betaW \\(sigma^2_{beta_W}\\), variance random walk model generated. Please refer Lang Brezger (2004) procedures form joint prior posterior probability density mean efficacy responses. addition, sigma2 sigma2betaW can fixed inverse-gamma prior posterior distribution. Therefore, inverse gamma distribution(s) used, parameters distribution first updated samples sigma2 sigma2betaW generated using updated parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"type Random Number Generator (RNG) initial seed used JAGS taken options argument. initial values supplied (.e RNG kind seed slot options NA), generated automatically JAGS.","code":""},{"path":"https://roche.github.io/crmPack/reference/mcmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>    [1] -0.3992868033  0.7522440126  0.7522440126  0.7522440126  0.7522440126 #>    [6]  1.3978449323  1.3978449323  0.6075780698 -0.1660041161  0.1743389058 #>   [11] -0.3064759885 -0.4585478859 -0.4585478859 -1.2129605914 -1.2129605914 #>   [16] -1.2129605914  0.4073761505  0.4073761505  1.6704170931  1.6704170931 #>   [21]  0.8252279514  0.8288351869 -0.2949082676 -0.2949082676 -0.0094254432 #>   [26] -1.8299574161 -1.1014897339 -1.1014897339 -0.7813565564 -0.7813565564 #>   [31]  0.1038685659  0.2552086861 -0.8777875431 -0.8777875431 -0.8777875431 #>   [36] -0.8777875431  1.0428608752  1.0428608752  1.0428608752  1.0428608752 #>   [41]  1.0428608752  1.0428608752  1.0428608752 -0.7758855477 -0.7758855477 #>   [46] -0.7758855477 -0.7758855477 -0.5787009337  0.3804141298  0.3804141298 #>   [51] -0.2045432563 -0.2045432563 -0.1006608862 -0.1006608862 -0.1006608862 #>   [56] -0.1006608862 -0.1006608862 -0.1006608862 -2.1358893627 -1.4526232854 #>   [61] -1.0254990392 -0.7337196468 -0.7337196468 -0.2425027966 -0.2425027966 #>   [66] -1.2783243437 -1.2783243437 -0.7606363453 -0.7606363453  0.4318835877 #>   [71]  0.3522401731  0.3522401731  0.3522401731  0.3522401731  0.8824610018 #>   [76]  1.1643579318  1.1643579318 -1.0317815231 -1.3403179526 -1.3403179526 #>   [81] -1.3403179526 -0.1456065373 -0.1456065373 -0.1456065373 -0.2037360300 #>   [86] -0.2037360300  0.4054449946  0.4054449946  0.4054449946  0.4054449946 #>   [91]  0.1960529374  0.8255558317  0.8255558317  0.8255558317  0.8255558317 #>   [96] -1.4295342817  1.1774426407 -0.9930714003 -0.4839141469  0.5890067231 #>  [101]  0.5890067231  0.5890067231  0.5890067231  0.5890067231  0.5890067231 #>  [106]  0.1304746762  0.5863942754 -0.4459779403 -0.4459779403 -1.0542636262 #>  [111] -1.0542636262 -1.0542636262 -1.0542636262 -0.4666299012 -0.0106548741 #>  [116] -0.5944382440 -0.9820990812 -1.0586996904 -1.0586996904 -0.8170360044 #>  [121]  0.5807232995  0.5807232995  0.5807232995  0.5807232995  0.0408609965 #>  [126]  1.1295923349  1.1295923349  1.1295923349  1.1295923349  1.1295923349 #>  [131]  1.1295923349  1.1295923349  1.2542102514  1.2542102514  1.2542102514 #>  [136] -0.1889670181 -0.1889670181  1.1966409298  1.1966409298  1.1966409298 #>  [141] -0.3176499326 -0.3176499326 -0.3176499326 -0.5527007173 -0.5527007173 #>  [146]  0.7948462029  0.0281071277 -0.8789601215 -1.3185357393 -2.0778108425 #>  [151] -1.9029290493 -2.1005181782 -1.9201386149 -1.9201386149 -1.9201386149 #>  [156]  0.4412610262 -0.5036494576 -0.1723838768 -0.1723838768 -0.2607350606 #>  [161] -0.2607350606 -0.2607350606 -0.2607350606  0.3567118826  0.3567118826 #>  [166]  0.3567118826 -1.3114012902 -1.3114012902 -1.0431457589 -1.0431457589 #>  [171]  0.3852499833 -0.1264577167 -0.1264577167  0.1535984656  0.2655096628 #>  [176]  0.2655096628  0.2655096628  0.5876559597 -0.5839382534 -0.5839382534 #>  [181] -0.5839382534  0.4391059974  1.0401488735  1.2045955470  0.6271192925 #>  [186]  0.6271192925 -1.0830786647 -1.7405630438 -1.4604830196 -2.3683529133 #>  [191]  0.1578167979 -0.9035683713  0.5046901495  1.0999871611  1.0999871611 #>  [196]  1.3767512065  1.3767512065 -0.6892701794 -0.6892701794 -1.0090912545 #>  [201] -2.3488990651 -2.3488990651 -1.1612597103 -1.1803942652 -0.2447542052 #>  [206] -0.2447542052 -0.2447542052  0.4806369404  0.4289360762  0.4289360762 #>  [211]  0.9251763647 -0.0431084563 -0.8533145699 -0.2209850575 -0.2209850575 #>  [216] -0.2209850575 -0.2209850575 -0.2209850575 -0.2209850575 -0.2209850575 #>  [221] -1.3478496559 -1.3478496559  0.5321184814  0.5321184814  0.7143723464 #>  [226]  0.0305970588  0.0305970588  0.6299199313  0.6299199313 -0.3367235213 #>  [231]  0.0160952846 -0.2511704027 -0.2511704027 -0.4766787294 -0.3396730081 #>  [236] -1.1768177250 -1.1768177250 -1.1768177250 -0.6488555013 -0.6488555013 #>  [241] -0.6488555013 -0.6488555013  1.1750951571 -0.4852548675 -0.2577280629 #>  [246] -0.3109030889 -0.3109030889 -0.3109030889 -0.3109030889  0.5744096856 #>  [251]  0.5744096856 -1.2822967410 -1.3388461868 -1.9236931297 -1.9236931297 #>  [256] -1.9236931297 -0.7309661086 -0.7309661086 -0.7791256073 -0.7791256073 #>  [261]  0.0209034739  0.0209034739  0.0209034739  0.0209034739  0.0209034739 #>  [266]  0.0209034739 -0.0547513094 -0.0547513094 -0.0547513094 -0.0547513094 #>  [271]  0.7761695121  0.2786681095  0.2786681095  0.2786681095  0.2786681095 #>  [276]  0.8040274860  0.8040274860 -0.6588570873 -2.1828853093 -2.3108076775 #>  [281] -1.3277400698 -1.3277400698  0.1709672941 -0.0030927645 -0.0030927645 #>  [286] -0.2664095836 -0.2664095836  1.2047415023  0.4629923294  1.0494906663 #>  [291]  1.0494906663  0.6870612809 -0.1429253092 -0.1429253092 -0.1429253092 #>  [296]  0.1211673871  0.1211673871  1.5298023245  1.5298023245  0.4289262523 #>  [301] -1.5603080475 -1.7085436510 -1.7085436510 -1.7085436510 -1.7085436510 #>  [306] -1.7085436510 -1.7085436510 -0.4802123337 -0.4802123337  0.7068613446 #>  [311]  0.7068613446 -0.2601090725 -0.9008804459 -0.6807339956 -0.3654018003 #>  [316]  1.1170392553  1.1170392553  1.6483874815  1.6483874815  1.1487372475 #>  [321]  1.3148013532  0.4624744963  0.4624744963 -0.9064956728  0.1404193706 #>  [326]  0.1404193706  0.1404193706  0.1404193706  0.1952676973  0.1588002831 #>  [331] -0.3132264357 -0.0136154922  1.0331500701  0.2208747601 -1.1912890712 #>  [336] -0.5738146940  0.4010550278  0.4010550278  0.8130074362 -0.1758362470 #>  [341] -0.1758362470 -0.1758362470 -0.1758362470  0.4324078279  0.4324078279 #>  [346] -0.2701040515 -0.5838270184  1.1817341319  1.0584440181  1.5534155096 #>  [351]  0.2414286337  0.2414286337 -0.1395065080 -1.1502169802 -1.1502169802 #>  [356] -1.7105802034 -1.7105802034 -1.7105802034 -1.7105802034 -1.4271375324 #>  [361] -0.6374841627 -0.9504856154 -0.9504856154 -0.2106079534 -0.2106079534 #>  [366] -1.8547287829 -1.8547287829 -1.8547287829  0.2609678130  0.5612780942 #>  [371]  0.4328036998  0.4328036998  0.4328036998 -0.3015231342 -0.3015231342 #>  [376] -0.3015231342 -1.0291854338 -0.3727554690 -0.3727554690 -0.3727554690 #>  [381] -0.3727554690 -0.3727554690 -0.3727554690 -0.3727554690 -0.3727554690 #>  [386] -0.3727554690 -0.1534020098  0.5684120259  0.5684120259  0.5684120259 #>  [391]  0.5684120259  0.5684120259  0.5684120259  0.9094214151 -0.1936648978 #>  [396] -0.2209388019 -0.2209388019  0.4160949456  0.4160949456  0.4160949456 #>  [401]  0.4160949456  0.2282947714  0.2282947714 -0.8270725209 -0.8270725209 #>  [406] -0.8270725209 -0.8270725209 -0.1661486991 -0.1661486991 -0.1661486991 #>  [411] -0.1661486991 -0.1661486991 -0.1661486991 -0.1661486991 -0.7055660423 #>  [416] -0.7055660423 -0.5277096159 -0.5277096159 -0.5277096159 -0.5277096159 #>  [421] -0.5277096159  0.2829933170  0.2829933170  0.2829933170  0.2829933170 #>  [426]  0.2829933170 -0.1890892119  0.5842403367  0.5842403367 -0.5551639661 #>  [431] -0.7654550450 -0.2694963243 -0.2694963243  0.3804686148  0.1486344836 #>  [436]  0.1486344836  0.1486344836  0.1486344836  0.2784658151  0.3557370242 #>  [441]  0.3557370242 -0.3309836079  0.2224452776  0.2224452776  0.2224452776 #>  [446]  0.2224452776 -1.2533209658 -0.2679621681  0.2512512510  0.9044388500 #>  [451] -0.5213756336 -1.0024280878 -1.0024280878  1.0192016420  1.0192016420 #>  [456]  1.0192016420  1.0192016420  1.0192016420  1.0192016420  0.4423326954 #>  [461]  0.4423326954 -0.6459561360 -0.6459561360  1.1306613218  0.5323431740 #>  [466]  0.5323431740  0.5323431740  0.5323431740  0.5323431740  0.5323431740 #>  [471]  0.5323431740  0.5323431740  0.5323431740  0.5323431740  0.5323431740 #>  [476]  1.1854675700  1.2151396407  1.2151396407  0.5997679688  0.7663416797 #>  [481] -0.1660281003  0.0829927952  0.0829927952 -0.0003840898 -0.0003840898 #>  [486] -0.0003840898 -0.0003840898 -0.0003840898 -0.0003840898  0.2749810563 #>  [491] -0.9712514581 -0.9712514581  1.1007516903  0.8456961846  0.2090991558 #>  [496]  0.2090991558  0.2701875094 -0.6585981847 -0.6585981847 -0.1348336984 #>  [501] -0.1348336984 -0.2078490655 -0.2078490655 -0.2078490655 -1.4854047598 #>  [506]  0.6631128121  0.8993248355  0.7059729822  0.7059729822  0.7059729822 #>  [511]  0.7059729822  0.8834527942  0.8834527942  0.8834527942  0.8834527942 #>  [516]  0.2011616039  0.1885236196 -0.3935739648 -0.3935739648  0.9245962660 #>  [521]  0.9245962660  1.1096245970  0.4690329117  0.4690329117  0.4690329117 #>  [526]  0.4690329117  0.4690329117  0.4690329117 -0.6383166941 -0.6383166941 #>  [531]  0.3507689115  0.3507689115  0.3507689115 -0.1376519562 -0.9571281721 #>  [536] -0.9571281721 -0.9571281721  0.5550254663  0.5550254663  0.5550254663 #>  [541]  0.5550254663  0.1172379854  0.1172379854 -0.6087263358 -0.1611633995 #>  [546]  0.0120176897  0.1317199140 -0.2488927917 -1.4202919481 -1.4202919481 #>  [551] -1.4202919481 -0.5206495957 -1.6378368790 -1.4635595981 -1.4635595981 #>  [556] -1.4635595981 -1.4635595981 -1.4635595981 -1.3686465174 -0.8117285789 #>  [561] -0.8117285789 -0.8117285789 -0.8117285789 -0.9263900273 -0.6101872811 #>  [566] -0.7100628229 -0.7100628229 -0.7100628229 -0.7100628229 -0.7100628229 #>  [571] -0.7100628229 -0.3465189603 -0.3465189603 -0.3465189603  0.6574207941 #>  [576]  0.6574207941  0.6574207941  0.6574207941  0.6574207941  0.6574207941 #>  [581]  0.6574207941  0.4648028755  0.4648028755  0.4648028755  0.7076409352 #>  [586]  0.7076409352  0.7076409352  0.7076409352 -0.2166630795 -0.2166630795 #>  [591] -0.2166630795 -0.2557246426 -0.2557246426  0.8486611289  0.8486611289 #>  [596]  0.8486611289  0.8486611289  0.4697584877  0.5178531095 -0.1982657147 #>  [601] -0.1982657147 -0.1982657147 -0.2271892390  0.6949790614 -2.3880765035 #>  [606] -1.3804708675 -0.4745184474 -0.4745184474 -0.6233457878 -0.6233457878 #>  [611] -0.6233457878 -0.4057121402 -0.4057121402 -0.4057121402  1.0772258386 #>  [616]  1.0772258386  0.6325784648  0.6325784648 -0.4250832410 -1.9850807679 #>  [621] -0.9064405490 -0.8369931885 -0.8369931885 -0.8369931885 -0.5942696815 #>  [626]  0.8497275271  0.8497275271  0.8497275271  0.8497275271  0.8497275271 #>  [631] -0.3826110361  0.5357301428 -0.7800487588 -0.7800487588 -0.7800487588 #>  [636] -0.7800487588  1.0627880547  0.4617988561  0.4617988561  0.9732458249 #>  [641] -0.0586247274  0.6358937681  0.6473512769  0.6473512769 -0.0450303277 #>  [646] -0.0450303277  0.7210444194  0.2284815919  0.1588965204  0.1588965204 #>  [651] -0.2058106958 -0.2058106958 -0.2058106958  0.0903560518  0.0903560518 #>  [656]  0.0903560518  0.0903560518  0.0903560518  0.3780546454  0.3123731800 #>  [661]  0.3123731800  0.3123731800  0.3123731800  0.3123731800  0.3123731800 #>  [666] -0.0260619683 -0.0260619683 -0.0260619683 -0.0260619683  0.3593466123 #>  [671]  0.3593466123  0.3593466123  0.3593466123 -0.0740301426  0.7251356481 #>  [676] -1.1284658079 -1.1284658079 -1.1284658079 -0.6488058031 -0.6488058031 #>  [681] -0.6488058031 -0.6488058031 -0.0204106476 -1.0285456461 -1.0285456461 #>  [686] -0.1141352340 -0.1141352340 -0.1141352340 -1.1829904594 -1.1829904594 #>  [691] -0.3976523135  0.5676668284  0.5676668284  0.4626074525 -0.4423977188 #>  [696] -0.4423977188 -0.9167863082  0.8519377541  0.4170783065  0.7213065072 #>  [701]  0.4440579887  0.3266620527 -0.3869839264 -1.0396214847 -1.0396214847 #>  [706] -1.9478470551 -0.6844471372 -0.3361673127 -0.8498185036  0.3578667070 #>  [711] -0.4000851769 -0.4000851769 -0.4000851769  0.2362904302 -1.6916679697 #>  [716] -0.1106210410  0.1339658151 -1.1115773842  0.3228527628  0.7215803300 #>  [721] -0.4353479403 -0.4353479403  0.9526136418  0.9526136418  0.9526136418 #>  [726]  0.9526136418 -0.3982210022 -0.3982210022 -0.3982210022 -0.3982210022 #>  [731] -0.3982210022  0.3031821059  0.3031821059 -0.4361609140 -0.4361609140 #>  [736] -0.2862824869  1.9553304786  0.2082109869  0.2082109869  0.3570613053 #>  [741]  0.3570613053  0.3570613053 -0.0213562089 -0.0213562089  0.9775577914 #>  [746]  0.2794084377  0.5818626298  0.0161418788  0.0161418788 -0.0046525962 #>  [751] -0.7856610403 -0.3956799244 -0.3956799244  0.1088078730  0.1204559595 #>  [756]  0.1204559595 -0.9829144520 -0.9829144520 -0.9829144520 -0.9829144520 #>  [761] -0.4601141613 -0.4601141613 -1.2027020250 -1.0631909681 -1.0631909681 #>  [766] -1.0631909681 -1.0631909681  0.5233464730 -0.9708282096  0.4814832802 #>  [771]  0.4814832802  0.4814832802  0.4814832802 -0.0734662480 -0.0734662480 #>  [776] -0.2953659968 -0.4649898458 -0.1955489277 -0.5281806183 -0.5281806183 #>  [781]  0.9436687475  0.9436687475  0.9436687475  1.2260146843  1.2260146843 #>  [786] -0.9547939429 -0.9547939429 -0.8746904994  0.0523863166 -0.2258742359 #>  [791] -0.2258742359 -0.2258742359  0.6738714270  0.6738714270  0.6738714270 #>  [796]  0.6738714270  0.9473384784 -0.1546377832 -0.1546377832  0.2091962200 #>  [801] -0.6640313002 -0.6640313002 -0.6640313002 -0.3825388321 -0.3825388321 #>  [806] -0.2651325390 -0.2651325390  0.6746886597  0.0983521532  0.0983521532 #>  [811] -0.6621044742 -0.5835881315  0.4441052467  0.3929467768  0.3929467768 #>  [816]  0.3929467768  0.3929467768  1.3165401619  0.1320650831  0.1320650831 #>  [821]  0.1320650831  0.1320650831 -0.1352466379 -0.1352466379 -0.1352466379 #>  [826] -0.1352466379 -0.7183874583  0.4724574511  0.0360902542  0.0360902542 #>  [831]  0.9913150406  0.9913150406  0.3608475683 -0.0925320650 -0.0925320650 #>  [836] -0.0925320650  0.6880935456  0.6880935456 -0.0847554290 -0.8798578558 #>  [841] -1.0641003292 -1.0641003292 -0.5505918172 -0.0428078790 -0.0428078790 #>  [846] -0.0428078790 -0.0428078790 -0.0428078790 -0.0428078790  0.4815783599 #>  [851]  0.6273698371  0.6273698371  0.8351164311  0.8351164311  0.8351164311 #>  [856]  0.8351164311  0.8351164311  0.8776470177  0.6315100504  0.6386970614 #>  [861] -0.6412410088 -0.6412410088  0.8399925749  0.6706390364  0.6706390364 #>  [866]  0.7713059803  0.7713059803  0.7713059803 -1.6975136320 -1.6975136320 #>  [871] -0.9410080067 -0.9410080067 -0.9410080067  0.2748637604 -0.1316853362 #>  [876] -0.1316853362 -0.1316853362 -0.1316853362 -0.3394066798 -0.0646859992 #>  [881] -0.0646859992 -0.7874282089 -0.7874282089 -0.7874282089  0.8838522716 #>  [886]  0.8838522716  0.8838522716  0.8838522716  1.3332533118  1.3332533118 #>  [891]  1.3332533118 -0.3415583618 -0.3415583618  0.0879686851  0.0879686851 #>  [896]  0.0879686851  0.0879686851  0.0879686851  0.0879686851  0.0879686851 #>  [901]  0.0879686851 -0.6062088349 -0.6062088349 -0.6062088349 -0.6062088349 #>  [906] -0.6062088349  0.3189312853  0.3189312853  0.6128602660 -0.1480603342 #>  [911] -0.1480603342 -0.1480603342 -0.7110921383  0.0328380273  0.9102776917 #>  [916] -0.0938798008 -0.0938798008 -0.3157939135 -0.3157939135 -0.3157939135 #>  [921] -0.7829743333 -2.0893436094 -2.0369754619 -2.0369754619 -0.6408623167 #>  [926] -0.6408623167 -0.6408623167 -0.6408623167 -0.7540635464 -1.1369771405 #>  [931] -0.5917978847  0.1394884844 -0.1636361395 -0.1636361395 -0.1636361395 #>  [936] -0.1636361395 -0.1636361395 -0.1636361395 -0.1636361395 -0.5733552302 #>  [941] -0.5733552302 -0.5997475084  0.5494097297  0.5494097297 -0.7214735754 #>  [946] -0.7214735754 -0.7045862150 -0.8466951308 -0.8466951308 -1.1485582030 #>  [951] -1.1522369862 -1.8629973439 -1.8629973439 -1.3365997102  0.0270001520 #>  [956]  0.0270001520  0.0270001520  0.0270001520  0.0270001520  0.0270001520 #>  [961] -1.2766258343  0.9883626782  0.7414498049  1.3552222089  0.3179234347 #>  [966]  0.3179234347  0.3179234347  0.9947202152  1.1581441424  1.6651216267 #>  [971]  0.4273661780  0.8916021419  0.3498549805  0.3498549805  0.3498549805 #>  [976] -0.4881737754 -0.4881737754 -0.7682685932 -0.8121019317 -1.4880907633 #>  [981]  0.0787974181  0.4505004088  0.4505004088  0.4505004088 -0.1223146121 #>  [986] -1.2563188846 -1.3296937885 -1.1046837180 -1.1046837180 -0.1272792277 #>  [991] -0.2174563629 -0.2174563629 -0.2174563629 -0.2174563629 -0.2174563629 #>  [996] -0.2174563629  0.1752338420 -1.1460395061 -0.0250644744 -0.0250644744 #>  #> $alpha1 #>    [1] 2.3110765 1.1293389 1.1293389 1.1293389 1.1293389 1.0785746 1.0785746 #>    [8] 0.3149643 0.2982701 0.3463586 0.6804174 0.4610008 0.4610008 1.3484157 #>   [15] 1.3484157 1.3484157 1.9628130 1.9628130 1.8508839 1.8508839 1.3182082 #>   [22] 1.3547115 2.0670005 2.0670005 0.7259399 0.8065621 1.0362026 1.0362026 #>   [29] 1.2232082 1.2232082 2.1008888 2.5619614 0.5323142 0.5323142 0.5323142 #>   [36] 0.5323142 1.6471563 1.6471563 1.6471563 1.6471563 1.6471563 1.6471563 #>   [43] 1.6471563 1.6294787 1.6294787 1.6294787 1.6294787 0.5578764 0.7560780 #>   [50] 0.7560780 0.3473060 0.3473060 1.8321080 1.8321080 1.8321080 1.8321080 #>   [57] 1.8321080 1.8321080 1.8907646 0.3105985 0.3770289 0.8135098 0.8135098 #>   [64] 0.7474393 0.7474393 0.3767464 0.3767464 1.2108768 1.2108768 0.6318318 #>   [71] 0.7301023 0.7301023 0.7301023 0.7301023 1.2009161 1.8733472 1.8733472 #>   [78] 0.7216029 0.9863344 0.9863344 0.9863344 1.0685672 1.0685672 1.0685672 #>   [85] 0.6797623 0.6797623 0.5079344 0.5079344 0.5079344 0.5079344 0.4302860 #>   [92] 0.4613903 0.4613903 0.4613903 0.4613903 1.5511582 1.9118667 1.8365179 #>   [99] 0.4333588 0.6972213 0.6972213 0.6972213 0.6972213 0.6972213 0.6972213 #>  [106] 0.7172740 1.3553588 0.5866937 0.5866937 0.4483365 0.4483365 0.4483365 #>  [113] 0.4483365 2.0807011 0.3313967 2.8080894 2.0207957 1.1797799 1.1797799 #>  [120] 0.7899592 0.9551049 0.9551049 0.9551049 0.9551049 0.7407313 1.9518218 #>  [127] 1.9518218 1.9518218 1.9518218 1.9518218 1.9518218 1.9518218 1.4839418 #>  [134] 1.4839418 1.4839418 0.9899645 0.9899645 2.0848982 2.0848982 2.0848982 #>  [141] 0.9430058 0.9430058 0.9430058 0.8888358 0.8888358 0.5029910 0.6208719 #>  [148] 0.8155641 0.5718696 0.9015869 1.3774550 2.5621598 1.8867323 1.8867323 #>  [155] 1.8867323 1.5898783 1.0928530 0.4258280 0.4258280 1.4880928 1.4880928 #>  [162] 1.4880928 1.4880928 0.7196916 0.7196916 0.7196916 1.4381434 1.4381434 #>  [169] 1.4545272 1.4545272 0.5352659 1.0206795 1.0206795 0.9064135 0.7517440 #>  [176] 0.7517440 0.7517440 0.7372394 0.8515410 0.8515410 0.8515410 2.0681101 #>  [183] 3.0901608 0.9611224 0.6937254 0.6937254 0.3858361 0.7175562 0.5060997 #>  [190] 1.2350645 1.0682147 0.4435531 0.4851254 1.2166046 1.2166046 1.8579820 #>  [197] 1.8579820 0.6038385 0.6038385 0.2416298 0.5243054 0.5243054 0.3371547 #>  [204] 0.4538457 1.9179078 1.9179078 1.9179078 1.2643519 0.1675808 0.1675808 #>  [211] 0.8833616 1.0863541 0.6512740 0.9010977 0.9010977 0.9010977 0.9010977 #>  [218] 0.9010977 0.9010977 0.9010977 2.3722930 2.3722930 0.2637305 0.2637305 #>  [225] 0.5546967 2.2990379 2.2990379 0.9263585 0.9263585 0.4602512 0.9221524 #>  [232] 1.2952299 1.2952299 1.2563738 2.1922341 1.7387313 1.7387313 1.7387313 #>  [239] 1.6809334 1.6809334 1.6809334 1.6809334 0.6837916 0.1749100 0.6512605 #>  [246] 1.0855023 1.0855023 1.0855023 1.0855023 1.5270446 1.5270446 2.7056384 #>  [253] 3.9782501 0.9013006 0.9013006 0.9013006 2.0067997 2.0067997 0.8781400 #>  [260] 0.8781400 1.6335752 1.6335752 1.6335752 1.6335752 1.6335752 1.6335752 #>  [267] 1.2792111 1.2792111 1.2792111 1.2792111 1.1660887 0.9259895 0.9259895 #>  [274] 0.9259895 0.9259895 0.9799968 0.9799968 0.7600165 1.5553000 0.8879660 #>  [281] 3.2063556 3.2063556 2.5494794 0.8923481 0.8923481 1.0430780 1.0430780 #>  [288] 2.0499004 1.5056253 1.2485146 1.2485146 0.8948140 1.6283033 1.6283033 #>  [295] 1.6283033 0.3647935 0.3647935 1.3695632 1.3695632 0.4188593 2.3002375 #>  [302] 0.5936879 0.5936879 0.5936879 0.5936879 0.5936879 0.5936879 0.3239624 #>  [309] 0.3239624 0.5962294 0.5962294 0.4372719 0.3922072 0.4923351 0.5601873 #>  [316] 0.8972632 0.8972632 0.9717951 0.9717951 2.1544272 1.5511495 0.5504503 #>  [323] 0.5504503 1.5115916 1.0608088 1.0608088 1.0608088 1.0608088 1.5683626 #>  [330] 0.7728512 1.3448030 0.9318547 1.3067647 0.5441477 0.4326224 0.4302851 #>  [337] 1.0263499 1.0263499 1.0859010 0.8212145 0.8212145 0.8212145 0.8212145 #>  [344] 1.0111716 1.0111716 0.8635717 1.6107046 0.7945784 0.4489032 1.5827376 #>  [351] 1.0523694 1.0523694 0.6383982 0.7069985 0.7069985 0.8677258 0.8677258 #>  [358] 0.8677258 0.8677258 1.0369254 1.4656155 0.7909815 0.7909815 1.2252896 #>  [365] 1.2252896 2.0465508 2.0465508 2.0465508 1.6785236 2.2435779 2.1058363 #>  [372] 2.1058363 2.1058363 0.3768842 0.3768842 0.3768842 0.9291130 1.4339857 #>  [379] 1.4339857 1.4339857 1.4339857 1.4339857 1.4339857 1.4339857 1.4339857 #>  [386] 1.4339857 0.6491093 0.8605047 0.8605047 0.8605047 0.8605047 0.8605047 #>  [393] 0.8605047 1.0899763 0.6502603 1.3746337 1.3746337 0.5457858 0.5457858 #>  [400] 0.5457858 0.5457858 2.2480627 2.2480627 1.4955732 1.4955732 1.4955732 #>  [407] 1.4955732 1.6832070 1.6832070 1.6832070 1.6832070 1.6832070 1.6832070 #>  [414] 1.6832070 1.0350008 1.0350008 0.5033132 0.5033132 0.5033132 0.5033132 #>  [421] 0.5033132 1.6510535 1.6510535 1.6510535 1.6510535 1.6510535 1.8618338 #>  [428] 1.0658664 1.0658664 0.6580026 0.7635472 1.9337427 1.9337427 1.4548456 #>  [435] 0.9292897 0.9292897 0.9292897 0.9292897 0.5965641 1.3931778 1.3931778 #>  [442] 0.8046718 0.6214278 0.6214278 0.6214278 0.6214278 2.1915141 2.8772804 #>  [449] 1.7996556 0.6901862 0.5316441 1.7542479 1.7542479 1.4938161 1.4938161 #>  [456] 1.4938161 1.4938161 1.4938161 1.4938161 3.1510688 3.1510688 3.6278951 #>  [463] 3.6278951 1.2849030 1.2613219 1.2613219 1.2613219 1.2613219 1.2613219 #>  [470] 1.2613219 1.2613219 1.2613219 1.2613219 1.2613219 1.2613219 1.1319172 #>  [477] 1.5953609 1.5953609 1.6090377 0.9783644 0.6358298 0.5606433 0.5606433 #>  [484] 0.8647416 0.8647416 0.8647416 0.8647416 0.8647416 0.8647416 1.7153083 #>  [491] 0.7439811 0.7439811 1.7176887 2.1127143 0.8230677 0.8230677 0.8329194 #>  [498] 0.9244145 0.9244145 1.3746731 1.3746731 0.7684758 0.7684758 0.7684758 #>  [505] 1.0025826 1.7674907 1.6898770 0.7625910 0.7625910 0.7625910 0.7625910 #>  [512] 2.1578664 2.1578664 2.1578664 2.1578664 2.7084835 2.5692173 2.0272690 #>  [519] 2.0272690 0.9993211 0.9993211 1.6254877 1.7428845 1.7428845 1.7428845 #>  [526] 1.7428845 1.7428845 1.7428845 0.9022752 0.9022752 0.4579014 0.4579014 #>  [533] 0.4579014 2.2643061 1.4780739 1.4780739 1.4780739 1.5688654 1.5688654 #>  [540] 1.5688654 1.5688654 0.9213857 0.9213857 1.0907800 1.7701880 1.4697881 #>  [547] 0.9458210 0.6292381 0.8254815 0.8254815 0.8254815 0.2411813 1.9606970 #>  [554] 1.7265373 1.7265373 1.7265373 1.7265373 1.7265373 1.4249504 1.0507423 #>  [561] 1.0507423 1.0507423 1.0507423 0.4800806 2.5449331 1.0158351 1.0158351 #>  [568] 1.0158351 1.0158351 1.0158351 1.0158351 0.6684721 0.6684721 0.6684721 #>  [575] 1.2351494 1.2351494 1.2351494 1.2351494 1.2351494 1.2351494 1.2351494 #>  [582] 1.2363512 1.2363512 1.2363512 0.9334212 0.9334212 0.9334212 0.9334212 #>  [589] 1.4800351 1.4800351 1.4800351 0.8085674 0.8085674 1.2021579 1.2021579 #>  [596] 1.2021579 1.2021579 1.8694787 0.9806608 1.4955213 1.4955213 1.4955213 #>  [603] 1.4598410 1.4796871 0.9521744 0.6497345 1.2830009 1.2830009 0.6116915 #>  [610] 0.6116915 0.6116915 1.5816072 1.5816072 1.5816072 1.8418716 1.8418716 #>  [617] 1.4077331 1.4077331 0.3432684 1.9112012 1.2488995 2.8405605 2.8405605 #>  [624] 2.8405605 0.2182008 1.3875334 1.3875334 1.3875334 1.3875334 1.3875334 #>  [631] 0.7793298 0.6108930 0.5206291 0.5206291 0.5206291 0.5206291 1.3858955 #>  [638] 2.3403820 2.3403820 2.1198833 0.3499554 0.9254895 0.7327568 0.7327568 #>  [645] 0.8530757 0.8530757 0.7788803 0.5526105 1.4907598 1.4907598 0.8599740 #>  [652] 0.8599740 0.8599740 1.2780898 1.2780898 1.2780898 1.2780898 1.2780898 #>  [659] 1.1347987 0.8688321 0.8688321 0.8688321 0.8688321 0.8688321 0.8688321 #>  [666] 1.5434867 1.5434867 1.5434867 1.5434867 0.8427273 0.8427273 0.8427273 #>  [673] 0.8427273 1.5320426 1.7337262 0.9220706 0.9220706 0.9220706 0.6660768 #>  [680] 0.6660768 0.6660768 0.6660768 0.8553058 0.7744341 0.7744341 0.9233934 #>  [687] 0.9233934 0.9233934 1.3771155 1.3771155 2.0575068 1.2131173 1.2131173 #>  [694] 0.6095854 2.4184261 2.4184261 0.4350002 1.5699180 1.9278166 0.8217234 #>  [701] 0.5814663 0.9938842 0.8355629 0.3799618 0.3799618 1.3466898 0.3193781 #>  [708] 0.2546054 0.5171033 1.0006401 0.6080660 0.6080660 0.6080660 0.7263501 #>  [715] 0.6096149 0.3262098 1.4957897 1.1222215 2.3317485 0.6634637 2.6363260 #>  [722] 2.6363260 2.3415997 2.3415997 2.3415997 2.3415997 1.0807485 1.0807485 #>  [729] 1.0807485 1.0807485 1.0807485 0.7920101 0.7920101 1.8778810 1.8778810 #>  [736] 0.4298774 1.1313657 0.4784123 0.4784123 0.8749690 0.8749690 0.8749690 #>  [743] 0.8215227 0.8215227 1.5925415 1.0758146 0.9917481 0.8217568 0.8217568 #>  [750] 0.4490691 0.7811448 3.3929208 3.3929208 0.7280828 1.7332096 1.7332096 #>  [757] 1.6075820 1.6075820 1.6075820 1.6075820 1.5500510 1.5500510 0.9374066 #>  [764] 2.1703809 2.1703809 2.1703809 2.1703809 1.4801177 1.4466315 1.2878165 #>  [771] 1.2878165 1.2878165 1.2878165 1.0942869 1.0942869 1.1357057 0.5270045 #>  [778] 0.8564553 0.8848933 0.8848933 0.3971092 0.3971092 0.3971092 1.6627841 #>  [785] 1.6627841 0.4991791 0.4991791 0.6239253 0.7994532 1.8203396 1.8203396 #>  [792] 1.8203396 0.9749116 0.9749116 0.9749116 0.9749116 1.1743714 0.4755010 #>  [799] 0.4755010 1.9120440 2.1094543 2.1094543 2.1094543 1.2150831 1.2150831 #>  [806] 1.2977335 1.2977335 0.8910294 1.6861739 1.6861739 1.1611009 0.6988374 #>  [813] 0.4569364 1.7135647 1.7135647 1.7135647 1.7135647 0.7623293 0.4405766 #>  [820] 0.4405766 0.4405766 0.4405766 1.5161223 1.5161223 1.5161223 1.5161223 #>  [827] 0.9376567 0.5337961 0.8387998 0.8387998 1.3174774 1.3174774 0.8795558 #>  [834] 1.2726796 1.2726796 1.2726796 0.8661024 0.8661024 0.3093511 0.7256640 #>  [841] 0.7805180 0.7805180 0.8698246 0.8703564 0.8703564 0.8703564 0.8703564 #>  [848] 0.8703564 0.8703564 0.6357471 1.1924036 1.1924036 0.9024243 0.9024243 #>  [855] 0.9024243 0.9024243 0.9024243 2.3688518 2.5115352 1.0558792 2.4566635 #>  [862] 2.4566635 0.7383578 2.3132454 2.3132454 1.4142699 1.4142699 1.4142699 #>  [869] 2.8904634 2.8904634 0.8883888 0.8883888 0.8883888 1.0682408 0.9833473 #>  [876] 0.9833473 0.9833473 0.9833473 1.2802693 1.9290890 1.9290890 0.5225726 #>  [883] 0.5225726 0.5225726 1.2002457 1.2002457 1.2002457 1.2002457 0.9757406 #>  [890] 0.9757406 0.9757406 1.0309025 1.0309025 1.7850770 1.7850770 1.7850770 #>  [897] 1.7850770 1.7850770 1.7850770 1.7850770 1.7850770 0.6286924 0.6286924 #>  [904] 0.6286924 0.6286924 0.6286924 0.7401930 0.7401930 1.8508521 0.9676135 #>  [911] 0.9676135 0.9676135 1.8194890 1.5768108 0.7482528 1.0644028 1.0644028 #>  [918] 0.4745651 0.4745651 0.4745651 0.2558215 0.8765256 3.4552266 3.4552266 #>  [925] 1.1540016 1.1540016 1.1540016 1.1540016 0.4226684 0.7804465 0.6181595 #>  [932] 0.8414609 1.4460091 1.4460091 1.4460091 1.4460091 1.4460091 1.4460091 #>  [939] 1.4460091 0.3902483 0.3902483 0.6335941 1.1580527 1.1580527 0.3472517 #>  [946] 0.3472517 0.2878352 1.2829598 1.2829598 1.3616356 0.3943496 0.3751480 #>  [953] 0.3751480 0.3865535 0.8042479 0.8042479 0.8042479 0.8042479 0.8042479 #>  [960] 0.8042479 0.9871193 1.2975431 1.7375580 1.8206834 0.7689275 0.7689275 #>  [967] 0.7689275 1.1166066 0.7240324 1.0362574 2.4261613 0.5681874 1.2869802 #>  [974] 1.2869802 1.2869802 1.4464387 1.4464387 0.4840431 1.9509368 2.3587319 #>  [981] 1.0540499 1.1073944 1.1073944 1.1073944 0.6560438 1.8870590 0.6944503 #>  [988] 0.9724184 0.9724184 1.2051012 1.4817780 1.4817780 1.4817780 1.4817780 #>  [995] 1.4817780 1.4817780 0.7272530 0.7084919 1.3429577 1.3429577 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 2100 #>  #> Slot \"burnin\": #> [1] 100 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> [1,] 43.97979 44.41466 44.43972 44.11392 44.62213 45.16043 45.16812 45.21349 #> [2,] 43.15657 42.91989 43.51310 44.68803 44.56862 44.87953 44.94821 45.51928 #> [3,] 63.68104 63.29789 63.85898 64.05148 63.52357 64.10696 64.75609 65.32082 #> [4,] 50.45590 49.98192 49.94248 50.23495 50.54648 50.68016 51.02047 50.21193 #>          [,9]    [,10]    [,11]    [,12]    [,13] #> [1,] 45.17819 44.50411 44.97736 44.98087 45.22721 #> [2,] 45.87216 45.26223 45.42696 45.75288 45.95267 #> [3,] 65.62907 65.52253 66.59065 66.42558 66.77227 #> [4,] 50.02701 49.17010 49.01135 49.45278 49.73688 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -2.507907 0.03496807 #> [2,] -2.507907 0.03496807 #> [3,] -2.507907 0.03496807 #> [4,] -2.507907 0.03496807 #>  #> $delta #>            [,1]        [,2]       [,3]       [,4]      [,5]        [,6] #> [1,]  0.4348687  0.02505645 -0.3258029  0.5082169 0.5382963 0.007687938 #> [2,] -0.2366798  0.59321185  1.1749236 -0.1194105 0.3109172 0.068670722 #> [3,] -0.3831418  0.56109098  0.1924961 -0.5279107 0.5833939 0.649129673 #> [4,] -0.4739807 -0.03943816  0.2924624  0.3115307 0.1336790 0.340314130 #>             [,7]        [,8]       [,9]      [,10]        [,11]     [,12] #> [1,]  0.04537578 -0.03529845 -0.6740836  0.4732525  0.003504127 0.2463430 #> [2,]  0.57107036  0.35288467 -0.6099253  0.1647277  0.325915901 0.1997869 #> [3,]  0.56472919  0.30824406 -0.1065357  1.0681196 -0.165072414 0.3466892 #> [4,] -0.80854374 -0.18491804 -0.8569132 -0.1587477  0.441429357 0.2841035 #>  #> $precW #> [1] 0.0007380298 0.0009402290 0.0006374998 0.0006963610 #>  #> $rho #> [1] 0.1193680 0.1129187 0.2440825 0.1499421 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = diag(2),   ref_dose = 2,   use_log_dose = FALSE,   sigma2W = c(a = 1, b = 2),   rho = c(a = 1.5, b = 2.5),   E0 = 2,   Emax = 50,   delta1 = 6,   mode = 9,   ref_dose_beta = my_data@doseGrid[my_data@nGrid] + 10 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>      [,1]     [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [2,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [3,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [4,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -4.354759 0.09035452 #> [2,] -4.354759 0.09035452 #> [3,] -4.354759 0.09035452 #> [4,] -3.273111 0.08172139 #>  #> $precW #> [1] 0.0004229406 0.0004149886 0.0004264222 0.0003413195 #>  #> $rho #> [1] -0.5116824 -0.5902350 -0.5709147 -0.5230612 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  ##obtain mcmc DLE samples given the data, LogisticIndepBeta (DLE model) and mcmc simulations options ## data must be of 'Data' class data<-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(25,300,25)) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'LogisticIndepBeta' class model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## options must be ''McmcOptions' class options<-McmcOptions(burnin=100,step=2,samples=200) set.seed(94) samples<-mcmc(data=data,model=model,options=options) # nolint start ##obtain mcmc efficacy samples given the data, 'Effloglog' model (efficacy model) and ## mcmc simulations options data must be of 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),               y=c(0,0,0,0,0,1,1,0),               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),               doseGrid=seq(25,300,25),placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'Effloglog' class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data)  ## options must be ''McmcOptions' class options<-McmcOptions(burnin=100,step=2,samples=200) set.seed(94) samples<-mcmc(data=data,model=Effmodel,options=options) # nolint end ## obtain mcmc efficacy samples given the data, 'EffFlexi' model (efficacy model) and ## mcmc simulations options ## data must be of 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'EffFlexi' class  effmodel <- EffFlexi(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1), sigma2betaW = c(a = 20, b = 50), rw1 = FALSE, data = data )  ## options must be ''McmcOptions' class options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data = data, model = effmodel, options = options)"},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking minimum sizes.","code":""},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"minSize(...)  # S4 method for CohortSize minSize(...)"},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMin","code":""},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"minSize(CohortSize): method combining cohort size rules taking minimum","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/minSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the minimum of the sample sizes of # the single rules mySize <- minSize(mySize1, mySize2)"},{"path":"https://roche.github.io/crmPack/reference/myBayesLogit.html","id":null,"dir":"Reference","previous_headings":"","what":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"MCMC sampling Bayesian logistic regression model","code":""},{"path":"https://roche.github.io/crmPack/reference/myBayesLogit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"","code":"myBayesLogit(y, X, m0, P0, options)"},{"path":"https://roche.github.io/crmPack/reference/myBayesLogit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"y 0/1 vector responses X design matrix m0 prior mean vector P0 precision matrix options McmcOptions object","code":""},{"path":"https://roche.github.io/crmPack/reference/myBayesLogit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"matrix samples (samples x parameters)","code":""},{"path":"https://roche.github.io/crmPack/reference/names-Samples-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The Names of the Sampled Parameters — names,Samples-method","title":"The Names of the Sampled Parameters — names,Samples-method","text":"method returns names parameters sampled.","code":""},{"path":"https://roche.github.io/crmPack/reference/names-Samples-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"# S4 method for Samples names(x)"},{"path":"https://roche.github.io/crmPack/reference/names-Samples-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Names of the Sampled Parameters — names,Samples-method","text":"x (Samples) object samples.","code":""},{"path":"https://roche.github.io/crmPack/reference/names-Samples-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"my_samples <- Samples(   data = list(alpha = 1:5, beta = 15:19),   options = McmcOptions(burnin = 2, step = 2, samples = 5) )  names(my_samples) #> [1] \"alpha\" \"beta\""},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding the Next Best Dose — nextBest","title":"Finding the Next Best Dose — nextBest","text":"function computes recommended next best dose based corresponding rule nextBest, posterior samples model underlying data.","code":""},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding the Next Best Dose — nextBest","text":"","code":"nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for NextBestMTD,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRM,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRM,numeric,Samples,GeneralModel,DataParts nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRMLoss,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestThreePlusThree,missing,missing,missing,Data nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for NextBestDualEndpoint,numeric,Samples,DualEndpoint,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestMinDist,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestInfTheory,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestTD,numeric,missing,LogisticIndepBeta,Data nextBest(nextBest, doselimit = Inf, model, data, in_sim = FALSE, ...)  # S4 method for NextBestTDsamples,numeric,Samples,LogisticIndepBeta,Data nextBest(nextBest, doselimit = Inf, samples, model, data, in_sim, ...)  # S4 method for NextBestMaxGain,numeric,missing,ModelTox,DataDual nextBest(   nextBest,   doselimit = Inf,   model,   data,   model_eff,   in_sim = FALSE,   ... )  # S4 method for NextBestMaxGainSamples,numeric,Samples,ModelTox,DataDual nextBest(   nextBest,   doselimit = Inf,   samples,   model,   data,   model_eff,   samples_eff,   in_sim = FALSE,   ... )  # S4 method for NextBestProbMTDLTE,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for NextBestProbMTDMinDist,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit, samples, model, data, ...)"},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding the Next Best Dose — nextBest","text":"nextBest (NextBest) rule next best dose. doselimit (number) maximum allowed next dose. infinity (default), essentially dose limit applied course dose recommendation calculation. samples (Samples) posterior samples model parameters given data. model (ModelTox) DLT model. data (Data) data used generate samples. ... additional arguments without method dispatch. in_sim (flag) method used simulations? Default FALSE. flag TRUE target dose estimates (trial end--trial) outside dose grid range, information message printed method. model_eff (Effloglog EffFlexi) efficacy model. samples_eff (Samples) posterior samples model_eff parameters given data.","code":""},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding the Next Best Dose — nextBest","text":"list next best dose recommendation  (element named value) grid defined data, plot depicting recommendation (element named plot). case multiple plots also element named singlePlots included. singlePlots list single plots. additional list elements describing outcome rule can contained .","code":""},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Finding the Next Best Dose — nextBest","text":"nextBest(   nextBest = NextBestMTD,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based MTD rule. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method. additional element probs output's list contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = DataParts ): find next best dose based NCRM method two parts trial used. nextBest(   nextBest = NextBestNCRMLoss,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method loss function. nextBest(   nextBest = NextBestThreePlusThree,   doselimit = missing,   samples = missing,   model = missing,   data = Data ): find next best dose based 3+3 method. nextBest(   nextBest = NextBestDualEndpoint,   doselimit = numeric,   samples = Samples,   model = DualEndpoint,   data = Data ): find next best dose based dual endpoint model. additional list element probs contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestMinDist,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives dose dose limit estimated DLT probability closest target dose. nextBest(   nextBest = NextBestInfTheory,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives appropriate dose within information theoretic framework. nextBest(   nextBest = NextBestTD,   doselimit = numeric,   samples = missing,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object without DLT samples. nextBest(   nextBest = NextBestTDsamples,   doselimit = numeric,   samples = Samples,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object involving DLT samples. nextBest(   nextBest = NextBestMaxGain,   doselimit = numeric,   samples = missing,   model = ModelTox,   data = DataDual ): find next best dose based pseudo DLT model ModelTox Effloglog efficacy model without samples. nextBest(   nextBest = NextBestMaxGainSamples,   doselimit = numeric,   samples = Samples,   model = ModelTox,   data = DataDual ): find next best dose based DLT efficacy responses DLT efficacy samples. nextBest(   nextBest = NextBestProbMTDLTE,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based highest probability toxicity rate less equal target toxicity level. nextBest(   nextBest = NextBestProbMTDMinDist,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based highest probability toxicity rate minimum distance target toxicity level.","code":""},{"path":"https://roche.github.io/crmPack/reference/nextBest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding the Next Best Dose — nextBest","text":"","code":"# Example of usage for `NextBestMTD` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestMTD' class. mtd_next_best <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = mtd_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Example of usage for `NextBestNCRM` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.004    0.000 #>  [2,]  0.5  0.000    0.004 #>  [3,]  1.5  0.004    0.004 #>  [4,]  3.0  0.038    0.004 #>  [5,]  6.0  0.094    0.014 #>  [6,] 10.0  0.210    0.030 #>  [7,] 12.0  0.218    0.060 #>  [8,] 14.0  0.220    0.078 #>  [9,] 16.0  0.244    0.106 #> [10,] 18.0  0.252    0.132 #> [11,] 20.0  0.246    0.174 #> [12,] 22.0  0.264    0.208 #> [13,] 24.0  0.302    0.224 #> [14,] 26.0  0.308    0.254 #> [15,] 28.0  0.310    0.286 #> [16,] 30.0  0.298    0.318 #> [17,] 32.0  0.308    0.354 #> [18,] 34.0  0.322    0.378 #> [19,] 36.0  0.328    0.404 #> [20,] 38.0  0.340    0.440 #> [21,] 40.0  0.356    0.456 #> [22,] 42.0  0.346    0.490 #> [23,] 44.0  0.334    0.520 #> [24,] 46.0  0.324    0.542 #> [25,] 48.0  0.310    0.570 #> [26,] 50.0  0.286    0.600 #> [27,] 52.0  0.300    0.600 #> [28,] 54.0  0.298    0.618 #> [29,] 56.0  0.268    0.648 #> [30,] 58.0  0.258    0.682 #> [31,] 60.0  0.250    0.692 #> [32,] 62.0  0.230    0.714 #> [33,] 64.0  0.222    0.724 #> [34,] 66.0  0.234    0.728 #> [35,] 68.0  0.224    0.740 #> [36,] 70.0  0.218    0.752 #> [37,] 72.0  0.208    0.762 #> [38,] 74.0  0.194    0.780 #> [39,] 76.0  0.188    0.788 #> [40,] 78.0  0.184    0.792 #> [41,] 80.0  0.184    0.792  # Example of usage for `NextBestNCRM-DataParts` NextBest class.  # Create the data. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation #> $value #> [1] 3 #>  #> $plot #> NULL #>   # Example of usage for `NextBestNCRMLoss` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class `NextBestNCRMLoss`. nrcm_loss_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.999,   losses = c(1, 0, 1, 2) )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_loss_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation$value #> [1] 18  # Look at the probabilities. dose_recommendation$probs #>     dose underdosing target excessive unacceptable       mean    std_dev #> 0.1  0.1       0.998  0.002     0.000        0.000 0.01110542 0.02692436 #> 0.5  0.5       0.992  0.006     0.002        0.000 0.02398787 0.04235771 #> 1.5  1.5       0.974  0.022     0.004        0.000 0.04385533 0.05935649 #> 3    3.0       0.934  0.060     0.006        0.000 0.06661410 0.07450753 #> 6    6.0       0.844  0.134     0.022        0.000 0.10417453 0.09394320 #> 10  10.0       0.722  0.230     0.048        0.000 0.14719423 0.11075642 #> 12  12.0       0.658  0.262     0.080        0.000 0.16691555 0.11706315 #> 14  14.0       0.604  0.286     0.108        0.002 0.18573827 0.12241348 #> 16  16.0       0.528  0.336     0.132        0.004 0.20378376 0.12699454 #> 18  18.0       0.468  0.374     0.154        0.004 0.22113636 0.13093881 #> 20  20.0       0.434  0.374     0.180        0.012 0.23785772 0.13434649 #> 22  22.0       0.402  0.354     0.230        0.014 0.25399479 0.13729777 #> 24  24.0       0.362  0.346     0.274        0.018 0.26958440 0.13985968 #> 26  26.0       0.316  0.344     0.318        0.022 0.28465624 0.14208983 #> 28  28.0       0.276  0.376     0.324        0.024 0.29923483 0.14403852 #> 30  30.0       0.252  0.372     0.338        0.038 0.31334090 0.14574975 #> 32  32.0       0.204  0.372     0.376        0.048 0.32699242 0.14726192 #> 34  34.0       0.162  0.396     0.384        0.058 0.34020533 0.14860817 #> 36  36.0       0.146  0.408     0.382        0.064 0.35299411 0.14981685 #> 38  38.0       0.128  0.374     0.408        0.090 0.36537222 0.15091178 #> 40  40.0       0.118  0.366     0.418        0.098 0.37735237 0.15191277 #> 42  42.0       0.110  0.338     0.436        0.116 0.38894678 0.15283597 #> 44  44.0       0.098  0.324     0.448        0.130 0.40016732 0.15369441 #> 46  46.0       0.068  0.346     0.430        0.156 0.41102559 0.15449838 #> 48  48.0       0.068  0.304     0.440        0.188 0.42153304 0.15525594 #> 50  50.0       0.060  0.306     0.436        0.198 0.43170091 0.15597328 #> 52  52.0       0.058  0.276     0.446        0.220 0.44154034 0.15665512 #> 54  54.0       0.048  0.238     0.484        0.230 0.45106229 0.15730498 #> 56  56.0       0.038  0.216     0.512        0.234 0.46027758 0.15792551 #> 58  58.0       0.036  0.196     0.518        0.250 0.46919684 0.15851870 #> 60  60.0       0.034  0.182     0.526        0.258 0.47783050 0.15908599 #> 62  62.0       0.022  0.178     0.534        0.266 0.48618878 0.15962852 #> 64  64.0       0.022  0.154     0.558        0.266 0.49428166 0.16014713 #> 66  66.0       0.014  0.156     0.548        0.282 0.50211887 0.16064252 #> 68  68.0       0.014  0.144     0.548        0.294 0.50970987 0.16111526 #> 70  70.0       0.014  0.140     0.536        0.310 0.51706385 0.16156583 #> 72  72.0       0.012  0.138     0.524        0.326 0.52418974 0.16199468 #> 74  74.0       0.012  0.136     0.516        0.336 0.53109614 0.16240223 #> 76  76.0       0.012  0.126     0.516        0.346 0.53779140 0.16278886 #> 78  78.0       0.012  0.106     0.528        0.354 0.54428356 0.16315497 #> 80  80.0       0.006  0.104     0.522        0.368 0.55058037 0.16350095 #>     posterior_loss #> 0.1          0.998 #> 0.5          0.994 #> 1.5          0.978 #> 3            0.940 #> 6            0.866 #> 10           0.770 #> 12           0.738 #> 14           0.716 #> 16           0.668 #> 18           0.630 #> 20           0.638 #> 22           0.660 #> 24           0.672 #> 26           0.678 #> 28           0.648 #> 30           0.666 #> 32           0.676 #> 34           0.662 #> 36           0.656 #> 38           0.716 #> 40           0.732 #> 42           0.778 #> 44           0.806 #> 46           0.810 #> 48           0.884 #> 50           0.892 #> 52           0.944 #> 54           0.992 #> 56           1.018 #> 58           1.054 #> 60           1.076 #> 62           1.088 #> 64           1.112 #> 66           1.126 #> 68           1.150 #> 70           1.170 #> 72           1.188 #> 74           1.200 #> 76           1.220 #> 78           1.248 #> 80           1.264  # Define another rule (loss function of 3 elements). nrcm_loss_next_best_losses_3 <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.30,   losses = c(1, 0, 2) )  # Calculate the next best dose. dose_recommendation_losses_3 <- nextBest(   nextBest = nrcm_loss_next_best_losses_3,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation_losses_3$value #> [1] 18  # Look at the probabilities. dose_recommendation_losses_3$probs #>     dose underdosing target overdose       mean    std_dev posterior_loss #> 0.1  0.1       0.998  0.002    0.000 0.01110542 0.02692436          0.998 #> 0.5  0.5       0.992  0.006    0.002 0.02398787 0.04235771          0.996 #> 1.5  1.5       0.974  0.022    0.004 0.04385533 0.05935649          0.982 #> 3    3.0       0.934  0.060    0.006 0.06661410 0.07450753          0.946 #> 6    6.0       0.844  0.134    0.022 0.10417453 0.09394320          0.888 #> 10  10.0       0.722  0.230    0.048 0.14719423 0.11075642          0.818 #> 12  12.0       0.658  0.262    0.080 0.16691555 0.11706315          0.818 #> 14  14.0       0.604  0.286    0.110 0.18573827 0.12241348          0.824 #> 16  16.0       0.528  0.336    0.136 0.20378376 0.12699454          0.800 #> 18  18.0       0.468  0.374    0.158 0.22113636 0.13093881          0.784 #> 20  20.0       0.434  0.374    0.192 0.23785772 0.13434649          0.818 #> 22  22.0       0.402  0.354    0.244 0.25399479 0.13729777          0.890 #> 24  24.0       0.362  0.346    0.292 0.26958440 0.13985968          0.946 #> 26  26.0       0.316  0.344    0.340 0.28465624 0.14208983          0.996 #> 28  28.0       0.276  0.376    0.348 0.29923483 0.14403852          0.972 #> 30  30.0       0.252  0.372    0.376 0.31334090 0.14574975          1.004 #> 32  32.0       0.204  0.372    0.424 0.32699242 0.14726192          1.052 #> 34  34.0       0.162  0.396    0.442 0.34020533 0.14860817          1.046 #> 36  36.0       0.146  0.408    0.446 0.35299411 0.14981685          1.038 #> 38  38.0       0.128  0.374    0.498 0.36537222 0.15091178          1.124 #> 40  40.0       0.118  0.366    0.516 0.37735237 0.15191277          1.150 #> 42  42.0       0.110  0.338    0.552 0.38894678 0.15283597          1.214 #> 44  44.0       0.098  0.324    0.578 0.40016732 0.15369441          1.254 #> 46  46.0       0.068  0.346    0.586 0.41102559 0.15449838          1.240 #> 48  48.0       0.068  0.304    0.628 0.42153304 0.15525594          1.324 #> 50  50.0       0.060  0.306    0.634 0.43170091 0.15597328          1.328 #> 52  52.0       0.058  0.276    0.666 0.44154034 0.15665512          1.390 #> 54  54.0       0.048  0.238    0.714 0.45106229 0.15730498          1.476 #> 56  56.0       0.038  0.216    0.746 0.46027758 0.15792551          1.530 #> 58  58.0       0.036  0.196    0.768 0.46919684 0.15851870          1.572 #> 60  60.0       0.034  0.182    0.784 0.47783050 0.15908599          1.602 #> 62  62.0       0.022  0.178    0.800 0.48618878 0.15962852          1.622 #> 64  64.0       0.022  0.154    0.824 0.49428166 0.16014713          1.670 #> 66  66.0       0.014  0.156    0.830 0.50211887 0.16064252          1.674 #> 68  68.0       0.014  0.144    0.842 0.50970987 0.16111526          1.698 #> 70  70.0       0.014  0.140    0.846 0.51706385 0.16156583          1.706 #> 72  72.0       0.012  0.138    0.850 0.52418974 0.16199468          1.712 #> 74  74.0       0.012  0.136    0.852 0.53109614 0.16240223          1.716 #> 76  76.0       0.012  0.126    0.862 0.53779140 0.16278886          1.736 #> 78  78.0       0.012  0.106    0.882 0.54428356 0.16315497          1.776 #> 80  80.0       0.006  0.104    0.890 0.55058037 0.16350095          1.786  # Example of usage for `NextBestThreePlusThree` NextBest class.  # Create the data. my_data <- Data(   x = c(5, 5, 5, 10, 10, 10),   y = c(0, 0, 0, 0, 1, 0),   ID = 1:6,   cohort = c(0, 0, 0, 1, 1, 1),   doseGrid = c(0.1, 0.5, 1.5, 3, 5, seq(from = 10, to = 80, by = 2)) )  # The rule to select the next best dose will be based on the 3+3 method. my_next_best <- NextBestThreePlusThree()  # Calculate the next best dose. dose_recommendation <- nextBest(my_next_best, data = my_data) # Example of usage for `NextBestDualEndpoint` NextBest class.  # Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(1L, 2L, 3L, 4L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L),   w = c(     0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6, 0.52, 0.54,     0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose. In this case, # target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety). de_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = de_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.004    0.002 #>  [2,]  0.5  0.006    0.002 #>  [3,]  1.5  0.044    0.002 #>  [4,]  3.0  0.026    0.002 #>  [5,]  6.0  0.134    0.022 #>  [6,] 10.0  0.110    0.062 #>  [7,] 12.0  0.116    0.142 #>  [8,] 14.0  0.046    0.184 #>  [9,] 16.0  0.066    0.198 #> [10,] 18.0  0.022    0.306 #> [11,] 20.0  0.008    0.418 #> [12,] 22.0  0.022    0.562 #> [13,] 24.0  0.026    0.684 #> [14,] 26.0  0.028    0.748 #> [15,] 28.0  0.030    0.852 #> [16,] 30.0  0.020    0.918 #> [17,] 32.0  0.008    0.940 #> [18,] 34.0  0.010    0.966 #> [19,] 36.0  0.002    0.978 #> [20,] 38.0  0.004    0.980 #> [21,] 40.0  0.000    0.990 #> [22,] 42.0  0.000    0.990 #> [23,] 44.0  0.000    1.000 #> [24,] 46.0  0.004    1.000 #> [25,] 48.0  0.000    1.000 #> [26,] 50.0  0.000    1.000 #> [27,] 52.0  0.000    1.000 #> [28,] 54.0  0.002    1.000 #> [29,] 56.0  0.006    1.000 #> [30,] 58.0  0.010    1.000 #> [31,] 60.0  0.012    1.000 #> [32,] 62.0  0.016    1.000 #> [33,] 64.0  0.020    1.000 #> [34,] 66.0  0.012    1.000 #> [35,] 68.0  0.014    1.000 #> [36,] 70.0  0.024    1.000 #> [37,] 72.0  0.018    1.000 #> [38,] 74.0  0.014    1.000 #> [39,] 76.0  0.034    1.000 #> [40,] 78.0  0.034    1.000 #> [41,] 80.0  0.048    1.000  # Joint plot. print(dose_recommendation$plot) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (2-2,1-1) arrange gtable[layout]  # Show customization of single plot. variant1 <- dose_recommendation$singlePlots$plot1 + xlim(0, 20) print(variant1) #> Warning: Removed 31 rows containing missing values (`geom_bar()`). #> Warning: Removed 1 rows containing missing values (`geom_vline()`).   # Example of usage for `NextBestTD` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. td_next_best <- NextBestTD(prob_target_drt = 0.35, prob_target_eot = 0.3)  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = td_next_best,   doselimit = max(my_data@doseGrid),   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 50 dose_recommendation$plot  # Example of usage for `NextBestTDsamples` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Set-up some MCMC parameters and generate samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 800) my_samples <- mcmc(my_data, my_model, my_options)  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. # 'derive' is specified such that the 30% posterior quantile of the TD35 and # TD30 samples will be used as TD35 and TD30 estimates. tds_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = tds_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 25 dose_recommendation$plot #> Warning: Some data points are outside of `bounds`. Removing them. #> Warning: Some data points are outside of `bounds`. Removing them.   # Example of usage for `NextBestMaxGain` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   ID = 1:8,   cohort = 1:8,   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g. 'Effloglog'. my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and at the # end of trial are defined as 0.35 and 0.3, respectively. mg_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = mg_next_best,   doselimit = 300,   model = my_model_dlt,   model_eff = my_model_eff,   data = my_data )  dose_recommendation$next_dose #> [1] 75 dose_recommendation$plot   # Example of usage for `NextBestMaxGainSamples` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = 1:8,   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g 'Effloglog'. my_model_effll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples_dlt <- mcmc(my_data, my_model_dlt, my_options) my_samples_effll <- mcmc(my_data, my_model_effll, my_options)  # Target probabilities of the occurrence of a DLT during trial and at the end of # trial are defined as 0.35 and 0.3, respectively. # Use 30% posterior quantile of the TD35 and TD30 samples as estimates of TD35 # and TD30. # Use 50% posterior quantile of the Gstar (the dose which gives the maxim gain value) # samples as Gstar estimate. mgs_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effll,   samples_eff = my_samples_effll )  dose_recommendation$next_dose #> [1] 50 dose_recommendation$plot   # Now using the 'EffFlexi' class efficacy model:  my_model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_samples_effflexi <- mcmc(my_data, my_model_effflexi, my_options)  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effflexi,   samples_eff = my_samples_effflexi )  dose_recommendation$next_dose #> [1] 50 dose_recommendation$plot  # Example of usage for `NextBestProbMTDLTE` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestProbMTDLTE' class. nb_mtd_lte <- NextBestProbMTDLTE(target = 0.33)  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nb_mtd_lte,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data ) # Example of usage for `NextBestProbMTDMinDist` NextBest class.  # Create the data. my_data <- Data(   x = c(1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 3.5, 3.5, 3.5),   y = c(0, 0, 0, 0, 0, 0, 1, 1, 0),   ID = 1:9,   cohort = c(1, 1, 1, 2, 2, 2, 3, 3, 3),   doseGrid = c(1.5, 2.5, 3.5, 4.5, 6, 7) )  # Initialize the CRM model used to model the data. my_model <- my_model <- LogisticKadaneBetaGamma(   theta = 0.3,   xmin = 1.5,   xmax = 7,   alpha = 1,   beta = 19,   shape = 0.5625,   rate = 0.125 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsDoseLevels(levels = 1)  next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestProbMTDMinDist' class. nb_mtd_min_dist <- NextBestProbMTDMinDist(target = 0.3)  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nb_mtd_min_dist,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )"},{"path":"https://roche.github.io/crmPack/reference/ngrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Doses in Grid — ngrid","title":"Number of Doses in Grid — ngrid","text":"function gets number doses grid. User can choose whether placebo dose () counted .","code":""},{"path":"https://roche.github.io/crmPack/reference/ngrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Doses in Grid — ngrid","text":"","code":"ngrid(object, ignore_placebo = TRUE, ...)  # S4 method for Data ngrid(object, ignore_placebo = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/reference/ngrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Doses in Grid — ngrid","text":"object (Data) object dose grid. ignore_placebo (flag) placebo dose () counted? ... arguments passed class-specific methods.","code":""},{"path":"https://roche.github.io/crmPack/reference/ngrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Doses in Grid — ngrid","text":"integer number doses grid.","code":""},{"path":"https://roche.github.io/crmPack/reference/ngrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Doses in Grid — ngrid","text":"","code":"my_data <- Data(   x = c(10, 50, 90, 100, 0.001, 20, 30, 30),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(1L, 2L, 3L, 4L, 5L, 5L, 6L, 6L),   doseGrid = c(0.001, seq(from = 10, to = 100, by = 10)),   placebo = TRUE ) ngrid(my_data) #> [1] 10 ngrid(my_data, ignore_placebo = FALSE) #> [1] 11"},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — or-Stopping-Stopping","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"method combining two atomic stopping rules","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"# S4 method for Stopping,Stopping |(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"## Example of combining two atomic stopping rules with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping <- myStopping1 | myStopping2"},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"method combining stopping list atomic","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"# S4 method for StoppingAny,Stopping |(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"e1 StoppingAny object e2 Stopping object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"modified StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 & myStopping2 ) | myStopping3"},{"path":"https://roche.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"method combining atomic stopping list","code":""},{"path":"https://roche.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"# S4 method for Stopping,StoppingAny |(e1, e2)"},{"path":"https://roche.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"e1 Stopping object e2 StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"modified StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <-  myStopping3 | (myStopping1 & myStopping2 )"},{"path":"https://roche.github.io/crmPack/reference/pinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the distribution function of Inverse gamma distribution — pinvGamma","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"Compute distribution function Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/reference/pinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"","code":"pinvGamma(q, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/pinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"q vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). logical; FALSE (default) TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://roche.github.io/crmPack/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://roche.github.io/crmPack/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://roche.github.io/crmPack/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://roche.github.io/crmPack/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"Plot fitted dose-tox based given pseudo DLE model data without samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"# S4 method for Data,ModelTox plot(   x,   y,   xlab = \"Dose level\",   ylab = \"Probability of DLE\",   showLegend = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"x data Data class object y model ModelTox class object xlab x axis label ylab y axis label showLegend legend shown? (default) ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"returns ggplot object dose-DLE model plot","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"## plot the dose-DLE curve given a pseudo DLE model using data without samples ## data must be of 'Data' class ## define the data data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1L:8L,   cohort = as.integer(c(1, 2, 2, 3, 4, 4, 5, 6)),   doseGrid = seq(25, 300, 25) ) ## model must be from 'ModelTox' class e.g 'LogisticIndepBeta' class model ## define the model (see LogisticIndepBeta example) model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## plot the dose-DLE curve ## 'x' is the data and 'y' is the model in plot plot(x = data, y = model)"},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"method creates plot Data  DataOrdinal objects.  method creates plot Data object.  method creates plot DataOrdinal object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"","code":"h_plot_data_dataordinal(   x,   blind = FALSE,   legend = TRUE,   tox_labels = c(Yes = \"red\", No = \"black\"),   tox_shapes = c(Yes = 17L, No = 16L),   ... )  # S4 method for Data,missing plot(x, y, blind = FALSE, legend = TRUE, ...)  # S4 method for DataOrdinal,missing plot(   x,   y,   blind = FALSE,   legend = TRUE,   tox_labels = NULL,   tox_shapes = NULL,   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"x (DataOrdinal) object want plot. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. legend (flag) whether legend added. tox_labels (named list character) labels toxicity categories. tox_shapes (names list integers) symbols used identify toxicity categories. ... used. y (missing) missing object, compatibility generic function.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"ggplot2 object. ggplot2 object. ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"default values tox_shapes tox_labels result DLTs displayed red triangles responses black circles. 9 toxicity categories, toxicity symbols must specified manually. 5 toxicity categories, toxicity labels must specified manually.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.001, 0.1, 0.1, 0.5, 0.001, 3, 3, 0.001, 10, 10, 10),   y = c(0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0),   cohort = c(1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 4),   doseGrid = c(0.001, 0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   placeb = TRUE ) #> Used default patient IDs!  # Plot the data. plot(my_data)  data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  plot(data)"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDA Class — plot,DataDA,missing-method","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"method creates plot DataDA object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# S4 method for DataDA,missing plot(x, y, blind = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"x (DataDA) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# Create some data of class 'DataDA'. my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (2-2,1-1) arrange gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"Plot fitted dose-efficacy based given pseudo efficacy model data without samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# S4 method for DataDual,ModelEff plot(   x,   y,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"x data DataDual class object y model ModelEff class object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"returns ggplot object dose-efficacy model plot","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# nolint start  ##plot the dose-efficacy curve given a pseudo efficacy model using data without samples ##data must be of 'DataDual' class ##define the data data<-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##model must be from 'ModelEff' class e.g 'Effloglog' class model ##define the model (see Effloglog example) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ## plot the dose-efficacy curve ## 'x' is the data and 'y' is the model in plot plot(x=data,y=Effmodel)   # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDual Class — plot,DataDual,missing-method","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"method creates plot DataDual object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# S4 method for DataDual,missing plot(x, y, blind = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"x (DataDual) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data) #> TableGrob (1 x 2) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (1-1,2-2) arrange gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"plot method can applied DualSimulations objects order summarize graphically. addition standard plot types, sigma2W Plot boxplot final biomarker variance estimates simulated trials rho Plot boxplot final correlation estimates simulated trials","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# S4 method for DualSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2W\", \"rho\"), ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"x DualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Create some data. my_data <- DataDual(   x = c(     0.1, 0.5, 1.5, 3, 6, 10, 10, 10,     20, 20, 20, 40, 40, 40, 50, 50, 50   ),   y = c(     0, 0, 0, 0, 0, 0, 1, 0,     0, 1, 1, 0, 0, 1, 0, 1, 1   ),   ID = 1:17,   cohort = c(1L, 2L, 3L, 4L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L),   w = c(     0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,     0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21   ),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) )  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) myStopping <- myStopping4 | StoppingMinPatients(40)  my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping my_stopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) my_stopping <- my_stopping4 | StoppingMinPatients(40) | StoppingMissingDose()  # Choose the rule for dose increments my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design  my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study. # Also for illustration purpose, we will use 5 burn-ins to generate 20 samples, # this should be increased of course. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 9,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 1,     step = 1,     samples = 2   ) )  # Plot the results of the simulation. print(plot(my_sims))  #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange gtable[arrange]"},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"plot method can applied DualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,SimulationsSummary,missing-method plus: meanBiomarkerFit Plot showing average fitted dose-biomarker curve across trials, together 95% credible intervals, comparison assumed truth (specified trueBiomarker argument summary,DualSimulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# S4 method for DualSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\",     \"meanBiomarkerFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"x DualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))   # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )   # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) # Only 10 patients here for illustration! my_stopping <- my_stopping4 | StoppingMinPatients(10) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }    true_biomarker <- function(dose) {   beta_mod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study. # For illustration purpose we will use 5 burn-ins to generate 20 samples, # this should be increased of course. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Plot the summary of the Simulations. plot(summary(my_sims,   trueTox = true_tox,   trueBiomarker = true_biomarker ))  #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,GeneralSimulations,missing-method","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# S4 method for GeneralSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\"), ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"x GeneralSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"plot method can applied GeneralSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# nolint start  ## obtain the plot for the simulation results ## If only DLE responses are considered in the simulations  ## Specified your simulations when no DLE samples are used ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients = 12) ## Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). ## The simulations mySim <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )   ## plot the simulations print(plot(mySim)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (2-2,1-1) arrange gtable[layout]    ## If DLE samples are involved ## The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ## specify the design design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 ) ## options for MCMC ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # # ##plot the simulations # print(plot(mySim)) #  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"plot method can applied GeneralSimulationsSummary objects order summarize graphically. Possible types plots moment :","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"","code":"# S4 method for GeneralSimulationsSummary,missing plot(x, y, type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\"), ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"x GeneralSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"nObs Distribution number patients simulated trials doseSelected Distribution final selected doses trials. Note can include zero entries, meaning trial stopped doses dose grid appeared toxic. propDLTs Distribution proportion patients DLTs trials nAboveTarget Distribution number patients treated doses target toxicity interval (specified truth target arguments summary,GeneralSimulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"plot method can applied PseudoDualFlexiSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses sigma2betaW variance random walk model can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# S4 method for PseudoDualFlexiSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\", \"sigma2betaW\"), ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"x PseudoDualFlexiSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model must be of 'EffFlexi' class. eff_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The cohort size, size of 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Define the stopping rule. Stop when the maximum sample size of 36 patients has # been reached or when the next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments ) # Specify the true DLE curve and the true expected efficacy values # at all dose levels. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499)  my_truth_eff <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )  # The true gain curve. my_truth_gain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }  # MCMC options. my_options <- McmcOptions(burnin = 10, step = 1, samples = 20)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = my_options,   nsim = 1,   seed = 819,   parallel = FALSE )  # Plot the simulated results. print(plot(my_sim)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,PseudoDualSimulations,missing-method","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# S4 method for PseudoDualSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\"), ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"x PseudoDualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"plot method can applied PseudoDualSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations.  # Example to run simulations when no samples are used. The data object # must be defined with doses >= 1: emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model must be of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop only when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Now specify the design with all the above information and starting with a # dose of 25 (for details please refer to the 'DualResponsesDesign' example). my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # Run simulations (for illustration purpose only 1 simulation is produced). my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   seed = 819,   parallel = FALSE )  # Plot the simulation results. print(plot(my_sim)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  # Example if DLE and efficacy samples are involved. # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The design of 'DualResponsesSamplesDesign' class. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # Options for MCMC. my_options <- McmcOptions(burnin = 10, step = 1, samples = 20)  # For illustration purpose only 1 simulation is produced (nsim = 1). my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Plot the simulation results. print(plot(my_sim)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"plot method can applied PseudoDualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,PseudoSimulationsSummary,missing-method plus: can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# S4 method for PseudoDualSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\",     \"meanEffFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"x PseudoDualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# Obtain the summary plot for the simulation results if DLE and efficacy # responses are considered in the simulations.  # In the example when no samples are used a data object with doses >= 1 # needs to be defined. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 10 subjects are treated (for illustration only). my_stopping <- StoppingMinPatients(nPatients = 10)  ## Now specified the design with all the above information and starting with a dose of 25  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = McmcOptions(burnin = 10, step = 1, samples = 50),   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sum)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  # Example where DLE and efficacy samples are involved. # Please refer to design-method 'simulate DualResponsesSamplesDesign' examples # for details. # Specify the next best method. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # MCMC options. my_options <- McmcOptions(burnin = 10, step = 2, samples = 50)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )   # Generate a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sum)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  # Example where the 'EffFlexi' class is used for the efficacy model. eff_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # Specify the true DLE curve and the true expected efficacy values at all dose levels. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499)  my_truth_eff <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )  # Define the true gain curve. my_truth_gain <- function(dose) {   return((my_truth_eff(dose)) / (1 + (my_truth_dle(dose) / (1 - my_truth_dle(dose))))) }  ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sim)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# S4 method for PseudoSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"x PseudoSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"plot method can applied PseudoSimulationsSummary objects order summarize graphically. can used DLE responses involved simulations. also applied results without samples generated simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# nolint start  ## obtain the plot for the simulation results ## If only DLE responses are considered in the simulations ## Specified your simulations when no DLE samples are used ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients = 12) ## Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). ## The simulations mySim <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )  ## Then produce a summary of your simulations MYSUM <- summary(mySim,   truth = myTruth ) ## plot the summary of the simulations print(plot(MYSUM)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  ## If DLE samples are involved ## The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ## specify the design design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 ) ## options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # ##Then produce a summary of your simulations # MYSUM <- summary(mySim, #                  truth=myTruth) # ##plot the summary of the simulations # print(plot(MYSUM))  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"","code":"# S4 method for Samples,DALogisticLogNormal plot(x, y, data, hazard = FALSE, ..., showLegend = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"x Samples object y DALogisticLogNormal object data DataDA object hazard see fitPEM explanation ... used showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"dual endpoint model, also dose-biomarker fit shown plot","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# S4 method for Samples,DualEndpoint plot(x, y, data, extrapolate = TRUE, showLegend = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"x Samples object y DualEndpoint object data DataDual object extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default) ... additional arguments parent method plot,Samples,GeneralModel-method","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"returns ggplot object dose-toxicity dose-biomarker model fits","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# nolint start  # Create some data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses #grid.arrange(plot(x = samples, y = model, data = data))  plot(x = samples, y = model, data = data) #> TableGrob (1 x 2) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (1-1,2-2) arrange gtable[layout]  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# S4 method for Samples,GeneralModel plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"x Samples object y GeneralModel object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses plot(x = samples, y = model, data = data)                 # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"Plot fitted dose-efficacy curve using model ModelEff class samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"","code":"# S4 method for Samples,ModelEff plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"x Samples object y ModelEff model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"returns ggplot object dose-efficacy model fit","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-efficacy curve with samples using the model from 'ModelEff' ##class e.g. 'Effloglog' class model ##define the model (see Effloglog example) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ## define the samples obtained using the 'Effloglog' model (see details in 'Samples' example) ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ## samples must be of 'Samples' class samples <- mcmc(data=data,model=Effmodel,options=options) ## plot the fitted dose-efficacy curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelEff' class plot(x=samples,y=Effmodel,data=data)  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"Plot fitted dose-DLE curve using ModelTox class model samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"# S4 method for Samples,ModelTox plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"x Samples object y ModelTox model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"returns ggplot object dose-DLE model fit","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## plot the dose-DLE curve with samples using the model from 'ModelTox' ## class e.g. 'LogisticIndepBeta' class model ## define the model (see LogisticIndepBeta example) model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the samples obtained using the 'LogisticIndepGBeta' model  ## Define options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## (see details in 'Samples' example) samples must be of 'Samples' class samples <- mcmc(data = data, model = model, options = options) ## plot the fitted dose-DLE curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelTox' class plot(x = samples, y = model, data = data)"},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# S4 method for SimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"x SimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"plot method can applied SimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,GeneralSimulationsSummary,missing-method plus: meanFit Plot showing average fitted dose-toxicity curve across trials, together 95% credible intervals, comparison assumed truth (specified truth argument summary,Simulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 10,   step = 1,   samples = 100 ) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]  # Plot the Summary of the Simulations plot(summary(mySims, truth = myTruth)) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"Plot DLE efficacy curve side side given DLE pseudo model, DLE sample, efficacy pseudo model given efficacy sample Plot dose-DLE dose-efficacy curve side side given DLE pseudo model given pseudo efficacy model without DLE efficacy samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples plotDualResponses(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   extrapolate = TRUE,   showLegend = FALSE,   ... )  # S4 method for ModelTox,missing,ModelEff,missing plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)"},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"DLEmodel pseudo DLE model ModelTox class object DLEsamples DLE samples Samples class object Effmodel pseudo efficacy model ModelEff class object Effsamples Efficacy samples Samples class object data data input DataDual class object ... additional arguments parent method plot,Samples,GeneralModel-method extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"returns ggplot object dose-toxicity dose-efficacy model fits","code":""},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): function still documented plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Plot DLE efficacy curve side side given DLE model efficacy model without samples","code":""},{"path":"https://roche.github.io/crmPack/reference/plotDualResponses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices! ##Specify the options for MCMC options <- McmcOptions(burnin=100,step=2,samples=1000)   DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data=data,model=Effmodel,options=options) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. ##For each curve the 95% credibility interval of the two samples are alos given plotDualResponses(DLEmodel=DLEmodel,DLEsamples=DLEsamples,          Effmodel=Effmodel,Effsamples=Effsamples,          data=data) #> TableGrob (1 x 2) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (1-1,2-2) arrange gtable[layout]  # nolint end # nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots without DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. plotDualResponses(DLEmodel=DLEmodel,                   Effmodel=Effmodel,                   data=data) #> TableGrob (1 x 2) \"arrange\": 2 grobs #>   z     cells    name           grob #> 1 1 (1-1,1-1) arrange gtable[layout] #> 2 2 (1-1,2-2) arrange gtable[layout]  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, DLE sample, given efficacy pseudo model efficacy sample Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, given efficacy pseudo model","code":""},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,missing,ModelEff,missing plotGain(DLEmodel, Effmodel, data, size = c(8L, 8L), shape = c(16L, 17L), ...)"},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"DLEmodel dose-DLE model ModelTox class object DLEsamples DLE sample Samples class object Effmodel dose-efficacy model ModelEff class object Effsamples efficacy sample Samples class object data data input DataDual class object ... used size (integer) vector length two defining sizes shapes used identify doses , respectively, p(DLE = 0.3) maximum gain shape (integer) vector length two defining shapes used identify doses , respectively, p(DLE = 0.3) maximum gain","code":""},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"returns ggplot object plot","code":""},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"plotGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): Standard method plotGain(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Standard method","code":""},{"path":"https://roche.github.io/crmPack/reference/plotGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data,const=0) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  ##Define the options for MCMC options <- McmcOptions(burnin=100,step=2,samples=1000)   DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data=data,model=Effmodel,options=options) ##plot the three curves of mean values of the DLEsamples, Effsamples and ##gain value samples (obtained within this plotGain function) at all dose levels plotGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,          Effmodel=Effmodel,Effsamples=Effsamples,          data=data)  # nolint end # nolint start ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##plot the three curves of using modal estimates of model parameters at all dose levels plotGain(DLEmodel=DLEmodel,          Effmodel=Effmodel,          data=data)  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/positive_number.html","id":null,"dir":"Reference","previous_headings":"","what":"positive_number — positive_number","title":"positive_number — positive_number","text":"positive_number class class store NULL, non NA, finite strictly positive numerical value. mainly used store reference dose value model classes.","code":""},{"path":"https://roche.github.io/crmPack/reference/printVignette.html","id":null,"dir":"Reference","previous_headings":"","what":"Taken from utils package (print.vignette) — printVignette","title":"Taken from utils package (print.vignette) — printVignette","text":"Taken utils package (print.vignette)","code":""},{"path":"https://roche.github.io/crmPack/reference/printVignette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Taken from utils package (print.vignette) — printVignette","text":"","code":"printVignette(x, ...)"},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"function computes probability occurrence DLE specified dose level, based model parameters (samples).","code":""},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"prob(dose, model, samples, ...)  # S4 method for numeric,LogisticNormal,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormal,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormalSub,Samples prob(dose, model, samples)  # S4 method for numeric,ProbitLogNormal,Samples prob(dose, model, samples)  # S4 method for numeric,ProbitLogNormalRel,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormalGrouped,Samples prob(dose, model, samples, group)  # S4 method for numeric,LogisticKadane,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticKadaneBetaGamma,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticNormalMixture,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticNormalFixedMixture,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormalMixture,Samples prob(dose, model, samples)  # S4 method for numeric,DualEndpoint,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticIndepBeta,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticIndepBeta,missing prob(dose, model)  # S4 method for numeric,OneParLogNormalPrior,Samples prob(dose, model, samples)  # S4 method for numeric,OneParExpPrior,Samples prob(dose, model, samples)"},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (GeneralModel ModelTox) model single agent dose escalation pseudo DLE (dose-limiting events)/toxicity model. samples (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. ... model specific parameters samples used. group (character factor) LogisticLogNormalGrouped, indicating whether calculate probability mono combo arm.","code":""},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"proportion numeric vector toxicity probabilities. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.","code":""},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() function computes probability toxicity given doses, using samples model parameter(s). work multivariate model parameters, assume model specific prob() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob(dose = numeric, model = LogisticNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormalSub, samples = Samples): prob(dose = numeric, model = ProbitLogNormal, samples = Samples): prob(dose = numeric, model = ProbitLogNormalRel, samples = Samples): prob(dose = numeric, model = LogisticLogNormalGrouped, samples = Samples): method LogisticLogNormalGrouped needs group argument addition. prob(dose = numeric, model = LogisticKadane, samples = Samples): prob(dose = numeric, model = LogisticKadaneBetaGamma, samples = Samples): prob(dose = numeric, model = LogisticNormalMixture, samples = Samples): prob(dose = numeric, model = LogisticNormalFixedMixture, samples = Samples): prob(dose = numeric, model = LogisticLogNormalMixture, samples = Samples): prob(dose = numeric, model = DualEndpoint, samples = Samples): prob(dose = numeric, model = LogisticIndepBeta, samples = Samples): compute toxicity probabilities occurrence DLE specified dose level, based samples LogisticIndepBeta model parameters. prob(dose = numeric, model = LogisticIndepBeta, samples = missing): compute toxicity probabilities occurrence DLE specified dose level, based LogisticIndepBeta model parameters. model parameters (except dose) present model object. prob(dose = numeric, model = OneParLogNormalPrior, samples = Samples): prob(dose = numeric, model = OneParExpPrior, samples = Samples):","code":""},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() dose() functions inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for Prob(DLT | dose = 50). prob(dose = 50, model = my_model, samples = my_samples) #>  [1] 0.6817686 0.2787839 0.2794573 0.2794573 0.5263969 0.3748107 0.3748107 #>  [8] 0.3748107 0.2443572 0.2443572 0.2443572 0.2443572 0.2443572 0.2443572 #> [15] 0.2443572 0.2443572 0.4806609 0.4806609 0.4806609 0.4806609  # Create data from the 'DataDual' class. data_dual <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data_dual )  # Get samples from posterior. dlt_sample <- mcmc(data = data_dual, model = dlt_model, options = my_options)  # Posterior for Prob(DLT | dose = 100). prob(dose = 100, model = dlt_model, samples = dlt_sample) #>  [1] 0.3331095 0.3331095 0.3331095 0.3331095 0.3780942 0.3780942 0.4100337 #>  [8] 0.4100337 0.4100337 0.4100337 0.4070378 0.4070378 0.4070378 0.4070378 #> [15] 0.4070378 0.4070378 0.4070378 0.5868325 0.6399562 0.1724915 prob(dose = c(50, 150), model = dlt_model) #> [1] 0.1981823 0.4601234"},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Prob Function for a Given Model Type — probFunction","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"function returns prob() function computes toxicity probabilities given dose level, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"probFunction(model, ...)  # S4 method for GeneralModel probFunction(model, ...)  # S4 method for ModelTox probFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"model (GeneralModel ModelTox) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"prob() function computes toxicity probabilities.","code":""},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"probFunction(GeneralModel): probFunction(ModelTox):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/reference/probFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  prob_fun <- probFunction(my_model, alpha0 = 2, alpha1 = 3) prob_fun(30) #> [1] 0.6147973"},{"path":"https://roche.github.io/crmPack/reference/probit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for probit function — probit","title":"Shorthand for probit function — probit","text":"Shorthand probit function","code":""},{"path":"https://roche.github.io/crmPack/reference/probit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for probit function — probit","text":"","code":"probit(x)"},{"path":"https://roche.github.io/crmPack/reference/probit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for probit function — probit","text":"x function argument","code":""},{"path":"https://roche.github.io/crmPack/reference/probit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for probit function — probit","text":"probit(x)","code":""},{"path":"https://roche.github.io/crmPack/reference/qinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the quantile function of Inverse gamma distribution — qinvGamma","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"Compute quantile function Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/reference/qinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"","code":"qinvGamma(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://roche.github.io/crmPack/reference/qinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"p vector probabilities shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). logical; FALSE (default) TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://roche.github.io/crmPack/reference/rinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"The random generation of the Inverse gamma distribution — rinvGamma","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"random generation Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/reference/rinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"","code":"rinvGamma(n, a, b)"},{"path":"https://roche.github.io/crmPack/reference/rinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"n number observations shape parameter inverse gamma distribution b scale parameter inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/reference/safeInteger.html","id":null,"dir":"Reference","previous_headings":"","what":"Safe conversion to integer vector — safeInteger","title":"Safe conversion to integer vector — safeInteger","text":"Safe conversion integer vector","code":""},{"path":"https://roche.github.io/crmPack/reference/safeInteger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safe conversion to integer vector — safeInteger","text":"","code":"safeInteger(x)"},{"path":"https://roche.github.io/crmPack/reference/safeInteger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safe conversion to integer vector — safeInteger","text":"x numeric vector","code":""},{"path":"https://roche.github.io/crmPack/reference/safeInteger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safe conversion to integer vector — safeInteger","text":"integer vector","code":""},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Determining if this Sample Should be Saved — saveSample","title":"Determining if this Sample Should be Saved — saveSample","text":"method determines sample given iteration saved. sample saved : burn-period matches step.","code":""},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"saveSample(object, iteration, ...)  # S4 method for McmcOptions saveSample(object, iteration, ...)"},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determining if this Sample Should be Saved — saveSample","text":"object (McmcOptions) object based answer determined. iteration (count) current iteration index. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determining if this Sample Should be Saved — saveSample","text":"TRUE sample saved.","code":""},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determining if this Sample Should be Saved — saveSample","text":"saveSample(McmcOptions): determine sample saved.","code":""},{"path":"https://roche.github.io/crmPack/reference/saveSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 saveSample(my_options, iteration = 5) #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/reference/set_seed.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Set and Save the RNG Seed — set_seed","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"code basically copied stats:::simulate.lm.","code":""},{"path":"https://roche.github.io/crmPack/reference/set_seed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"","code":"set_seed(seed = NULL)"},{"path":"https://roche.github.io/crmPack/reference/set_seed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"seed object specifying random number generator initialized (\"seeded\"). Either NULL (default) integer used call set.seed() simulating response vectors. set, value saved seed slot returned object. default, NULL change random generator state.","code":""},{"path":"https://roche.github.io/crmPack/reference/set_seed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"integer vector containing random number generate state returned, order call function input reproduce obtained simulation results.","code":""},{"path":"https://roche.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"Show summary dual-endpoint simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# S4 method for DualSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"object DualSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 30))  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 )  # Stop with a small number of patients for illustration. my_stopping <- my_stopping1 | StoppingMinPatients(10) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)   # Run the simulation on the desired design. # For illustration purposes only 1 trial outcome is generated and 5 burn-ins # to generate 20 samples are used here. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Show the summary of the simulations. show(summary(   my_sims,   trueTox = true_tox,   trueBiomarker = true_biomarker )) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was NA, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 3 (3, 3)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 0 (0, 0)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean NA % (NA %, NA %)  #> Fitted biomarker level at dose most often selected : mean NA (NA, NA)"},{"path":"https://roche.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"","code":"# S4 method for GeneralSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"object GeneralSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"Show summary Pseudo Dual simulations summary","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# S4 method for PseudoDualSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"object PseudoDualSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# Example where DLE and efficacy responses are considered in the simulations. # In simulations where no samples are used a data object with doses >= 1 needs # to be generated. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)   # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # For illustration purpose only 2 simulations are produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Show the summary of the simulations in a data frame. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)   # Example when DLE and efficacy samples are involved.  # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The design of 'DualResponsesSamplesDesign' class. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # MCMC options. # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # For illustration purpose 2 trials are simulated. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Show the summary in data frame for the simulations. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2045 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)"},{"path":"https://roche.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# S4 method for PseudoSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"object PseudoSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# Obtain the plot for the simulation results if only DLE responses are # considered in the simulations.  # Specified simulations when no DLE samples are used. emptydata <- Data(doseGrid = seq(25, 300, 25))  # The design only incorporate DLE responses and DLE samples are involved. # Specify the model of 'ModelTox' class eg 'LogisticIndepBeta' class model. my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The escalation rule. td_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # The cohort size is 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Specify the stopping rule with maximum sample size of 36 patients or when the # next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'TDDesign' example.) my_design <- TDDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the truth of the DLE responses. my_truth <- probFunction(my_model, phi1 = -53.66584, phi2 = 10.50499)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   truth = my_truth )  # Show the summary of the simulated results in a data frame. show(my_sum) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>   # Example where DLE samples are involved.  # The escalation rule. td_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # The design. my_design <- TDsamplesDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # For illustration purposes 2 trails are simulated with 50 burn-ins to generate # 200 samples. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 2,   seed = 819,   mcmcOptions = my_options,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   truth = my_truth )  # Show the summary of the simulated results in a data frame. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>"},{"path":"https://roche.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,SimulationsSummary-method","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# S4 method for SimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"object SimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 ) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]  # Show the Summary of the Simulations show(summary(mySims, truth = myTruth)) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 21 (21, 21)  #> Number of patients treated above target tox interval : mean 7 (7, 7)  #> Proportions of DLTs in the trials : mean 29 % (29 %, 29 %)  #> Mean toxicity risks for the patients on active : mean 26 % (26 %, 26 %)  #> Doses selected as MTD : mean 20 (20, 20)  #> True toxicity at doses selected : mean 22 % (22 %, 22 %)  #> Proportion of trials selecting target MTD: 100 % #> Dose most often selected as MTD: 20  #> Observed toxicity rate at dose most often selected: 0 % #> Fitted toxicity rate at dose most often selected : mean 26 % (26 %, 26 %)   # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-DADesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"Simulate outcomes time--DLT augmented CRM design (DADesign)","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DADesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# S4 method for DADesign simulate(   object,   nsim = 1L,   seed = NULL,   truthTox,   truthSurv,   trueTmax = NULL,   args = NULL,   firstSeparate = FALSE,   deescalate = TRUE,   mcmcOptions = McmcOptions(),   DA = TRUE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-DADesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object DADesign object want simulate data nsim number simulations (default: 1) seed see set_seed truthTox function takes input dose (vector) returns true probability (vector) toxicity time DLT occurs. Additional arguments can supplied args. truthSurv CDF takes input time (vector) returns true cumulative probability (vector) DLT occur conditioning patient DLTs. trueTmax add documentation args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. deescalate deescalation DLT occurs cohorts lower dose level. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used. DA document rename parameter make meaningful parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine (maximum 5) derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DADesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object class Simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DADesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   Tmax = 60 )  # Initialize the mDA-CRM model npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 ) # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping2 <- StoppingMinPatients(nPatients = 50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  # Initialize the design design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )  ## set up truth curves myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from = 0, to = 100, ylim = c(0, 1))   exp_cond.cdf <- function(x, onset = 15) {   a <- pexp(28, 1 / onset, lower.tail = FALSE)   1 - (pexp(x, 1 / onset, lower.tail = FALSE) - a) / (1 - a) }  # set up simulation settings options <- McmcOptions(   burnin = 10,   step = 1,   samples = 200 )  mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf,   trueTmax = 80,   nsim = 2,   seed = 819,   mcmcOptions = options,   firstSeparate = TRUE,   deescalate = FALSE,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-Design-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a CRM design — simulate,Design-method","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"Simulate outcomes CRM design","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-Design-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# S4 method for Design simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-Design-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object Design object want simulate data nsim number simulations (default: 1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-Design-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object class Simulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-Design-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 ) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"simulate method DesignGrouped designs.","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"","code":"# S4 method for DesignGrouped simulate(   object,   nsim = 1L,   seed = NULL,   truth,   combo_truth,   args = data.frame(),   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallelly::availableCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"object (DesignGrouped) design want simulate trials . nsim (number) many trials simulated. seed (RNGstate) generated set_seed(). truth (function) function takes input dose (vector) returns true probability (vector) toxicity mono arm. Additional arguments can supplied args. combo_truth (function) truth combo arm. args (data.frame) optional data.frame arguments work truth combo_truth functions. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate (flag) whether enroll first patient separately rest cohort close cohort case DLT occurs first patient. mcmcOptions (McmcOptions) MCMC options evaluation trial. parallel (flag) whether simulation runs parallelized across cores computer. nCores (number) many cores used parallel computing. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"list mono combo simulation results Simulations objects.","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"","code":"# Assemble ingredients for our group design. my_stopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) |   StoppingMinPatients(20) |   StoppingMissingDose() my_increments <- IncrementsDoseLevels(levels = 3L) my_next_best <- NextBestNCRM(   target = c(0.2, 0.3),   overdose = c(0.3, 1),   max_overdose_prob = 0.3 ) my_cohort_size <- CohortSizeConst(3) empty_data <- Data(doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))) my_model <- LogisticLogNormalGrouped(   mean = c(-4, -4, -4, -4),   cov = diag(rep(6, 4)),   ref_dose = 0.1 )  # Put together the design. Note that if we only specify the mono arm, # then the combo arm is having the same settings. my_design <- DesignGrouped(   model = my_model,   mono = Design(     model = my_model,     stopping = my_stopping,     increments = my_increments,     nextBest = my_next_best,     cohort_size = my_cohort_size,     data = empty_data,     startingDose = 0.1   ),   first_cohort_mono_only = TRUE,   same_dose = TRUE )  # Set up a realistic simulation scenario. my_truth <- function(x) plogis(-4 + 0.2 * log(x / 0.1)) my_combo_truth <- function(x) plogis(-4 + 0.5 * log(x / 0.1)) matplot(   x = empty_data@doseGrid,   y = cbind(     mono = my_truth(empty_data@doseGrid),     combo = my_combo_truth(empty_data@doseGrid)   ),   type = \"l\",   ylab = \"true DLT prob\",   xlab = \"dose\" ) legend(\"topright\", c(\"mono\", \"combo\"), lty = c(1, 2), col = c(1, 2))  # Start the simulations. set.seed(123) my_sims <- simulate(   my_design,   nsim = 4, # This should be at least 100 in actual applications.   seed = 123,   truth = my_truth,   combo_truth = my_combo_truth )  # Looking at the summary of the simulations: mono_sims_sum <- summary(my_sims$mono, truth = my_truth) combo_sims_sum <- summary(my_sims$combo, truth = my_combo_truth)  mono_sims_sum #> Summary of 4 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was NA, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 21 (21, 21)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 2 % (0 %, 5 %)  #> Mean toxicity risks for the patients on active : mean 4 % (4 %, 4 %)  #> Doses selected as MTD : mean 27 (23.8, 29.4)  #> True toxicity at doses selected : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 28  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 7 % (5 %, 10 %)  combo_sims_sum #> Summary of 4 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 18.6, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 21 (21, 21)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 15 % (11 %, 19 %)  #> Mean toxicity risks for the patients on active : mean 15 % (15 %, 15 %)  #> Doses selected as MTD : mean 25 (20.4, 28.8)  #> True toxicity at doses selected : mean 22 % (21 %, 24 %)  #> Proportion of trials selecting target MTD: 75 % #> Dose most often selected as MTD: 26  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 17 % (11 %, 21 %)   plot(mono_sims_sum)  #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout] plot(combo_sims_sum) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name            grob #> 1 1 (1-1,1-1) arrange gtable[arrange] #> 2 2 (2-2,1-1) arrange  gtable[layout]  # Looking at specific simulated trials: trial_index <- 1 plot(my_sims$mono@data[[trial_index]])  plot(my_sims$combo@data[[trial_index]])"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"Simulate outcomes dual-endpoint design","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# S4 method for DualDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueTox,   trueBiomarker,   args = NULL,   sigma2W,   rho = 0,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object DualDesign object want simulate data nsim number simulations (default: 1) seed see set_seed trueTox function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). Additional arguments can supplied args. args data frame arguments trueTox trueBiomarker function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. sigma2W variance biomarker measurements rho correlation toxicity biomarker measurements (default: 0) firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object class DualSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   use_log_dose = TRUE,   ref_dose = 2,   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) myStopping <- myStopping4 | StoppingMinPatients(10)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- DualDesign(   model = model,   data = emptydata,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   startingDose = 3 )  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) }  trueTox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles par(mfrow = c(1, 2)) curve(trueTox(x), from = 0, to = 80) curve(trueBiomarker(x), from = 0, to = 80)   # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course, similarly for the McmcOptions - # they also need to be increased. mySims <- simulate(design,   trueTox = trueTox,   trueBiomarker = trueBiomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions =     McmcOptions(       burnin = 100,       step = 1,       samples = 300     ) )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object. addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"","code":"# S4 method for DualResponsesDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"object DualResponsesDesign object want simulate data nsim number simulations (default :1) seed see set_seed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu precision, inverse variance efficacy responses args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"object class PseudoDualSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based on DLE and efficacy responses where no DLE ## and efficacy samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel <- Effloglog(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025), data = data )  ## The escalation rule using the 'NextBestMaxGain' class mynextbest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )   ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients = 36) ## Now specified the design with all the above information and starting with a dose of 25  ## Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(   nextBest = mynextbest,   model = DLEmodel,   eff_model = Effmodel,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 ) ## Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## The true gain curve can also be seen myTruthGain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }   ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). options <- McmcOptions(burnin = 100, step = 2, samples = 200) mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesSamplesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object (special case EffFlexi class model object). addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"","code":"# S4 method for DualResponsesSamplesDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu = NULL,   trueSigma2 = NULL,   trueSigma2betaW = NULL,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"object DualResponsesSamplesDesign object want simulate data nsim number simulations (default :1) seed see set_seed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu (codeEffFlexi) precision, inverse variance efficacy responses trueSigma2 (codeEffFlexi) true variance efficacy responses must single positive scalar. trueSigma2betaW (codeEffFlexi) true variance random walk model used smoothing. must single positive scalar. args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"object class PseudoDualSimulations PseudoDualFlexiSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used data <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel <- Effloglog(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025), data = data )   ## The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 10 subjects are treated (only for illustration such a low ## sample size) myStopping <- StoppingMinPatients(nPatients = 10) ## Now specified the design with all the above information and starting with ## a dose of 25   ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE and efficacy curve myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## The true gain curve can also be seen myTruthGain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }  ## simulate the trial for 10 times involving samples ## for illustration purpose we use 10 burn-ins to generate 50 samples options <- McmcOptions(burnin = 10, step = 1, samples = 50) ## For illustration purpose only 1 simulations are produced (nsim=1). mySim <- simulate(design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = options,   seed = 819,   parallel = FALSE )    ## Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used ## when the efficacy model is of 'EffFlexi' class Effmodel <- EffFlexi(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1), sigma2betaW = c(a = 20, b = 50), rw1 = FALSE, data = data )   ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 ) ## The true gain curve can also be seen d1 <- data@doseGrid myTruthGain <- (myTruthEff) / (1 + (myTruthDLE(d1) / (1 - myTruthDLE(d1))))   mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = options,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"Simulate outcomes rule-based design","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# S4 method for RuleDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object RuleDesign object want simulate data nsim number simulations (default: 1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object class GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = emptydata,   startingDose = 5 )  model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Perform the simulation ## For illustration purpose only 10 simulation is produced (nsim=10). threeSims <- simulate(myDesign,   nsim = 10,   seed = 35,   truth = myTruth,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-TDDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDDesign model used ModelTox class object samples involved.","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# S4 method for TDDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object TDDesign object want simulate data nsim number simulations (default :1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based only on DLE responses and no DLE samples are used  ## The design comprises a model, the escalation rule, starting data, ## a cohort size and a starting dose ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## The design only incorporate DLE responses and DLE samples are involved ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) doseRecommendation <- nextBest(tdNextBest,   doselimit = max(data@doseGrid),   model = model,   data = data ) #> [1] \"TD 35 = 24.9999999999785 not within dose grid\" #> [1] \"TD 30 = 14.3714101936777 not within dose grid\" ## Then the starting data, an empty data set emptydata <- Data(doseGrid = seq(25, 300, 25)) ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients = 36)   ## Specified the design(for details please refer to the 'TDDesign' example) design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from = 0, to = 300, ylim = c(0, 1))    ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDsamplesDesign model used ModelTox class object DLE samples also used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# S4 method for TDsamplesDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://roche.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object TDsamplesDesign object want simulate data nsim number simulations (default :1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://roche.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based only on DLE responses with DLE samples involved  ## The design comprises a model, the escalation rule, starting data, ## a cohort size and a starting dose ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## The design only incorporate DLE responses and DLE samples are involved ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients = 36)  ## Specified the design(for details please refer to the 'TDsamplesDesign' example) design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data, startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from = 0, to = 300, ylim = c(0, 1))   ## Then specified the simulations and generate the trial ## options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE )  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/size.html","id":null,"dir":"Reference","previous_headings":"","what":"Size of an Object — size","title":"Size of an Object — size","text":"method computes size given object. can instance size MCMC sample, size cohort. See help specific method details.","code":""},{"path":"https://roche.github.io/crmPack/reference/size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Size of an Object — size","text":"","code":"size(object, ...)  # S4 method for McmcOptions size(object, ...)  # S4 method for CohortSizeRange size(object, dose, data)  # S4 method for CohortSizeDLT size(object, dose, data)  # S4 method for CohortSizeMax size(object, dose, data)  # S4 method for CohortSizeMin size(object, dose, data)  # S4 method for CohortSizeConst size(object, dose, ...)  # S4 method for CohortSizeParts size(object, dose, data)  # S4 method for Samples size(object, ...)"},{"path":"https://roche.github.io/crmPack/reference/size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Size of an Object — size","text":"object (McmcOptions Samples CohortSize) object size computed. ... used. dose next dose. data data input, object class Data.","code":""},{"path":"https://roche.github.io/crmPack/reference/size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Size of an Object — size","text":"size given object.","code":""},{"path":"https://roche.github.io/crmPack/reference/size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Size of an Object — size","text":"size(McmcOptions): compute number MCMC samples based McmcOptions object. size(CohortSizeRange): Determines size next cohort based range next dose falls . size(CohortSizeDLT): Determines size next cohort based number DLTs far. size(CohortSizeMax): Determines size next cohort based maximum multiple cohort size rules. size(CohortSizeMin): Determines size next cohort based minimum multiple cohort size rules. size(CohortSizeConst): Constant cohort size. size(CohortSizeParts): Determines size next cohort based parts. size(Samples): get number MCMC samples Samples object.","code":""},{"path":"https://roche.github.io/crmPack/reference/size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Size of an Object — size","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for the cohort size: #   - having cohort of size 1 for doses <10 #   - and having cohort of size 3 for doses >=10 mySize <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements,   data = data )  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples, model = model, data = data )  # Rule for the cohort size: #   - having cohort of size 1 if no DLTs were yet observed #   - and having cohort of size 3 if at least 1 DLT was already observed mySize <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements,   data = data )  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples, model = model, data = data )  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(   intervals = c(0, 10),   cohort_size = c(1, 3) )  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Combining the two rules for cohort size by taking the maximum of the sample sizes # of the single rules mySize <- maxSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements,   data = data )  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples, model = model, data = data )  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) )  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Combining the two rules for cohort size by taking the minimum of the sample sizes # of the single rules mySize <- minSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 1  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for having cohorts with constant cohort size of 3 mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value) #> [1] 3  # nolint end # nolint start  # create an object of class 'DataParts' data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  myIncrements <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 ) nextMaxDose <- maxDose(myIncrements,   data = data )  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for the cohort size: mySize <- CohortSizeParts(cohort_sizes = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 1  # nolint end # Set up the MCMC option in order to have a burn-in of 100 iterations and # then take every other iteration up to a collection of 200 samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 200)  my_samples <- Samples(   data = list(alpha = rnorm(200), beta = rnorm(200)),   options = my_options )  size(my_samples) #> [1] 200"},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop the trial? — stopTrial","title":"Stop the trial? — stopTrial","text":"function returns whether stop trial.  Stopping rule based precision MTD estimation. trial stopped, MTD can estimated sufficient precision. criteria based robust coefficient variation (CV) calculated posterior distribution. robust CV defined mad(MTD) / median(MTD), mad median absolute deviation. Stopping based based lowest non placebo dose. trial stopped lowest non placebo dose meets Hard Safety Rule, .e. deemed overly toxic. Stopping based observed data lowest dose level using Bin-Beta model based DLT probability.","code":""},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop the trial? — stopTrial","text":"","code":"stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMissingDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingList,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingAll,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingAny,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingCohortsNearDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingPatientsNearDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMinCohorts,ANY,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMinPatients,ANY,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTargetProb,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMTDdistribution,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMTDCV,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingLowestDoseHSRBeta,numeric,Samples,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTargetBiomarker,numeric,Samples,DualEndpoint,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingSpecificDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingHighestDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTDCIRatio,ANY,Samples,ModelTox,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTDCIRatio,ANY,missing,ModelTox,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMaxGainCIRatio,ANY,Samples,ModelTox,DataDual stopTrial(   stopping,   dose,   samples,   model,   data,   TDderive,   Effmodel,   Effsamples,   Gstarderive,   ... )  # S4 method for StoppingMaxGainCIRatio,ANY,missing,ModelTox,DataDual stopTrial(stopping, dose, model, data, Effmodel, ...)"},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop the trial? — stopTrial","text":"stopping (Stopping) rule stopping trial. dose recommended next best dose. samples (Samples) mcmc samples. model (GeneralModel) model. data (Data) input data. ... additional arguments without method dispatch. TDderive function derives input, vector posterior samples called TDsamples dose probability occurrence DLE equals either targetDuringTrial targetEndOfTrial, final next best TDtargetDuringTrial (dose probability occurrence DLE equals targetDuringTrial)TDtargetEndOfTrial estimate. Effmodel efficacy model ModelEff class object Effsamples efficacy samples Samples class object Gstarderive function derives input, vector posterior Gstar (dose gives maximum gain value) samples called Gstarsamples, final next best Gstar estimate.","code":""},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop the trial? — stopTrial","text":"logical value: TRUE trial can stopped, FALSE otherwise. attribute message gives reason decision.","code":""},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Stop the trial? — stopTrial","text":"stopTrial(   stopping = StoppingMissingDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based value returned next best dose. stopTrial(   stopping = StoppingList,   dose = ,   samples = ,   model = ,   data = ): Stop based multiple stopping rules stopTrial(   stopping = StoppingAll,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment multiple stopping rules stopTrial(   stopping = StoppingAny,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment stopping rule stopTrial(   stopping = StoppingCohortsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number cohorts near next best dose stopTrial(   stopping = StoppingPatientsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number patients near next best dose stopTrial(   stopping = StoppingMinCohorts,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number cohorts stopTrial(   stopping = StoppingMinPatients,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number patients stopTrial(   stopping = StoppingTargetProb,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based probability target tox interval stopTrial(   stopping = StoppingMTDdistribution,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based MTD distribution stopTrial(   stopping = StoppingTargetBiomarker,   dose = numeric,   samples = Samples,   model = DualEndpoint,   data = ): Stop based probability targeting biomarker stopTrial(   stopping = StoppingSpecificDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stopping rule met specific dose planned dose grid just default next best dose. stopTrial(   stopping = StoppingHighestDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop highest dose reached stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples given stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples involved stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses DLE efficacy samples also used. stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses without DLE efficacy samples involved.","code":""},{"path":"https://roche.github.io/crmPack/reference/stopTrial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop the trial? — stopTrial","text":"","code":"## Example of combining stopping rules with '&' and/or '|' operators  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 & myStopping2) | myStopping3     # Example of usage for `StoppingMissingDose` StopTrial class.  # Create the data. my_data <- Data(   x = c(0.01, 0.1, 0.5, 3, 6, 10, 10, 10),   y = c(0, 1, 1, 0, 0, 0, 0, 1),   cohort = c(1, 1, 2, 3, 4, 5, 5, 5),   ID = 1:8,   doseGrid = c(     0.01, 0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   placebo = TRUE )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 )  my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  next_max_dose <- maxDose(my_increments,   data = my_data )  # Define the rule which will be used to select the next best dose based # on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.1, 0.25),   overdose = c(0.2, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = my_samples, model = my_model, data = my_data )  # Define the stopping rule such that the study would be stopped if there is # no safe active dose returned from dose_recommendation. my_stopping <- StoppingMissingDose() my_stopping <- StoppingAny(   stop_list = c(     StoppingMinPatients(nPatients = 16),     StoppingMissingDose()   ) )  # Evaluate if to stop the trial. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   data = my_data,   model = my_model ) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 16\" #>  #> attr(,\"message\")[[2]] #> [1] \"Next dose is NA , i.e., no active dose is safe enough according to the NextBest rule.\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 16\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Next dose is NA , i.e., no active dose is safe enough according to the NextBest rule.\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that the study # would be stopped if 'any' of the single stopping rules is TRUE. mystopping <- StoppingList(stop_list=c(myStopping1,myStopping2,myStopping3),                            summary=any)  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAll' myStopping <- (myStopping1 | myStopping2) & myStopping3  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAny' myStopping <- (myStopping1 | myStopping2) | myStopping3  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 34 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"message\")[[3]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 34 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 3 # cohorts were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingCohortsNearDose(nCohorts = 3,                                       percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 cohorts lie within 0.2% of the next best dose 20. This is below the required 3 cohorts\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 9 # patients were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingPatientsNearDose(nPatients = 9,                                        percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0.2% of the next best dose 20. This is below the required 9 patients\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 6 # cohorts were already dosed myStopping <- StoppingMinCohorts(nCohorts = 6)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 6\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 20 # patients were already dosed myStopping <- StoppingMinPatients(nPatients = 20)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] myStopping <- StoppingTargetProb(target=c(0.2, 0.35),                                  prob=0.5)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 39 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.9 probability that MTD > 0.5*next_best_dose. Here MTD is defined as the dose for # which prob(DLE)=0.33 myStopping <- StoppingMTDdistribution(target = 0.33,                                       thresh = 0.5,                                       prob = 0.9)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability of MTD above 50 % of current dose 20 is 91 % and thus greater than or equal to the required 90 %\" #> attr(,\"report_label\") #> [1] NA  # nolint end # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100, step = 2, samples = 2000, rng_kind = \"Mersenne-Twister\", rng_seed = 94 ) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33)) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rule such that the study would be stopped if the # the MTD can be estimated with sufficient precision, i.e. if robust coefficient # of variation is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)  # Evaluate if to stop the trial. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = my_samples,   model = my_model,   data = my_data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"CV of MTD is 70 % and thus above the required precision threshold of 40 %\" #> attr(,\"report_label\") #> [1] NA  # Create the data. data <- Data(   x = c(0.1, 0.1, 0.1),   y = c(0, 0, 1),   cohort = c(1, 1, 1),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   ID = 1:3 )  # Initialize the CRM model used to model the data. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  next_max_dose <- maxDose(my_increments, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(my_next_best,   doselimit = next_max_dose,   samples = samples, model = model, data = data )  # Define the stopping rule such that the study would be stopped if first dose # is toxic based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Evaluate if the trial will be stopped. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability that the lowest active dose of 0.1 being toxic based on posterior Beta distribution using a Beta(1,1) prior is 65% and thus below the required 90% threshold.\" #> attr(,\"report_label\") #> [1] NA # nolint start  # Create the data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # In this case target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety) myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples,                                model=model,                                data=data)  # Define the stopping rule such that the study would be stopped if if there is at # least 0.5 posterior probability that the biomarker (efficacy) is within the # biomarker target range of [0.9, 1.0] (relative to the maximum for the biomarker). myStopping <- StoppingTargetBiomarker(target = c(0.9, 1),                                       prob = 0.5)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target biomarker is 12 % for dose 6 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA  # nolint end  # Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_nb_ncrm <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. my_dose_recommendation <- nextBest(   nextBest = my_nb_ncrm,   doselimit = 100,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rules. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 ) max_patients <- StoppingMinPatients(nPatients = 20) patients_near_dose <- StoppingPatientsNearDose(nPatients = 3, percentage = 0)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that # the study would be stopped if 'any' of the single stopping rules is TRUE. my_stopping <- highest_dose_safe | max_patients | patients_near_dose  # Evaluate if to stop the Trial stopTrial(   stopping = my_stopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 0 % for dose 80 and thus below the required 80 %\" #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 17 and thus below the prespecified minimum number 20\" #>  #> attr(,\"message\")[[3]] #> [1] \"1 patients lie within 0% of the next best dose 6. This is below the required 3 patients\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 0 % for dose 80 and thus below the required 80 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 17 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"1 patients lie within 0% of the next best dose 6. This is below the required 3 patients\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40,                  80, 80, 80),              y=c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] stopTarget <- StoppingTargetProb(target=c(0.2, 0.35),                                  prob=0.5)  ## now use the StoppingHighestDose rule: stopHigh <-   StoppingHighestDose() &   StoppingPatientsNearDose(nPatients=3, percentage=0) &   StoppingTargetProb(target=c(0, 0.2),                      prob=0.5)  ## and combine everything: myStopping <- stopTarget | stopHigh  # Then evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 53 % for dose 64 and thus above the required 50 %\" #>  #> attr(,\"message\")[[2]] #> attr(,\"message\")[[2]][[1]] #> [1] \"Next best dose is 64 and thus not the highest dose\" #>  #> attr(,\"message\")[[2]][[2]] #> [1] \"0 patients lie within 0% of the next best dose 64. This is below the required 3 patients\" #>  #> attr(,\"message\")[[2]][[3]] #> [1] \"Probability for target toxicity is 23 % for dose 64 and thus below the required 50 %\" #>  #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 53 % for dose 64 and thus above the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Next best dose is 64 and thus not the highest dose\" #>  #> attr(,\"message\")[[2]] #> [1] \"0 patients lie within 0% of the next best dose 64. This is below the required 3 patients\" #>  #> attr(,\"message\")[[3]] #> [1] \"Probability for target toxicity is 23 % for dose 64 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Next best dose is 64 and thus not the highest dose\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0% of the next best dose 64. This is below the required 3 patients\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 23 % for dose 64 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses with samples ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!  ##model can be specified of 'Model' or 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##define MCMC options ##for illustration purpose we use 10 burn-in and generate 50 samples options<-McmcOptions(burnin=10,step=2,samples=50) ##samples of 'Samples' class samples<-mcmc(data,model,options) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35, prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  RecommendDose<-nextBest(tdNextBest,doselimit=max(data@doseGrid),samples=samples,                         model=model,data=data) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,dose=RecommendDose$next_dose_drt,           samples=samples,model=model,data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"95% CI is (2.87962060593632e-11, 11670.3899178591), Ratio = 405275260699296 is greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!  ##model must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest<-NextBestTD(prob_target_drt=0.35,prob_target_eot=0.3)   RecommendDose<-nextBest(tdNextBest,doselimit=max(data@doseGrid),model=model,data=data) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,dose=RecommendDose$next_dose_drt,           model=model,data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"95% CI is ( 15.2619 , 173.8695 ), Ratio = 11.3924 is  greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##for illustration purpose we use 10 burn-in and generate 50 samples options<-McmcOptions(burnin=10,step=2,samples=50) ##DLE and efficacy samples must be of 'Samples' class DLEsamples<-mcmc(data,DLEmodel,options) Effsamples<-mcmc(data,Effmodel,options)  ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  RecommendDose<-nextBest(mynextbest,doselimit=max(data@doseGrid),samples=DLEsamples,model=DLEmodel,                         data=data,model_eff=Effmodel,samples_eff=Effsamples) #> [1] \"Estimated TD 35 = 14.8679719869239 not within dose grid\" #> [1] \"Estimated TD 30 = 9.60973788445752 not within dose grid\" #> [1] \"Estimated max gain dose = 300 not within dose grid\" ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,           dose=RecommendDose$next_dose,           samples=DLEsamples,           model=DLEmodel,           data=data,           TDderive=function(TDsamples){             quantile(TDsamples,prob=0.3)},           Effmodel=Effmodel,           Effsamples=Effsamples,           Gstarderive=function(Gstarsamples){             quantile(Gstarsamples,prob=0.5)}) #> [1] FALSE #> attr(,\"message\") #> [1] \"Gstar estimate is 300 with 95% CI ( 25 , 300 ) and its ratio = 12\"                                                        #> [2] \"TDtargetEndOfTrial estimate is  9.6097 with 95% CI ( 0.0014 , 2.68928250388782e+39 ) and its ratio= 1.93690997062722e+42\" #> [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 1.93690997062722e+42  which is  greater than target_ratio = 5\"        #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data)   ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest<-NextBestMaxGain(prob_target_drt=0.35, prob_target_eot=0.3)  RecommendDose<-nextBest(mynextbest,doselimit=max(data@doseGrid),model=DLEmodel,                         model_eff=Effmodel,data=data)  ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial   stopTrial(stopping=myStopping,dose=RecommendDose$next_dose,model=DLEmodel,           data=data, Effmodel=Effmodel) #> [1] FALSE #> attr(,\"message\") #> [1] \"Gstar estimate is 94.942 with 95% CI ( 16.771 , 537.4745 ) and its ratio = 32.0479\"                  #> [2] \"TDtargetEndOfTrial estimate is  81.4924 with 95% CI ( 24.3435 , 272.804 ) and its ratio= 11.2064\"    #> [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 11.2064 which is  greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] NA  # nolint end"},{"path":"https://roche.github.io/crmPack/reference/summary-DualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"Summarize dual-endpoint design simulations, relative given true dose-toxicity dose-biomarker curves","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# S4 method for DualSimulations summary(object, trueTox, trueBiomarker, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object DualSimulations object want summarize trueTox function takes input dose (vector) returns true probability (vector) toxicity. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied trueTox trueBiomarker","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object class DualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))   # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 )  # For illustration stop with 6 subjects. my_stopping <- my_stopping1 | StoppingMinPatients(6) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)   # Run the simulation on the desired design. # For illustration purposes 1 trial is simulated with 5 burn-ins to generate 20 samples. my_sims <- simulate(   object = design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Summarize the results of the simulations. summary(   my_sims,   trueTox = true_tox,   trueBiomarker = true_biomarker ) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 51.6, 56.1  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 6 (6, 6)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 1 (1, 1)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 1  #> Observed toxicity rate at dose most often selected: 0 % #> Fitted toxicity rate at dose most often selected : mean 5 % (5 %, 5 %)  #> Fitted biomarker level at dose most often selected : mean 0.2 (0.2, 0.2)"},{"path":"https://roche.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"","code":"# S4 method for GeneralSimulations summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object GeneralSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object class GeneralSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"Summary Pseudo Dual responses simulations given pseudo DLE model Flexible efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# S4 method for PseudoDualFlexiSimulations summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object PseudoDualFlexiSimulations object want summarize trueDLE function takes input dose (vector) returns true probability DLE (vector) trueEff vector takes input true mean efficacy values dose levels (order) targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# nolint start  ## If DLE and efficacy responses are considered in the simulations and the 'EffFlexi' class is used ## we need a data object with doses >= 1: data <- DataDual(doseGrid = seq(25, 300, 25)) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## for the efficacy model Effmodel <- EffFlexi(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1), sigma2betaW = c(a = 20, b = 50), rw1 = FALSE, data = data )   ## specified the next best mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 10 subjects are treated: ## very low sample size is just for illustration here myStopping <- StoppingMinPatients(nPatients = 10)  ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )   ## specify the options for MCMC # For illustration purpose, we use 10 burn-in and generate 100 samples options <- McmcOptions(burnin = 10, step = 1, samples = 100) ## The simulation ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   nsim = 1,   seed = 819,   parallel = FALSE,   mcmcOptions = options ) ## summarize the simulation results summary(mySim,   trueDLE = myTruthDLE,   trueEff = myTruthEff ) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 0 (0, 0)  #> Number of patients treated above the target p(DLE) used during a trial : mean 0 (0, 0)  #> Proportions of observed DLT in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients : mean 0 % (0 %, 0 %)  #> Doses selected as TDEOT : mean 0 (0, 0)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    6.222   6.222   6.222   6.222   6.222   6.222   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 125  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      250     250     250     250     250     250   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.192   2.192   2.192   2.192   2.192   2.192   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)   # nolint end"},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"Summary Pseudo Dual responses simulations, relative given pseudo DLE efficacy model (except EffFlexi class model)","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# S4 method for PseudoDualSimulations summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object PseudoDualSimulations object want summarize trueDLE function takes input dose (vector) returns true probability (vector) DLE trueEff function takes input dose (vector) returns mean efficacy value(s) (vector). targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations.  # Specified simulations when no samples are used. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # Specify the simulations and generate the 2 trials. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)   # Example where DLE and efficacy samples are involved. # Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details.  # Specify the next best rule. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # For illustration purpose 2 simulation are created. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2045 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)"},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"# S4 method for PseudoSimulations summary(object, truth, targetEndOfTrial = 0.3, targetDuringTrial = 0.35, ...)"},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object PseudoSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity targetEndOfTrial target probability DLE wanted achieve end trial targetDuringTrial target probability DLE wanted achieve trial ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object class PseudoSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"emptydata <- Data(doseGrid = seq(25, 300, 25))  # The design incorporate DLE responses and DLE samples. # Specify the model of 'ModelTox' class eg 'LogisticIndepBeta' class model. my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The escalation rule. td_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Cohort size is 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Stopp when the maximum sample size of 36 patients has been reached or the next # dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'TDDesign' example.) my_design <- TDDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the truth of the DLE responses. my_truth <- probFunction(my_model, phi1 = -53.66584, phi2 = 10.50499)  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # Refer to design-method 'simulate TDDesign' examples for details. # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   parallel = FALSE,   mcmcOptions = my_options )  # Produce a summary of the simulations. summary(   my_sim,   truth = my_truth ) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>   # Example where DLE samples are involved.  # Specify the next best rule. td_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # The design. my_design <- TDsamplesDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # For illustration purpose 2 trials are simulated. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 2,   seed = 819,   mcmcOptions = my_options,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   truth = my_truth ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>"},{"path":"https://roche.github.io/crmPack/reference/summary-Simulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"Summarize model-based design simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-Simulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# S4 method for Simulations summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/reference/summary-Simulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object Simulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-Simulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object class SimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/reference/summary-Simulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 ) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE,   derive = list(     max_mtd = max,     mean_mtd = mean,     median_mtd = median   ), ))[3]  # Summarize the Results of the Simulations summary(mySims, truth = myTruth) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 22 (22, 22)  #> Number of patients treated above target tox interval : mean 9 (9, 9)  #> Proportions of DLTs in the trials : mean 27 % (27 %, 27 %)  #> Mean toxicity risks for the patients on active : mean 31 % (31 %, 31 %)  #> Doses selected as MTD : mean 20 (20, 20)  #> True toxicity at doses selected : mean 22 % (22 %, 22 %)  #> Proportion of trials selecting target MTD: 100 % #> Dose most often selected as MTD: 20  #> Observed toxicity rate at dose most often selected: 25 % #> Fitted toxicity rate at dose most often selected : mean 25 % (25 %, 25 %)   # nolint end"},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating Data Objects — update,Data-method","title":"Updating Data Objects — update,Data-method","text":"method updates existing Data object new data.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating Data Objects — update,Data-method","text":"","code":"# S4 method for Data update(   object,   x,   y,   ID = length(object@ID) + seq_along(y),   new_cohort = TRUE,   check = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating Data Objects — update,Data-method","text":"object (Data) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ID (integer) patient IDs. can also supply numeric vectors, converted integer internally. new_cohort (flag) TRUE (default) new data assigned new cohort. check (flag) whether validation updated object conducted. See details . ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating Data Objects — update,Data-method","text":"new, updated Data object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Updating Data Objects — update,Data-method","text":"current implementation update method allows updating Data class object adding single dose level x . However, might use cases new cohort added contains placebo active dose. Hence, update need performed iteratively calling update method twice. example, first call user can add placebo, second call, active dose. Since cohort placebo allowed, update method normally throw error attempting add placebo first call. allow updates, check parameter set FALSE first call.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-Data-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating Data Objects — update,Data-method","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0L, 1L, 1L)) my_data1 #> An object of class \"Data\" #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDA Objects — update,DataDA-method","title":"Updating DataDA Objects — update,DataDA-method","text":"method updates existing DataDA object new data.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# S4 method for DataDA update(object, u, t0, trialtime, y, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDA Objects — update,DataDA-method","text":"object (DataDA) object want update. u (numeric) new DLT free survival times patients, .e. existing patients object well new patients. t0 (numeric) time patient starts DLT observation window. parameter covers patients, .e. existing patients object well new patients. trialtime (number) current time trial, .e. followup time. y (numeric) new DLTs patients, .e. existing patients object well new patients. ... arguments passed Data update method update-Data. used new patients added cohort. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDA Objects — update,DataDA-method","text":"new, updated DataDA object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Updating DataDA Objects — update,DataDA-method","text":"function capable adding new patients also updates existing ones respect y, t0, u slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDA-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# Create an object of class 'DataDA'. my_data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data. my_data1 <- update(   object = my_data,   y = c(my_data@y, 0), # The 'y' will be updated according to 'u'.   u = c(my_data@u, 20),   t0 = c(my_data@t0, 95),   x = 20,   trialtime = 120 # This is the global timeline for a trial. ) my_data1 #> An object of class \"DataDA\" #> Slot \"u\": #> [1] 42 30 15  5 20 25 30 35 20 #>  #> Slot \"t0\": #> [1]  0 15 30 40 55 70 75 85 95 #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 #>  #> Slot \"y\": #> [1] 0 0 1 1 0 0 1 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1]  1  2  3  4  5  6  6  6 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 9 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 7 #>  #> Slot \"nObs\": #> [1] 9 #>"},{"path":"https://roche.github.io/crmPack/reference/update-DataDual-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDual Objects — update,DataDual-method","title":"Updating DataDual Objects — update,DataDual-method","text":"method updates existing DataDual object new data.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDual-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# S4 method for DataDual update(object, w, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/update-DataDual-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDual Objects — update,DataDual-method","text":"object (DataDual) object want update. w (numeric) continuous vector biomarker values patients update. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDual-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDual Objects — update,DataDual-method","text":"new, updated DataDual object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataDual-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0, 1, 1), w = c(0.4, 1.2, 2.2)) my_data1 #> An object of class \"DataDual\" #> Slot \"w\": #>  [1] -0.16751154  0.70445775 -0.69464530 -0.13104399  1.15884973 -0.82885674 #>  [7] -0.01927325  0.40794502  0.40000000  1.20000000  2.20000000 #>  #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataOrdinal Objects — update,DataOrdinal-method","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"method updates existing DataOrdinal object new data.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"","code":"# S4 method for DataOrdinal update(   object,   x,   y,   ID = length(object@ID) + seq_along(y),   new_cohort = TRUE,   check = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"object (DataOrdinal) object want update. x (number) dose level (one level !). y (integer) vector toxicity grades (0, 1, 2, ...) patients cohort. can also supply numeric vectors, converted integer internally. ID (integer) patient IDs. can also supply numeric vectors, converted integer internally. new_cohort (flag) TRUE (default) new data assigned new cohort. check (flag) whether validation updated object conducted. See Details . ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"new, updated DataOrdinal object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"current implementation update method allows updating DataOrdinal class object adding single dose level x . However, might use cases new cohort added contains placebo active dose. Hence, update need performed iteratively calling update method twice. example, first call user can add placebo, second call, active dose. Since cohort placebo allowed, update method normally throw error attempting add placebo first call. allow updates, check parameter set FALSE first call.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"","code":"data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  update(data, x = 70, y = c(1L, 2L, 1L)) #> An object of class \"DataOrdinal\" #> Slot \"x\": #>  [1] 10 20 30 40 50 50 50 60 60 60 70 70 70 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 1 0 0 1 2 1 2 1 #>  #> Slot \"doseGrid\": #>  [1]  10  20  30  40  50  60  70  80  90 100 #>  #> Slot \"nGrid\": #> [1] 10 #>  #> Slot \"xLevel\": #>  [1] 1 2 3 4 5 5 5 6 6 6 7 7 7 #>  #> Slot \"yCategories\": #>     No tox Sub-tox AE        DLT  #>          0          1          2  #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 5 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 13 #>"},{"path":"https://roche.github.io/crmPack/reference/update-DataParts-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataParts Objects — update,DataParts-method","title":"Updating DataParts Objects — update,DataParts-method","text":"method updates existing DataParts object new data.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataParts-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# S4 method for DataParts update(object, x, y, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/reference/update-DataParts-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataParts Objects — update,DataParts-method","text":"object (DataParts) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataParts-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataParts Objects — update,DataParts-method","text":"new, updated DataParts object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-DataParts-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# Create an object of class 'DataParts'. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. # Note that since we reached the last level from 'part1Ladder' # then the 'nextPart' is switched from '1' to '2'. my_data1 <- update(my_data, x = 10, y = 0L) my_data1 #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 1 #>  #> Slot \"nextPart\": #> [1] 2 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 #>  #> Slot \"nObs\": #> [1] 4 #>"},{"path":"https://roche.github.io/crmPack/reference/update-ModelPseudo-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"Update method ModelPseudo model class. method update model class slots (estimates, parameters, variables etc.), new data (e.g. new observations responses) available. method mostly used obtain new modal estimates pseudo model parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# S4 method for ModelPseudo update(object, data, ...)"},{"path":"https://roche.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"object (ModelPseudo) model update. data (Data) currently available data. ... used.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"new ModelPseudo class object.","code":""},{"path":"https://roche.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# Update the 'LogisticIndepBeta' model with new data. empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model_lib <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # Then, we have some new observations data. data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data@doseGrid )  # Update the model to get new estimates. new_model_lib <- update(object = my_model_lib, data = data)  # Update the 'Effloglog' model with new data. empty_data_dual <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data_dual,   const = 0 )  # Data with new observations data. my_data_dual <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data_dual@doseGrid )  # Update the model to get new estimates. new_model_eff <- update(object = my_model_eff, data = my_data_dual)"},{"path":"https://roche.github.io/crmPack/reference/v_cohort_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"functions used internally validate format input CohortSize inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_cohort_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"","code":"v_cohort_size_range(object)  v_cohort_size_dlt(object)  v_cohort_size_const(object)  v_cohort_size_parts(object)  v_cohort_size_max(object)"},{"path":"https://roche.github.io/crmPack/reference/v_cohort_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"object (CohortSize) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_cohort_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_cohort_size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"v_cohort_size_range(): validates CohortSizeRange object contains valid intervals  cohort_size slots. v_cohort_size_dlt(): validates CohortSizeDLT object contains valid intervals  cohort_size slots. v_cohort_size_const(): validates CohortSizeConst object contains valid size slot. v_cohort_size_parts(): validates CohortSizeParts object contains valid sizes slot. v_cohort_size_max(): validates CohortSizeMax object contains valid cohort_sizes slot.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_data_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"functions used internally validate format input GeneralData inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_data_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"","code":"v_general_data(object)  h_doses_unique_per_cohort(dose, cohort)  v_data(object)  v_data_dual(object)  v_data_parts(object)  v_data_mixture(object)  v_data_da(object)  v_data_ordinal(object)  v_data_grouped(object)"},{"path":"https://roche.github.io/crmPack/reference/v_data_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"object (GeneralData) object validate. dose (numeric) dose values. cohort (integer) cohort indices parallel doses.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_data_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"character vector validation failure messages, TRUE case validation passes. TRUE dose unique per cohort, otherwise FALSE.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_data_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"v_general_data(): validates GeneralData object contains unique ID, non-negative cohort indices ID cohort vectors length nObs. h_doses_unique_per_cohort(): helper function verifies whether dose values unique every different cohort. v_data(): validates Data object contains valid elements respect types, dependency length. v_data_dual(): validates DataDual object contains valid biomarker vector respect type length. v_data_parts(): validates DataParts object contains valid elements respect types, dependency length. v_data_mixture(): validates DataMixture object contains valid elements respect types, dependency length. v_data_da(): validates DataDA object contains valid elements respect types, dependency length. v_data_ordinal(): validates DataOrdinal object contains valid elements respect types, dependency length. v_data_grouped(): validates DataGrouped object contains valid group information.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"functions used internally validate format input RuleDesign inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"","code":"v_rule_design(object)  v_design_grouped(object)"},{"path":"https://roche.github.io/crmPack/reference/v_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"object (RuleDesign) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_design.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"v_rule_design(): validates RuleDesign object contains valid startingDose. v_design_grouped(): validates DesignGrouped object contains valid flags.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_general_simulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"functions used internally validate format input GeneralSimulations inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_general_simulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"","code":"v_general_simulations(object)  v_simulations(object)  v_dual_simulations(object)  v_da_simulations(object)"},{"path":"https://roche.github.io/crmPack/reference/v_general_simulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"object (GeneralSimulations) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_general_simulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_general_simulations.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"v_general_simulations(): validates GeneralSimulations object contains valid data object valid dose simulations. v_simulations(): validates Simulations object contains valid object fit, stop_reasons, stop_report, additional_stats compared general class GeneralSimulations. v_dual_simulations(): validates DualSimulations object capture dose-biomarker fits, sigma2W rho estimates. v_da_simulations(): validates DASimulations object contains valid trialduration vector trial duration values simulations.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_increments.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Increments Objects — v_increments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"functions used internally validate format input Increments inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_increments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"","code":"v_increments_relative(object)  v_increments_relative_parts(object)  v_increments_relative_dlt(object)  v_increments_dose_levels(object)  v_increments_hsr_beta(object)  v_increments_min(object)"},{"path":"https://roche.github.io/crmPack/reference/v_increments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"object (Increments) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_increments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_increments.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"v_increments_relative(): validates IncrementsRelative object contains valid intervals increments parameters. v_increments_relative_parts(): validates IncrementsRelativeParts object contains valid dlt_start clean_start parameters. v_increments_relative_dlt(): validates IncrementsRelativeDLT object contains valid intervals increments parameters. v_increments_dose_levels(): validates IncrementsDoseLevels object contains valid levels basis_level option. v_increments_hsr_beta(): validates IncrementsHSRBeta object contains valid probability target, threshold shape parameters. v_increments_min(): validates IncrementsMin object contains list Increments objects.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"functions used internally validate format input McmcOptions inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"","code":"v_mcmc_options(object)"},{"path":"https://roche.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"object (McmcOptions) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"v_mcmc_options(): validates McmcOptions object contains valid integer scalars iterations, burnin step well proper parameters Random Number Generator.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"functions used internally validate format input GeneralModel ModelPseudo inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"","code":"v_general_model(object)  v_model_logistic_kadane(object)  v_model_logistic_kadane_beta_gamma(object)  v_model_logistic_normal_mix(object)  v_model_logistic_normal_fixed_mix(object)  v_model_logistic_log_normal_mix(object)  v_model_dual_endpoint(object)  v_model_dual_endpoint_rw(object)  v_model_dual_endpoint_beta(object)  v_model_dual_endpoint_emax(object)  v_model_logistic_indep_beta(object)  v_model_eff_log_log(object)  v_model_eff_flexi(object)  v_model_da_logistic_log_normal(object)  v_model_tite_logistic_log_normal(object)  v_model_one_par_exp_normal_prior(object)  v_model_one_par_exp_prior(object)"},{"path":"https://roche.github.io/crmPack/reference/v_model_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"object (GeneralModel) (ModelPseudo)  object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"v_general_model(): validates names arguments init function included datanames datanames_prior slots. v_model_logistic_kadane(): validates logistic Kadane model parameters valid. v_model_logistic_kadane_beta_gamma(): validates logistic Kadane model parameters beta gamma prior valid. v_model_logistic_normal_mix(): validates weightpar valid. v_model_logistic_normal_fixed_mix(): validates component list valid ModelParamsNormal objects well weights correct. v_model_logistic_log_normal_mix(): validates share_weight represents probability. v_model_dual_endpoint(): validates DualEndpoint class slots valid. v_model_dual_endpoint_rw(): validates DualEndpointRW class slots valid. v_model_dual_endpoint_beta(): validates DualEndpointBeta class slots valid. v_model_dual_endpoint_emax(): validates DualEndpointEmax class slots valid. v_model_logistic_indep_beta(): validates LogisticIndepBeta class slots valid. v_model_eff_log_log(): validates Effloglog class slots valid. v_model_eff_flexi(): validates EffFlexi class slots valid. v_model_da_logistic_log_normal(): validates DALogisticLogNormal class slots valid. v_model_tite_logistic_log_normal(): validates TITELogisticLogNormal class slots valid. v_model_one_par_exp_normal_prior(): validates OneParLogNormalPrior class slots valid. v_model_one_par_exp_prior(): validates OneParExpPrior class slots valid.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"functions used internally validate format object model parameters inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"","code":"v_model_params_normal(object)"},{"path":"https://roche.github.io/crmPack/reference/v_model_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"object (ModelParamsNormal) multivariate normal parameters object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_model_params.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"v_model_params_normal(): helper function validates multivariate normal parameters.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_next_best.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"functions used internally validate format input NextBest inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_next_best.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"","code":"v_next_best_mtd(object)  v_next_best_ncrm(object)  v_next_best_ncrm_loss(object)  v_next_best_dual_endpoint(object)  v_next_best_min_dist(object)  v_next_best_inf_theory(object)  v_next_best_td(object)  v_next_best_td_samples(object)  v_next_best_max_gain_samples(object)  v_next_best_prob_mtd_lte(object)  v_next_best_prob_mtd_min_dist(object)"},{"path":"https://roche.github.io/crmPack/reference/v_next_best.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"object (NextBest) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_next_best.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_next_best.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"v_next_best_mtd(): validates NextBestMTD object contains valid target probability derive function. v_next_best_ncrm(): validates NextBestNCRM object contains valid target probability, overdose max_overdose_prob probability ranges. v_next_best_ncrm_loss(): validates NextBestNCRMLoss object contains valid objects. v_next_best_dual_endpoint(): validates NextBestDualEndpoint object contains valid probability objects. v_next_best_min_dist(): validates NextBestMinDist object contains valid target object. v_next_best_inf_theory(): validates NextBestInfTheory object contains valid target asymmetry objects. v_next_best_td(): validates NextBestTD object contains valid prob_target_drt prob_target_eot probabilities. v_next_best_td_samples(): validates NextBestTDsamples object contains valid derive function. v_next_best_max_gain_samples(): validates NextBestMaxGainSamples object contains valid derive mg_derive functions. v_next_best_prob_mtd_lte(): validates NextBestProbMTDLTE object contains valid target probability method string value. v_next_best_prob_mtd_min_dist(): validates NextBestProbMTDMinDist object contains valid target probability method string value.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_pseudo_simulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"functions used internally validate format input PseudoSimulations inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_pseudo_simulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"","code":"v_pseudo_simulations(object)  v_pseudo_dual_simulations(object)  v_pseudo_dual_flex_simulations(object)"},{"path":"https://roche.github.io/crmPack/reference/v_pseudo_simulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"object (PseudoSimulations) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_pseudo_simulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_pseudo_simulations.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"v_pseudo_simulations(): validates PseudoSimulations object contains valid fit, FinalTDtargetEndOfTrialEstimates , FinalTDtargetDuringTrialAtDoseGrid,FinalTDtargetEndOfTrialAtDoseGrid , FinalTDEOTCIs, FinalTDEOTRatios, FinalCIs, FinalRatios, object valid stopReasons simulations. v_pseudo_dual_simulations(): validates PseudoDualSimulations object contains valid fitEff, FinalGstarEstimates , FinalGstarAtDoseGrid, FinalGstarCIs , FinalGstarRatios, FinalOptimalDose, FinalOptimalDoseAtDoseGrid object valid sigma2est simulations. v_pseudo_dual_flex_simulations(): validates PseudoDualFlexiSimulations object contains valid sigma2betaWest vector final posterior mean sigma2betaW estimates.FinalGstarEstimates , FinalGstarAtDoseGrid,","code":""},{"path":"https://roche.github.io/crmPack/reference/v_safety_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"functions used internally validate format input SafetyWindow inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_safety_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"","code":"v_safety_window_size(object)  v_safety_window_const(object)"},{"path":"https://roche.github.io/crmPack/reference/v_safety_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"object (SafetyWindow) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_safety_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_safety_window.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"v_safety_window_size(): validates SafetyWindowSize object contains valid slots. v_safety_window_const(): validates SafetyWindowConst object contains valid slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_samples_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"functions used internally validate format input Samples inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_samples_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"","code":"v_samples(object)"},{"path":"https://roche.github.io/crmPack/reference/v_samples_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"object (Samples) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_samples_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_samples_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"v_samples(): validates Samples object contains valid data slot.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"functions used internally validate format input Stopping inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"","code":"v_stopping_cohorts_near_dose(object)  v_stopping_patients_near_dose(object)  v_stopping_min_cohorts(object)  v_stopping_min_patients(object)  v_stopping_target_prob(object)  v_stopping_mtd_distribution(object)  v_stopping_mtd_cv(object)  v_stopping_target_biomarker(object)  v_stopping_list(object)  v_stopping_all(object)  v_stopping_tdci_ratio(object)"},{"path":"https://roche.github.io/crmPack/reference/v_stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"object (Stopping) object validate.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/reference/v_stopping.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"v_stopping_cohorts_near_dose(): validates StoppingCohortsNearDose object contains valid nCohorts percentage parameters. v_stopping_patients_near_dose(): validates StoppingPatientsNearDose object contains valid nPatients percentage parameters. v_stopping_min_cohorts(): validates StoppingMinCohorts object contains valid nCohorts parameter. v_stopping_min_patients(): validates StoppingMinPatients object contains valid nPatients parameter. v_stopping_target_prob(): validates StoppingTargetProb object contains valid target prob parameters. v_stopping_mtd_distribution(): validates StoppingMTDdistribution object contains valid target, thresh prob parameters. v_stopping_mtd_cv(): validates StoppingMTDCV object contains valid probability target percentage threshold. v_stopping_target_biomarker(): validates StoppingTargetBiomarker object contains valid target, is_relative probslots. v_stopping_list(): validates StoppingList object contains valid stop_list, summary slots. v_stopping_all(): validates StoppingAll object contains valid stop_list slot. v_stopping_tdci_ratio(): validates StoppingTDCIRatio object contains valid target_ratio  prob_target slots.","code":""},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the safety window length of the next cohort — windowLength","title":"Determine the safety window length of the next cohort — windowLength","text":"function determines safety window length next cohort.","code":""},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"windowLength(safetyWindow, size, ...)  # S4 method for SafetyWindowSize windowLength(safetyWindow, size, data, ...)  # S4 method for SafetyWindowConst windowLength(safetyWindow, size, ...)"},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the safety window length of the next cohort — windowLength","text":"safetyWindow rule, object class SafetyWindow size next cohort size ... additional arguments data data input, object class DataDA","code":""},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength list safety window parameters (gap, follow, follow_min)","code":""},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength(SafetyWindowSize): Determine safety window length based cohort size windowLength(SafetyWindowConst): Constant safety window length","code":""},{"path":"https://roche.github.io/crmPack/reference/windowLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"# nolint start  # Create the data data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=c(0,15,30,40,55,70,75,85),                Tmax=60) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior<-function(k){   npiece_/(data@Tmax*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose=doseRecommendation$value, data = data)  # Rule for the safety window length: #   -having patientGap as (0,7,3,3,...) for cohort size <4 #   -and having patientGap as (0,9,5,5,...) for cohort size >=4 myWindowLength <- SafetyWindowSize(gap = list(c(7,3),c(9,5)),                                    size = c(1,4),                                    follow = 7,                                    follow_min = 14)  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size=sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end # nolint start  # Create the data data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=c(0,15,30,40,55,70,75,85),                Tmax=60) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior<-function(k){   npiece_/(data@Tmax*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose=doseRecommendation$value, data = data)  # Rule for having safety window length with constant safety window parameters myWindowLength <- SafetyWindowConst(gap = c(7,3),                                     follow = 7,                                     follow_min = 14)  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size=sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end"},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-1090009133","dir":"Changelog","previous_headings":"","what":"Version 1.0.9000.9133","title":"Version 1.0.9000.9133","text":"Removed multiplot function. Use Please use equivalent functionality packages, cowplot ggpubr. Added new DataGrouped DesignGrouped classes corresponding model LogisticLogNormalGrouped support simultaneous dose escalation monotherapy combination therapy arms. Created CrmPackClass class ultimate ancestor crmPack classes allow identification crmPack classes simpler definition generic methods. approximate now returns list containing fitted model , optionally, ggplot object approximated dose/toxicity curve. Modified wording attribute stopTrial’s return value StoppingMTDdistribution objects strictly match definition given online documentation. return value unchanged. Corrected spelling name messgae [sic] attribute return value stopTrial signature stopping = \"StoppingTDCIRatio\". Changed type ref_dose LogisticNormalMixture LogisticNormalFixedMixture classes positive_number numeric consistency classes. Added -parameter constructor functions named .Default<class name> provide usable instances concrete subclasses Increments, Model, NextBest Stopping. Added new function dose_grid_range returns range doses dose grid. Added new function ngrid returns number doses dose grid. Modified efficacy-EffFlexi method: allowed vectorized dose; NA now returned doses outside dose grid range (warning thrown). Added new custom checkmate function check_range. Added method names objects class Samples. Added method size objects class Samples. Added new custom checkmate function check_length. Added unique flag assert_probabilities checkmate custom functions. Created new vignette describes use certain functions features crmPack major refactoring. Removed MASS Imports Rcpp, RcppArmadillo Suggests used old development version. doselimit argument nextBest method now specified Inf instead numeric(0). Added new helper functions nextBest methods, particularly plotting finding dose closest grid. Added new NextBestNCRMLoss class corresponding nextBest method. Warning message printed anymore nextBest methods doselimit specified. Set prototype target = 0.3 NextBestMinDist class. Added new customized checkmate functions probability values checking. Renamed argument derive function mtdSamples mtd_samples NextBestMTD class. Allowed from_prior flag - argument modelspecs function GeneralModel class. Created new ProbitLogNormalRel model class support (standardized) dose. Changed ProbitLogNormal supports log (standardized) dose . Added logger feature. user interface consists four functions: enable_logging, disable_logging, is_logging_enabled, log_trace. Re-factored sampleSize function returns 0 burnin > iterations. vector t0 slot DataDA class must sorted ascending order. Replaced warning message cohort ID provided user constructor Data. Introduced validation updated object update methods Data-like classes. Added check flag possibly omit validation updated object. Set package use testthat. Added lifecycle package. Include rolling CRM design, previously available separate GitHub branch. Additional authors change maintainer. Included ‘additional_stats’ add reporting additional parameters method simulate summarize MTD. ‘report_label’ can added stopping rules individual combined stopping rule reporting.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2019-06-13 Reference JSS publication.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-029","dir":"Changelog","previous_headings":"","what":"Version 0.2.9","title":"Version 0.2.9","text":"CRAN release: 2018-12-21 default use 5 cores available cores machine. Note value can also changed user. Change maintainer","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-8","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.8","text":"PLcohortSize now defaults 0 placebo patients upon Design class initialization (instead 1 - note effect erroneous simulations, due option set Data class) “examine” function also stops stopping rules fulfilled already case DLTs occurring. case beforehand lead infinite looping (thanks John Kirkpatrick reporting bug) Removed RW2 warnings “DualEndpointRW” - seems work nicely now (thanks Charles Warne reporting!) Removed WinBUGS since used anyway (paper describe )","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"new-features-0-2-8","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.8","text":"“examine” function now counts number times dose recommended contiguously break e.g. default 100 times (can specified new option “examine”) avoid infinite loops issues corresponding warning condition met New “Increments” class “IncrementsNumDoseLevels” works directly number dose levels dose grid can incremented current next cohort (thanks John Kirkpatrick suggestion). can example used order force design skip dose level escalating. Included JSS manuscript new vignette. now possible specify many cores used parallel computations used.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-027","dir":"Changelog","previous_headings":"","what":"Version 0.2.7","title":"Version 0.2.7","text":"CRAN release: 2018-03-13","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-7","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.7","text":"LogisticNormal now works - prec found .","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-026","dir":"Changelog","previous_headings":"","what":"Version 0.2.6","title":"Version 0.2.6","text":"CRAN release: 2018-02-15","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-6","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.6","text":"Replaced BayesLogit dependency JAGS code, since BayesLogit taken CRAN. Speed one example pass CRAN check.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/news/index.html","id":"new-features-0-2-5","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.5","text":"matching doses dose grid now includes tolerance 1e-10, order make user-friendly (thanks YJ Choi Giuseppe investigating)","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-5","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.5","text":"minor fix alpha1 description LogisticLogNormal-class minor fix scale_colour_manual import ggplot2 reported R-Core","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/news/index.html","id":"new-features-0-2-4","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.4","text":"case multiple nextBest plots now also returned original plots list singlePlots, allow customization, jointly plotting . ProbitLogNormal: Now also model allows reference dose log transformation (standardized) dose. can specified options refDose useLogDose. DualEndpoint: additional options ProbitLogNormal now available DualEndpoint models. consequence, parameter “refDose” class DualEndpointBeta needed renamed “refDoseBeta”, parameter “refDose” class DualEndpointEmax renamed “refDoseEmax”.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-4","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.4","text":"documentation: DualEndpoint description fixed problem formula","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/news/index.html","id":"new-features-0-2-3","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.3","text":"New increment class “IncrementMin” added allows combine multiple increment rules MIN operation","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-021","dir":"Changelog","previous_headings":"","what":"Version 0.2.1","title":"Version 0.2.1","text":"CRAN release: 2017-05-03","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.1","text":"Option targetThresh NextBestDualEndpoint allows tune target probability onwards used derive next best dose (fixed 0.05) Added ProbitLogNormal model NextBestDualEndpoint class, additional option “scale” now allows also specify absolute biomarker target ranges. corresponding method evaluation, safety samples now longer included evaluation biomarker target probability, now description consistent computations. NextBestNCRM NextBestDualEndpoint now return matrix target overdosing probabilities additional list element “probs” result “nextBest” applied. Note StoppingTargetBiomarker evaluation, toxicity longer part biomarker target probability.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"bugfixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.1","text":"Added back example vignette, can opened crmPackExample() Clarified DualEndpointRW model samples prior obtained due impropriety RW prior (added model class description). DualEndpointRW models, now possible non-equidistant grid points, obtain sensible results. (still needs thoroughly tested though.) DualEndpointBeta model, now possible negative E0 Emax parameters. Cohort size 0 placebo now possible - e.g. start patients later move larger cohorts also including placebo subjects. simulating firstSeparate=TRUE placebo, now first (sentinel) cohort includes one active one placebo patients, next patients use cohort size active placebo arms, respectively. Barplots work now also one observed value simulations NextBestDualEndpoint now takes account active doses optimizing biomarker outcome next best dose among admissible doses, thus avoiding early stopping placebo dose level. DataMixture objects used, mcmc now correctly sets fromPrior FALSE shared data object contains data.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-020","dir":"Changelog","previous_headings":"","what":"Version 0.2.0","title":"Version 0.2.0","text":"CRAN release: 2016-07-16 Added arguments probmin probmax MinimalInformative order control probability threshold minimum maximum dose minimally informative prior Values 95% CI corresponding ratio upper lower limit CI displayed results using ‘nextBest’ six- number summary tables including values lowest, 25th percentile, 50th percentile median, mean, 75th precentile highest final (stopping) estimates dose levels corresponds target probability DLE used end trial, TDEOT ratios upper lower 95% credibility intervals (CI) TDEOT dose levels corresponds target probability DLE used trial dose levels corresponds maximum gain value, Gstar ratios upper lower 95% CI final estimates Gstar optimal doses, either TDEOT (DLE response ) minimum TDEOT Gstar (DLE efficacy response) ratios optimal dose across simulations also displayed using ‘summary’ simulations.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-018","dir":"Changelog","previous_headings":"","what":"Version 0.1.8","title":"Version 0.1.8","text":"CRAN release: 2016-02-17 value 95% CI final estimates displayed results using ‘stopTrial’ Bugfixes dual endpoint designs: Improved graphical display plots nextBest dose Improved methodology compute Gstar Warnings removed using nextBest simulations Stopping rules can now also freely combined using /operators dual endpoint design stopping rules using MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-016","dir":"Changelog","previous_headings":"","what":"Version 0.1.6","title":"Version 0.1.6","text":"CRAN release: 2015-12-22 New model class “LogisticLogNormalMixture” added, use new data class “DataMixture”. New stopping rule “StoppingHighestDose” added. “examine” method longer stops two consecutive cohorts start dose. important e.g. two-parts study designs, part 1 can end dose part 2 starts. contents “datanames” slot new models longer restricted specific set, previously enforced validation function GeneralModel AllModels classes. Sampling prior can now enabled/disabled user mcmc function, necessary models might prior even though nObs == 0. Bugfix: results MinimalInformative function reproducible beforehand. Now seed parameter can supplied, ensures reproducibility. Bugfix: Compatibility help file links new ggplot2 package version.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-015","dir":"Changelog","previous_headings":"","what":"Version 0.1.5","title":"Version 0.1.5","text":"CRAN release: 2015-11-12 Bugfix: newer versions grid plotting simulation objects longer work. fixed.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-012","dir":"Changelog","previous_headings":"","what":"Version 0.1.2","title":"Version 0.1.2","text":"publication) prior quantiles specified approximated logistic (log) normal priors.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-011","dir":"Changelog","previous_headings":"","what":"Version 0.1.1","title":"Version 0.1.1","text":"Bugfix: Previously, happen NextBestNCRM rule, higher doses lead decreasing probability overdosing, doses numerically probability 1 DLT. bugfix, clarified rules documentation fixed rule method, right limit overdose interval vector inclusive.","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-010","dir":"Changelog","previous_headings":"","what":"Version 0.1.0","title":"Version 0.1.0","text":"Added examine function generate table hypothetical trial courses model-based rule-based DLT-endpoint designs Made results mcmc() (works usual set.seed earlier user code) simulate() (previously already promised) reproducible. See help file mcmc details. Additional improvements reduce confusing warning messages / notes mcmc() higher-level functions. Made simulate parallel=TRUE work r.roche.com (Linux server), using parallelization method laptops (Windows) Passing empty (zero length) vector doselimit parameter nextBest function now considered requesting dose recommendation without strict dose limit, corresponding warning printed. Introduced GeneralModel class, class Model single agent dose escalation derives. Another branch ComboLogistic model multiple agent combinations (future version). Similarly introduced GeneralData class, class Data single agent derives, separately subclass DataCombo (future version).","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-0023","dir":"Changelog","previous_headings":"","what":"Version 0.0.23","title":"Version 0.0.23","text":"Fixed bug mcmc function led error “data elements must many rows sample size ” slightly changed JAGS way handling burnin / thinning (user impact). Reduced number MCMC samples dual-endpoint example vignette able plot vignette","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-0022","dir":"Changelog","previous_headings":"","what":"Version 0.0.22","title":"Version 0.0.22","text":"simulate function fixed (specification arguments) Dual-endpoint model-based design added. 3+3 design simulation now possible, see ?ThreePlusThreeDesign Welcome message attaching crmPack, .e. library(“crmPack”) run crmPackUpgrade() function easy upgrade crmPack latest version Rule-based designs now can specified class RuleDesign, model-based designs stay class Design. even special class DualDesign class, dual-endpoint model-based designs. Corresponding classes GeneralSimulations, Simulations DualSimulations capture output trial simulations rule-based, model-based dual-endpoint designs. class Simulations-summary renamed SimulationsSummary, similarly classes GeneralSimulationsSummary DualSimulationsSummary. Stopping CohortSize rules based intervals (IncrementsRelative, IncrementsRelativeDLT, CohortSizeRange, CohortSizeDLT) now use different intervals definition. Now “intervals” slots contain left bounds intervals. , last element needed infinity. See vignette examples. StoppingMaxPatients class removed, redundant class StoppingMinPatients. Please just use StoppingMinPatients class instead. Initialization methods replaced dedicated initialization functions. Please now use Class(…) functions instead new(“Class”, …) calls obtain correct objects. change also reflected vignette. extract function extracting parameter samples Samples objects removed (due name conflict ggmcmc dependency packages). Please now use instead “get” method Samples objects (see vignette example) obtain data ggmcmc format. crmPack now needs package httr (’s now “Imports” field). Packages Rcpp RcppArmadillo moved “Depends” “Suggests” packages. Currently using . showLegend argument model fit plotting functions, order show legend .","code":""},{"path":"https://roche.github.io/crmPack/news/index.html","id":"version-0021","dir":"Changelog","previous_headings":"","what":"Version 0.0.21","title":"Version 0.0.21","text":"NEWS version","code":""}]
