[{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"classes","dir":"Articles","previous_headings":"Class and Methods Name Changes","what":"Classes","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates class/slot removed.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"methods","dir":"Articles","previous_headings":"Class and Methods Name Changes","what":"Methods","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates method/argument removed.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"moved-dose-and-prob-functions-from-slots-to-methods","dir":"Articles","previous_headings":"","what":"Moved dose and prob Functions from Slots to Methods","title":"Migrating from crmPack version 1.0.3","text":"Moved dose prob functions model class slots model class methods. Example usage: dose/prob function true dose-DLT/DLT-dose relationship.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"generate-data-define-a-model-and-get-samples","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Generate data, define a model and get samples","title":"Migrating from crmPack version 1.0.3","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100)) my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) ) my_options <- McmcOptions(burnin = 2, step = 2, samples = 20) my_samples <- mcmc(empty_data, my_model, my_options)"},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"dose","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Dose","title":"Migrating from crmPack version 1.0.3","text":"example dose function can used case different inputs, .e. model’s parameters samples case fixed model’s parameters values.","code":"# Doses reaching a specific target probability of the occurrence of a DLT (equal to 0.3), # given a particular models and samples. # Every single dose corresponds to one particular sample in `my_samples`. dose(0.3, my_model, my_samples) ##  [1] 3.288861e+00 1.142211e+01 7.397016e-01 1.040678e+00 1.157911e+00 ##  [6] 1.500464e+00 1.425438e+00 7.800850e-01 4.095033e+00 8.046662e-01 ## [11] 4.633535e+00 3.884194e-01 3.164010e+00 2.977329e+01 6.800376e+00 ## [16] 1.372428e+00 2.106645e-09 1.628172e+00 1.181168e+00 1.791637e+00 # True dose-DLT relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_dose_fun` takes one argument (target probability of the occurrence of a DLT) # and computes the corresponding dose, according to the model chosen and given a fixed values # of the model's parameters. true_dose_fun <- doseFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_dose_fun(0.3) ## [1] 0.9538033"},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"prob","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Prob","title":"Migrating from crmPack version 1.0.3","text":"","code":"# Toxicity probabilities for a given dose (equal to 10), model and samples. # Every single probability value corresponds to one particular sample in `my_samples`. prob(10, my_model, my_samples) ##  [1] 0.6479220 0.2780871 0.7802167 0.8438793 0.9840123 0.5622099 0.8185522 ##  [8] 0.8732629 0.3520833 0.9736790 0.4045853 0.9802929 0.6927658 0.4568453 ## [15] 0.2122105 0.7853867 0.6274737 0.9450522 0.9637874 0.7659890 # True DLT-dose relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_prob_fun` takes one argument (the dose) and computes the corresponding # toxicity probability, according to the model chosen and given a fixed values # of the model's parameters. true_prob_fun <- probFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_prob_fun(10) ## [1] 0.8179597"},{"path":"https://roche.github.io/crmPack/main/articles/migration_from_the_old_crmPack.html","id":"new-random-number-generator-settings-for-the-mcmc","dir":"Articles","previous_headings":"","what":"New Random Number Generator settings for the MCMC","title":"Migrating from crmPack version 1.0.3","text":"Random Number Generator (RNG) settings used JAGS MCMC now configured solely McmcOptions class. RNG settings : RNG type RNG seed corresponds given RNG type. Find details help page McmcOptions class. RNG-related user settings R session level (us set.seed()) ignored MCMC sampler.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"setting-up-the-data","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Setting up the data","title":"Rolling CRM Example","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                 y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=rep(0, 8),                Tmax=60) ## Used default patient IDs! ## Used best guess cohort indices! emptydata <- DataDA(doseGrid=c(0.1, 0.5,1, 1.5, 3, 6,                                seq(from=10, to=80, by=2)),                     Tmax=60)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"structure-of-the-model-class","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Structure of the model class","title":"Rolling CRM Example","text":"","code":"npiece_=10 Tmax_=60  lambda_prior<-function(k){   npiece_/(Tmax_*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"obtain-the-posterior","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Obtain the posterior","title":"Rolling CRM Example","text":"","code":"options <- McmcOptions(burnin=10,                        step=2,                        samples=1e2)  set.seed(94) samples <- mcmc(data, model, options)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"use-ggmcmc-to-diagnose","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Use ggmcmc to diagnose","title":"Rolling CRM Example","text":"","code":"library(ggmcmc) ## Loading required package: dplyr ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union ## Loading required package: tidyr ## Registered S3 method overwritten by 'GGally': ##   method from    ##   +.gg   ggplot2 alpha0samples <- get(samples,\"alpha0\")  print(ggs_traceplot(alpha0samples)) print(ggs_autocorrelation(alpha0samples))"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"plot-the-model-fit","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Plot the model fit","title":"Rolling CRM Example","text":"","code":"plot(samples, model,data,hazard=TRUE)  plot(samples, model,data,hazard=FALSE)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"prior-mean-curve","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"prior mean curve","title":"Rolling CRM Example","text":"","code":"emptydata <- DataDA(doseGrid=c(0.1, 0.5, 1.5, 3, 6,                                seq(from=10, to=80, by=2)),Tmax=60)  Priorsamples <- mcmc(emptydata, model, options)  plot(Priorsamples, model,emptydata,hazard=FALSE)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"escalation-rules","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Escalation rules","title":"Rolling CRM Example","text":"Need fill (use rule section 8 “using package crmPack: introductory examples”)","code":"myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  nextMaxDose <- maxDose(myIncrements, data = data)  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3)) mySize <- maxSize(mySize1, mySize2)  myStopping1 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping2 <- StoppingMinPatients(nPatients = 50) myStopping <- (myStopping1 | myStopping2)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"recommended-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Recommended dose for the next cohort","title":"Rolling CRM Example","text":"","code":"doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples,                                model=model,                                data=data)   doseRecommendation$plot doseRecommendation$value ## [1] 0.1"},{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"set-up-safety-window-and-dadesign-to-be-completed","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up safety window and DADesign to be completed","title":"Rolling CRM Example","text":"","code":"mysafetywindow <- SafetyWindowConst(c(6,2),7,7)  design <- DADesign(model=model,                    increments=myIncrements,                    nextBest=myNextBest,                    stopping=myStopping,                    cohortSize=mySize,                    data=emptydata,                    safetyWindow=mysafetywindow,                    startingDose=3)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"set-up-true-curves","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up true curves","title":"Rolling CRM Example","text":"","code":"myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from=0, to=100, ylim=c(0, 1)) onset <- 15 exp_cond.cdf<-function(x){      1-(pexp(x,1/onset,lower.tail=FALSE)-pexp(28,1/onset,lower.tail=FALSE))/pexp(28,1/onset)    }"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"perform-the-simulations","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Perform the simulations","title":"Rolling CRM Example","text":"","code":"mySims <- simulate(design,                    args=NULL,                    truthTox=myTruth,                    truthSurv=exp_cond.cdf,#piece_exp_cond.cdf,                    trueTmax=80,                    nsim=2,                    seed=819,                    mcmcOptions=options,                    firstSeparate=TRUE,                    deescalate=FALSE,                    parallel=FALSE)"},{"path":"https://roche.github.io/crmPack/main/articles/rolling-crm.html","id":"interpret-the-simulation-results","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Interpret the simulation results","title":"Rolling CRM Example","text":"Use similar way section 9.2 “using package crmPack: introductory examples” document","code":"a <- summary(mySims,truth=myTruth) b <- mySims@data[[1]]  plot(mySims) plot(b) mySims@stopReasons[[2]] ## [[1]] ## [1] \"Probability for target toxicity is 56 % for dose 20 and thus above the required 50 %\" ##  ## [[2]] ## [1] \"Number of patients is 8 and thus below the prespecified minimum number 50\" # nolint end"},{"path":"https://roche.github.io/crmPack/main/articles/simulations.html","id":"simulation-setting","dir":"Articles","previous_headings":"","what":"Simulation setting","title":"Simulation study example","text":"simulation study setting defined.","code":"id <- 1 onset <- 3 a0 <- 2 a1 <- 3 refDose <- 56  # True dose-DLT relationship myTruth <- function(dose){   StandLogDose <- log(dose / refDose)   plogis(a0 + a1 * StandLogDose) }  # The conditional CDF of the PEM if(onset==30) {   onset=15   exp_cond.cdf<-function(x){     (pexp(42-x,1/onset,lower.tail=FALSE)-pexp(Tmax_,1/onset,lower.tail=FALSE))/pexp(Tmax_,1/onset)   } } else{ exp_cond.cdf<-function(x){   1-(pexp(x,1/onset,lower.tail=FALSE)-pexp(Tmax_,1/onset,lower.tail=FALSE))/pexp(Tmax_,1/onset) }}"},{"path":"https://roche.github.io/crmPack/main/articles/simulations.html","id":"design-definition","dir":"Articles","previous_headings":"","what":"Design definition","title":"Simulation study example","text":"dose escalation designs defined: example TITE-CRM used. Similarly code can adapted rolling-CRM.","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example Tmax_ <- 42  model <- TITELogisticLogNormal(   mean=c(1.33,1.49),   cov=matrix(c(1.826,0.0209,0.0209,0.0245),nrow=2),   ref_dose=refDose )  myIncrements <- IncrementsRelative(intervals=c(0,20),                                    increments=c(10,3))  myNextBest <- NextBestMTD(target=0.3,                           derive=                             function(mtd_samples){                               mean(mtd_samples)                             })  myStopping <- StoppingMinPatients(nPatients=48)  mySize <- CohortSizeConst(size=3)  emptydata <- DataDA(doseGrid=seq(from=2, to=50, by=2),Tmax=Tmax_)  mysafetywindow <- SafetyWindowConst(c(7,7),7,7)  design <- DADesign(model=model,                    increments=myIncrements,                    nextBest=myNextBest,                    stopping=myStopping,                    cohortSize=mySize,                    data=emptydata,                    safetyWindow=mysafetywindow,                    startingDose=8)"},{"path":"https://roche.github.io/crmPack/main/articles/simulations.html","id":"simulation-run","dir":"Articles","previous_headings":"","what":"Simulation run","title":"Simulation study example","text":"order obtain stable results, increase simulation parameters appropriately (step, samples, nsim).","code":"options <- McmcOptions(burnin=20,                        step=1,                        samples=50) mySims <- simulate(design,                    args=NULL,                    truthTox=myTruth,                    truthSurv=exp_cond.cdf,                    trueTmax=42,                    nsim=10,                    seed=819,                    mcmcOptions=options,                    parallel=FALSE)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Analysis","text":"vignette picks previous one (Trial Definition), ends. recap, trial defines six fundamental elements CRM trial ","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Introduction","what":"The dose grid","title":"Trial Analysis","text":"trial use dose grid consisting following doses: 1, 3, 9, 20, 30, 45, 60, 80 100. units doses defined irrelevant operation CRM.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Introduction","what":"The dose-toxicity model","title":"Trial Analysis","text":"trial uses logistic log Normal dose toxicity model \\[ log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta (d_i - d^*) \\] prior joint distribution \\(\\alpha\\) \\(\\beta\\) \\[ \\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}. \\]","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-increment-rule","dir":"Articles","previous_headings":"Introduction","what":"The increment rule","title":"Trial Analysis","text":"maximum increment doses greater 0 less 20 100 x (1 + 1)%, 200% highest dose used far, whereas 20 , maximum increment 100 x (1 + 0.5)%, 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-dose-selection-rule","dir":"Articles","previous_headings":"Introduction","what":"The dose selection rule","title":"Trial Analysis","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability overdose range - [0.35, 1.0] - less 0.25.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Introduction","what":"The cohort size","title":"Trial Analysis","text":"Whilst dose next cohort 20 less DLTs observed, minimum cohort size 1. Otherwise, 3.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-stopping-rule","dir":"Articles","previous_headings":"Introduction","what":"The stopping rule","title":"Trial Analysis","text":"trial stop either Twenty patients recruited, . least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"trial-definition","dir":"Articles","previous_headings":"Introduction","what":"Trial definition","title":"Trial Analysis","text":"code define elements trial design given Trial Definition vignette.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"analysing-a-trial","dir":"Articles","previous_headings":"","what":"Analysing a trial","title":"Trial Analysis","text":"Given trial design constructed , process analysing real life instance trial simply matter providing model actual toxicity status participants treated far. escalation rules defined earlier allow use single patient run-either first DLT observed dose 20 administered.","code":""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-single-patient-run-in","dir":"Articles","previous_headings":"Analysing a trial","what":"The single patient run-in","title":"Trial Analysis","text":"Assume first three patients - dosed 1, 3 5 - completed trial without incident, fourth patient - treated 10 - experienced DLT. provide information crmPack via Data object: Within Data object, doses patient treated given x slot toxicity status (Boolean toxicity represented truthy value) y slot. observed data easily visualised  , since plot method returns ggplot object, easily customised.  Now, update model obtain posterior estimate dose-toxicity curve: posterior estimate dose toxicity curve easily visualised:  visual representation model’s state obtained :  lower panel plot shows posterior probability dose overdose range. dashed horizontal black line shows acceptable risk overdose: Doses red lines go line considered toxic. upper panel shows probability dose target toxicity range. Clearly, doses 30 45 highest probability target toxicity range. However, risk overdose range unacceptable. Therefore, 20 dose recommended next cohort. can produce tabulation model state presentations, can see : highest dose far administered 20, escalation rule permits doses including 40 considered dose next cohort. However… Doses 30 considered unsafe remaining doses, 20 highest posterior probability target toxicity range DLT reported Items 1 4 list tell us size next cohort three. Items 2 3 together imply highest dose can used next cohort 20. Thus, model’s recommendation next cohort consist three patients, treated 20. can confirmed programmatically: However, given probability 20 overdose range just less threshold 0.25 (participant far treated 20 experienced DLT) perfectly reasonable clinical decision treat next cohort 10 - , indeed, dose 20. absolutely obligation follow CRM dose recommendation without consideration factors might affect choice appropriate dose next cohort. However, purpose exposition, treat next cohort 20, recommended model. can confirm trial’s stopping rules satisfied:","code":"firstFour <- Data(   x = c(1, 3, 9, 20),   y = c(0, 0, 0, 1),   ID = 1:4,   cohort = 1:4,   doseGrid = doseGrid ) plot(firstFour) plot(firstFour) + theme_light() vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) postSamples <- mcmc(   data = firstFour,   model = model,   options = vignetteMcmcOptions ) plot(postSamples, model, firstFour) nextBest(   my_next_best,   doselimit = 100,   samples = postSamples,   model = model,   data = empty_data )$plot tabulatePosterior <- function(mcmcSamples, observedData) {   as_tibble(     nextBest(       my_next_best,       doselimit = 100,       samples = mcmcSamples,       model = model,       data = observedData     )$probs   ) %>%     left_join(       tibble(         dose = observedData@x,         WithDLT = observedData@y       ) %>%         group_by(dose) %>%         summarise(           Treated = n(),           WithDLT = sum(WithDLT),           .groups = \"drop\"         ),       by = \"dose\"     ) %>%     replace_na(list(Treated = 0, WithDLT = 0)) %>%     select(dose, Treated, WithDLT, target, overdose) %>%     kableExtra::kable(       col.names = c(\"Dose\", \"Treated\", \"With DLT\", \"Target range\", \"Overdose range\"),       table.attr = \"style='width:60%;'\",       digits = c(0, 0, 0, 3, 3)     ) %>%     kableExtra::add_header_above(c(\" \" = 1, \"Participants\" = 2, \"Probability that dose is in \" = 2)) }  tabulatePosterior(postSamples, firstFour) nextMaxDose <- maxDose(my_increments, firstFour) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples,   model = model,   data = firstFour ) doseRecommendation$value #> [1] 9 stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples,   model,   firstFour ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 18 % for dose 9 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 4 and thus below the prespecified minimum number 20\""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-first-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The first full cohort","title":"Trial Analysis","text":"Assume none three patients first full cohort report DLT: Update model: Tabulate posterior: trial stop? , dose used next cohort? trial continue, treating three patients next cohort 30.","code":"firstFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20),   y = c(0, 0, 0, 1, 0, 0, 0),   ID = 1:7,   cohort = c(1:4, rep(5, 3)),   doseGrid = doseGrid ) postSamples1 <- mcmc(   data = firstFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples1, firstFullCohort) nextMaxDose <- maxDose(my_increments, firstFullCohort) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples1,   model = model,   data = firstFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples1,   model,   firstFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-second-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The second full cohort","title":"Trial Analysis","text":"Assume none three patients next cohort report DLT: Update model: Tabulate posterior: dose highest posterior probability target toxicity range now 45, dose also unacceptably high probability overdose range. Therefore, trial continue next cohort treated 30:","code":"secondFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20, 30, 30, 30),   y = c(0, 0, 0, 1, 0, 0, 0, 0, 0, 0),   ID = 1:10,   cohort = c(1:4, rep(5, 3), rep(6, 3)),   doseGrid = doseGrid ) postSamples2 <- mcmc(   data = secondFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples2, secondFullCohort) nextMaxDose <- maxDose(my_increments, secondFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples2,   model = model,   data = secondFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples2,   model,   secondFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-third-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The third full cohort","title":"Trial Analysis","text":"Assume none three patients third cohort report DLT: Update model: Tabulate posterior: 45 still dose highest posterior probability target toxicity range, probability overdose range now acceptable. Therefore, trial continue next cohort treated 45:","code":"thirdFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6)),   y = c(0, 0, 0, 1, rep(0, 9)),   ID = 1:13,   cohort = c(1:4, rep(5, 3), rep(6, 3), rep(7, 3)),   doseGrid = doseGrid ) postSamples3 <- mcmc(   data = thirdFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples3, thirdFullCohort) nextMaxDose <- maxDose(my_increments, thirdFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples3,   model = model,   data = thirdFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples3,   model,   thirdFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-fourth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fourth full cohort","title":"Trial Analysis","text":"Assume none three patients fourth cohort report DLT: Update model: Tabulate posterior: 60 now dose highest posterior probability target toxicity range, probability overdose range unacceptable. Therefore, trial continue next cohort treated 45:","code":"fourthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 3)),   y = c(0, 0, 0, 1, rep(0, 12)),   ID = 1:16,   cohort = c(1:4, rep(5:8, each = 3)),   doseGrid = doseGrid ) postSamples4 <- mcmc(   data = fourthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples4, fourthFullCohort) nextMaxDose <- maxDose(my_increments, fourthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples4,   model = model,   data = fourthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples4,   model,   fourthFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"the-fifth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fifth full cohort","title":"Trial Analysis","text":"Assume two three patients fourth cohort report DLT: Update model: Tabulate posterior: 45 remains dose highest posterior probability target toxicity range, probability overdose range acceptable. Moreover, probability 45 target toxicity range 0.5 three cohorts treated total. Therefore, trial stop conclude 45 MTD:","code":"fifthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 6)),   y = c(0, 0, 0, 1, rep(0, 13), 1, 1),   ID = 1:19,   cohort = c(1:4, rep(5:9, each = 3)),   doseGrid = doseGrid ) postSamples5 <- mcmc(   data = fifthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples5, fifthFullCohort) nextMaxDose <- maxDose(my_increments, fifthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples5,   model = model,   data = fifthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples5,   model,   fifthFullCohort ) x #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 55 % for dose 45 and thus above the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 19 and thus below the prespecified minimum number 20\""},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"summarising-the-trial-results","dir":"Articles","previous_headings":"","what":"Summarising the trial results","title":"Trial Analysis","text":"crmPack provides wealth information trial’s results. following code snippets illustrate many possibilities trial might summarised.    little bit work, can obtain detailed summary plot posterior probabilities toxicity dose:","code":"plot(fifthFullCohort) plot(postSamples5, model, fifthFullCohort) doseRecommendation$plot slotNames(model) #> [1] \"params\"          \"ref_dose\"        \"datamodel\"       \"priormodel\"      #> [5] \"modelspecs\"      \"init\"            \"datanames\"       \"datanames_prior\" #> [9] \"sample\"  fullSamples <- tibble(   Alpha = postSamples5@data$alpha0,   Beta = postSamples5@data$alpha1 ) %>%   expand(nesting(Alpha, Beta), Dose = doseGrid) %>%   rowwise() %>%   mutate(P = probFunction(model, alpha0 = Alpha, alpha1 = Beta)(dose = Dose)) %>%   ungroup()  fullSummary <- fullSamples %>%   group_by(Dose) %>%   summarise(     Mean = mean(P),     Median = median(P),     Q = list(quantile(P, probs = c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95), na.rm = TRUE))   ) %>%   unnest_wider(     col = Q,     names_repair = function(.x) {       ifelse(         str_detect(.x, \"\\\\d+%\"),         sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))),         .x       )     }   ) #> Warning in sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))): NAs #> introduced by coercion  fullSummary %>%   kableExtra::kable(     col.names = c(\"Dose\", \"Mean\", \"Median\", \"5th\", \"10th\", \"25th\", \"75th\", \"90th\", \"95th\"),     digits = c(0, rep(3, 8))   ) %>%   add_header_above(c(\" \" = 3, \"Quantiles\" = 6)) %>%   add_header_above(c(\" \" = 1, \"P(Toxicity)\" = 8)) fullSamples %>%   filter(Dose > 9) %>%   ggplot() +   geom_density(aes(x = P, color = as.factor(Dose))) +   theme_light() +   theme(     axis.text.y = element_blank(),     axis.title.y = element_blank(),     axis.ticks.y = element_blank()   ) +   labs(     title = \"Posterior PDFs for doses > 9\",     colour = \"Dose\"   ) fullSummary %>%   ggplot(aes(x = Dose)) +   geom_ribbon(aes(ymin = Q05, ymax = Q95), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q10, ymax = Q90), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q25, ymax = Q75), fill = \"steelblue\", alpha = 0.25) +   geom_line(aes(y = Mean), colour = \"black\") +   geom_line(aes(y = Median), colour = \"blue\") +   theme_light() +   labs(     title = \"Posterior Dose toxicity curve\",     colour = \"Dose\",     y = \"P(Toxicity)\"   )"},{"path":"https://roche.github.io/crmPack/main/articles/trial_analysis.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Trial Analysis","text":"analyses presented vignette used chains short length. purely convenience. Analyses real trials use considerably longer chains. example, effective sample size approximately 40,000 required estimate percentage within ±1%.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"defining-the-design","dir":"Articles","previous_headings":"","what":"Defining the design","title":"Trial Definition","text":"CRM study consists six basic elements: dose grid dose-toxicity model increment rule_1 dose recommendation rule1 cohort size1 stopping rule 1: Note crmPack, increment, dose selection cohort size rules collectively known escalation rules. many, many possible choices element. introduction, make simple choices value element. start loading crmPack package … … defining element turn.","code":"library(crmPack) #> Loading required package: ggplot2 #> Registered S3 method overwritten by 'crmPack': #>   method       from   #>   print.gtable gtable #> Type crmPackHelp() to open help browser #> Type crmPackExample() to open example"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Defining the design","what":"The dose grid","title":"Trial Definition","text":"First, list doses might used trial. commitment use every dose grid. define grid 9 doses ranging 1 100. crmPack agnostic respect units used measure doses. requirements dose grid ordered one dimensional. Additional doses can added whilst trial running. affect validity results trial prior addition, probably affect trial’s operating characteristics.","code":"# Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 9, 20, 30, 45, 60, 80, 100))"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Defining the design","what":"The dose toxicity model","title":"Trial Definition","text":"Next, define dose toxicity model. crmPack, LogisticLogNormal class fits model following form: \\[log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta (d_i - d^*)\\] \\(d^*\\) reference dose (specified ref_dose argument LogisticLogNormal function ) prior joint distribution \\(\\alpha\\) \\(\\beta\\) \\[\\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} \\mu_{\\alpha}\\\\ \\mu_{\\beta} \\end{bmatrix}   , \\begin{bmatrix} \\sigma_{\\alpha\\alpha} & \\sigma_{\\alpha\\beta} \\\\ \\sigma_{{\\beta\\alpha}} & \\sigma_{\\beta\\beta} \\end{bmatrix}    \\end{pmatrix}. \\] mean covariance matrices defined mean cov parameters LogisticLogNormal call. code defines prior joint distribution \\(\\alpha\\) \\(log(\\beta)\\) \\[ N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}. \\] easy obtain visual representation prior:","code":"# Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 ) vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) prior_samples <- mcmc(   data = empty_data,   model = model,   options = vignetteMcmcOptions ) plot(prior_samples, model, empty_data)"},{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-maximum-increment","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The maximum increment","title":"Trial Definition","text":"Now, define maximum possible increment dose used current cohort dose used next, regardless likely toxicity. rule chosen defines maximum possible increment terms multiples highest dose far administered: doses greater 0 less 20, maximum increment 100 x (1 + 1)%, 200% highest dose used far. doses 20 , maximum increment 100 x (1 + 0.5)%, 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation. tabular form, based dose grid defined , maximum permitted escalation , highest dose used far 9, highest dose dose grid can used next cohort 20, even 30 higher doses deemed safe NextBest rule. Next, define rule choosing best dose next cohort","code":"# Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 30),   increments = c(1, 0.5) )"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-nextbest-rule-for-recommending-the-best-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The NextBest rule for recommending the best dose for the next cohort","title":"Trial Definition","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability toxicity overdose range - [0.35, 1.0] - less 0.25.","code":"# Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The cohort size","title":"Trial Definition","text":"Now, define rule choosing size next cohort. Note, term “cohort size” somewhat anachronistic. hangover days 3+3 design. context CRM trials, best interpreted “largest permitted interval CRM model updates”. CRM trial, model can updated time mathematical need halt recruitment allow model updated. elect define cohort size using compound rule. dose used number DLTs far observed contribute decision. first part compound rule (my_size_1), based dose used, permits use single patient run-including dose 20. doses 20, minimum cohort size 3. second part compound rule (my_size_2) also permits single patient run-, long DLTs far observed. soon first DLT reported, minimum cohort size 3. determine actual size next cohort, larger number required two parts compound rule used. words, provided dose 20 DLTs observed, single patient cohort permitted. cases, required cohort size 3.","code":"# Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   dlt_intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-stopping-rules","dir":"Articles","previous_headings":"Defining the design","what":"The stopping rules","title":"Trial Definition","text":"Now create rules define trial’s objectives met (stopped futility). futility rule easiest explain: twenty patients recruited, study stop (my_stopping_3). success rule requires following conditions met: least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5. trial stop either futility rule components success rule satisfied.","code":"# Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3"},{"path":"https://roche.github.io/crmPack/main/articles/trial_definition.html","id":"the-overall-trial-design","dir":"Articles","previous_headings":"Defining the design","what":"The overall trial design","title":"Trial Definition","text":"Finally, combine six elements design, together starting dose, define trial. now ready use trial definition, either analyse real trial simulate long term operating characteristics design. processes described vignettes .","code":"# Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohortSize = my_size,   data = empty_data,   startingDose = 3 )"},{"path":[]},{"path":"https://roche.github.io/crmPack/main/articles/trial_simulation.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Trial Simulation","text":"basic example shows run simulations CRM 2-parameter logistic regression model, using log normal prior distribution, custom cohort size, stopping maximum increments rules:","code":"library(crmPack)  # Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   dlt_intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)  # Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohortSize = my_size,   data = empty_data,   startingDose = 3 )  # Define the true function. my_truth <- function(dose) {   alpha0 <- 7   alpha1 <- 8   ref_dose <- 56   stand_log_dose <- log(dose / ref_dose)   plogis(alpha0 + alpha1 * stand_log_dose) }  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course. options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 ) time <- system.time(my_sims <- simulate(design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]"},{"path":"https://roche.github.io/crmPack/main/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Sabanes Bove. Author, maintainer. Wai Yin Yeung. Author. Burak Kuersad Guenhan. Author. Giuseppe Palermo. Author. Thomas Jaki. Author. Jiawen Zhu. Author. Ziwei Liao. Author. Dimitris Kontos. Author. Marlene Schulte-Goebel. Author.","code":""},{"path":"https://roche.github.io/crmPack/main/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sabanés Bové D, Yeung WY, Palermo G, Jaki T (2019). “Model-Based Dose Escalation Designs R crmPack.” Journal Statistical Software, 89(10), 1–22. doi:10.18637/jss.v089.i10.","code":"@Article{,   title = {Model-Based Dose Escalation Designs in {R} with {crmPack}},   author = {Daniel {Saban\\'es Bov\\'e} and Wai Yin Yeung and Giuseppe Palermo and Thomas Jaki},   journal = {Journal of Statistical Software},   year = {2019},   volume = {89},   number = {10},   pages = {1--22},   doi = {10.18637/jss.v089.i10}, }"},{"path":"https://roche.github.io/crmPack/main/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Object-Oriented Implementation of CRM Designs","text":"can install development version crmPack github : can install stable release version crmPack CRAN :","code":"devtools::install_github(\"Roche/crmPack\") install.packages(\"crmPack\")"},{"path":"https://roche.github.io/crmPack/main/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Object-Oriented Implementation of CRM Designs","text":"basic example shows run simulations CRM 2-parameter logistic regression model, using log normal prior distribution, custom cohort size, stopping maximum increments rules:","code":"library(crmPack)  # Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   dlt_intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)  # Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohortSize = my_size,   data = empty_data,   startingDose = 3 )  # Define the true function. my_truth <- function(dose) {   alpha0 <- 7   alpha1 <- 8   ref_dose <- 56   stand_log_dose <- log(dose / ref_dose)   plogis(alpha0 + alpha1 * stand_log_dose) }  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course. options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 )  time <- system.time(   my_sims <- simulate(     design,     args = NULL,     truth = my_truth,     nsim = 1,     seed = 819,     mcmcOptions = options,     parallel = FALSE   ) )[3]"},{"path":"https://roche.github.io/crmPack/main/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"Object-Oriented Implementation of CRM Designs","text":"package vignettes provide information various aspects CRM trial design, implementation, simulation analysis: Trial definition Trial analysis Simulation operating characteristics Extending crmPack Sabanes Bove et al (2019) Model-based Dose Escalation Designs R crmPack. JSS 89:10 DOI 10.18637/jss.v089.i10","code":""},{"path":"https://roche.github.io/crmPack/main/pull_request_template.html","id":null,"dir":"","previous_headings":"","what":"Pull Request","title":"Pull Request","text":"Fixes #nnn","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSize — CohortSize-class","title":"CohortSize — CohortSize-class","text":"CohortSize class cohort sizes.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeConst — CohortSizeConst-class","title":"CohortSizeConst — CohortSizeConst-class","text":"CohortSizeConst class fixed constant size cohort.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"CohortSizeConst(size)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeConst — CohortSizeConst-class","text":"size (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeConst — CohortSizeConst-class","text":"size (integer) cohort size.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"# Cohort of size 3, constant along the study. my_size <- CohortSizeConst(size = 3)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeDLT — CohortSizeDLT-class","title":"CohortSizeDLT — CohortSizeDLT-class","text":"CohortSizeDLT class cohort size based number DLTs.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"CohortSizeDLT(dlt_intervals, cohort_size)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeDLT — CohortSizeDLT-class","text":"dlt_intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeDLT — CohortSizeDLT-class","text":"dlt_intervals (integer) vector left bounds relevant DLT intervals. cohort_size (integer) vector cohort sizes corresponding elements dlt_intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"# Rule for having cohort of size 1 until no DLT is observed and having cohort # of size 3 as soon as 1 DLT is observed. my_size <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMax — CohortSizeMax-class","title":"CohortSizeMax — CohortSizeMax-class","text":"CohortSizeMax class cohort size based maximum multiple cohort size rules. cohort_size_list slot stores set cohort size rules, objects class CohortSize. maximum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":"CohortSizeMax(cohort_size_list)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_size_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_size_list (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMax' which will then be combined with # the 'max' operation. mySize <- CohortSizeMax(cohort_size_list = list(my_size1, my_size2))"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMin — CohortSizeMin-class","title":"CohortSizeMin — CohortSizeMin-class","text":"CohortSizeMin class cohort size based minimum multiple cohort size rules. cohort_size_list slot stores set cohort size rules, objects class CohortSize. minimum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"CohortSizeMin(cohort_size_list)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_size_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_size_list (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMin' which will then be combined with # the 'min' operation. my_size <- CohortSizeMin(cohort_size_list = list(my_size1, my_size2))"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeParts — CohortSizeParts-class","title":"CohortSizeParts — CohortSizeParts-class","text":"CohortSizeParts class cohort size changes second part dose escalation. works conjunction DataParts objects.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"CohortSizeParts(sizes)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeParts — CohortSizeParts-class","text":"sizes (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeParts — CohortSizeParts-class","text":"sizes (integer) vector length two two sizes, one part 1, one part 2 respectively.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"# Part 1 cohort size = 1, Part 2 cohort size = 3. my_size <- CohortSizeParts(sizes = c(1, 3))"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeRange-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeRange — CohortSizeRange-class","title":"CohortSizeRange — CohortSizeRange-class","text":"CohortSizeRange class cohort size based dose range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeRange-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"CohortSizeRange(intervals, cohort_size)"},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeRange-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeRange-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) vector left bounds relevant dose intervals. cohort_size (integer) integer vector cohort sizes corresponding elements intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/CohortSizeRange-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"# Example for the rule having cohort of size 1 for doses <30 # and having cohort of size 3 for doses >=30.  my_size <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))"},{"path":"https://roche.github.io/crmPack/main/reference/DADesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the time-to-DLT augmented CRM design — DADesign-class","title":"Class for the time-to-DLT augmented CRM design — DADesign-class","text":"class special requirements model data slots comparison parent class Design:","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DADesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the time-to-DLT augmented CRM design — DADesign-class","text":"model model used, object inheriting class GeneralModel, see particular DALogisticLogNormal TITELogisticLogNormal make use time--DLT data data dose grid, previous data, etc., contained object class DataDA safetyWindow still documented.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DADesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for the time-to-DLT augmented CRM design — DADesign-class","text":"","code":"# nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(doseGrid=c(0.1, 0.5,1, 1.5, 3, 6,                                seq(from=10, to=80, by=2)),Tmax=60) # Initialize the mDA-CRM model npiece_=10 Tmax_=60  lambda_prior<-function(k){   npiece_/(Tmax_*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2) # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0,20),                                    increments=c(1,0.33)) # Choose the rule for selecting the next dose nextMaxDose <- maxDose(myIncrements,data=emptydata)  myNextBest <- NextBestNCRM(target=c(0.2,0.35),                            overdose=c(0.35,1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping2 <- StoppingMinPatients(nPatients=50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow=SafetyWindowConst(c(6,2),7,7)  # Initialize the design design <- DADesign(model=model,                    increments=myIncrements,                    nextBest=myNextBest,                    stopping=myStopping,                    cohortSize=mySize,                    data=emptydata,                    safetyWindow=mysafetywindow,                    startingDose=3) # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/DADesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for DADesign — DADesign","title":"Initialization function for DADesign — DADesign","text":"Initialization function DADesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DADesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for DADesign — DADesign","text":"","code":"DADesign(model, data, safetyWindow, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DADesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for DADesign — DADesign","text":"model see DADesign data see DADesign safetyWindow see DADesign ... additional arguments Design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DADesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for DADesign — DADesign","text":"DADesign object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DALogisticLogNormal — DALogisticLogNormal-class","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"DALogisticLogNormal class logistic model bivariate (log) normal prior data augmentation. class inherits LogisticLogNormal class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"DALogisticLogNormal(npiece = 3, l, c_par = 2, cond_pem = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"still need include formula lambda prior.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/DALogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"npiece <- 10 Tmax <- 60 # nolintr  lambda_prior <- function(k) {   npiece / (Tmax * (npiece - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece,   l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),   c_par = 2 )"},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the simulations output from DA based designs — DASimulations-class","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"class captures trial simulations DA based designs. comparison parent class Simulations, contains additional slots capture time DLT fits, additional parameters trial duration.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"trialduration vector trial duration values simulations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for DASimulations — DASimulations","title":"Initialization function for DASimulations — DASimulations","text":"Initialization function DASimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for DASimulations — DASimulations","text":"","code":"DASimulations(trialduration, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for DASimulations — DASimulations","text":"trialduration see DASimulations ... additional parameters Simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DASimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for DASimulations — DASimulations","text":"DASimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DLTLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of DLTs in each interval — DLTLikelihood","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"helper function fitPEM methods .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DLTLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"","code":"DLTLikelihood(lambda, Tmax)"},{"path":"https://roche.github.io/crmPack/main/reference/DLTLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"lambda vector piecewise hazards Tmax end time interval DLTs","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DLTLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"vector probabilities DLTs within intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data — Data-class","title":"Data — Data-class","text":"Data class data input. inherits GeneralData.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data — Data-class","text":"","code":"Data(   x = numeric(),   y = integer(),   ID = integer(),   cohort = integer(),   doseGrid = numeric(),   placebo = FALSE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1). can also supply numeric vectors, converted integer internally. ID (integer) unique patient IDs. can also supply numeric vectors, converted integer internally. cohort (integer) cohort (non-negative sorted) indices. can also supply numeric vectors, converted integer internally. doseGrid (numeric) possible doses. placebo (flag) TRUE first dose level doseGrid considered placebo. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data — Data-class","text":"cohort can missing placebo equal FALSE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1 integers). doseGrid (numeric) vector possible doses (sorted), .e. dose grid. nGrid (integer) number gridpoints. xLevel (integer) levels doses patients given, w.r.t doseGrid. placebo (logical) TRUE first dose level doseGridis considered PLACEBO.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Data — Data-class","text":"ID cohort can missing. message issued variables filled default IDs best guesses cohort, .e. sorted (ascending order) sequence values {1, 2, ...}.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Data-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data — Data-class","text":"","code":"my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs! #> Used best guess cohort indices! my_data #> An object of class \"Data\" #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDA — DataDA-class","title":"DataDA — DataDA-class","text":"DataDA class time--DLT augmented data. inherits Data contains additional DLT free survival times.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDA — DataDA-class","text":"","code":"DataDA(   u = numeric(),   t0 = numeric(length(u)),   Tmax = 0 + .Machine$double.xmin,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Default vector 0s length equal length u. Tmax (number) DLT observation period. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Tmax (number) DLT observation period.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataDA — DataDA-class","text":"survival time refers time period subject experience DLT, referring deaths.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDA-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDA — DataDA-class","text":"","code":"my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Set up an empty data set. empty_data <- DataDA(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   Tmax = 60 ) empty_data #> An object of class \"DataDA\" #> Slot \"u\": #> numeric(0) #>  #> Slot \"t0\": #> numeric(0) #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.0  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 #> [16] 28.0 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 #> [31] 58.0 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 42 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>"},{"path":"https://roche.github.io/crmPack/main/reference/DataDual-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDual — DataDual-class","title":"DataDual — DataDual-class","text":"DataDual class dual endpoint data. inherits Data contains additional biomarker information.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDual-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDual — DataDual-class","text":"","code":"DataDual(w = numeric(), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DataDual-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDual-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataDual-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDual — DataDual-class","text":"","code":"my_data <- DataDual(   w = rnorm(8),   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs! #> Used best guess cohort indices! my_data #> An object of class \"DataDual\" #> Slot \"w\": #> [1]  0.28133768 -0.06655328  1.36712224  0.17197873 -0.08797329 -0.16172308 #> [7]  1.52911623  0.64127393 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://roche.github.io/crmPack/main/reference/DataMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataMixture — DataMixture-class","title":"DataMixture — DataMixture-class","text":"DataMixture class data mixture sharing. inherits Data contains additional information mixture sharing.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataMixture — DataMixture-class","text":"","code":"DataMixture(xshare = numeric(), yshare = integer(), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DataMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. can also supply numeric vectors, converted integer internally. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. nObsshare (count) number share patients.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataMixture — DataMixture-class","text":"","code":"my_data <- DataMixture(   xshare = c(12, 14, 16, 18.0),   yshare = c(0L, 1L, 1L, 1L),   nObsshare = 4L,   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) my_data #> An object of class \"DataMixture\" #> Slot \"xshare\": #> [1] 12 14 16 18 #>  #> Slot \"yshare\": #> [1] 0 1 1 1 #>  #> Slot \"nObsshare\": #> [1] 4 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://roche.github.io/crmPack/main/reference/DataParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataParts — DataParts-class","title":"DataParts — DataParts-class","text":"DataParts class data two study parts. inherits Data contains additional information two study parts.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataParts — DataParts-class","text":"","code":"DataParts(part = integer(), nextPart = 1L, part1Ladder = numeric(), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DataParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid. ... parameters passed Data().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DataParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataParts — DataParts-class","text":"","code":"my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) my_data #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 #>  #> Slot \"nextPart\": #> [1] 1 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://roche.github.io/crmPack/main/reference/Design-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the CRM design — Design-class","title":"Class for the CRM design — Design-class","text":"addition slots simple RuleDesign, objects class contain:","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Design-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the CRM design — Design-class","text":"model model used, object class GeneralModel stopping stopping rule(s) trial, object class Stopping increments control increments dose levels, object class Increments PLcohortSize rules cohort sizes placebo, planned object class CohortSize (defaults constant 0 placebo patients)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Design-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for the CRM design — Design-class","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3) # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/Design.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"Design\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"Design(model, stopping, increments, PLcohortSize = CohortSizeConst(0L), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/Design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"model see Design stopping see Design increments see Design PLcohortSize see Design ... additional arguments RuleDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"Design object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the dual-endpoint CRM design — DualDesign-class","title":"Class for the dual-endpoint CRM design — DualDesign-class","text":"class special requirements model data slots comparison parent class Design:","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the dual-endpoint CRM design — DualDesign-class","text":"model model used, object class DualEndpoint data dose grid, previous data, etc., contained object class DataDual Note NextBest slot can class, allows easy comparison recommendation methods use biomarker information.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for the dual-endpoint CRM design — DualDesign-class","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) myStopping <- myStopping4 | StoppingMinPatients(40)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = mySize,                      startingDose = 3)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"DualDesign\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"DualDesign(model, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"model see DualDesign data see DualDesign ... additional arguments Design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"DualDesign object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpoint — DualEndpoint-class","title":"DualEndpoint — DualEndpoint-class","text":"DualEndpoint general class dual endpoint model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpoint — DualEndpoint-class","text":"","code":"DualEndpoint(mean, cov, ref_dose = 1, use_log_dose = FALSE, sigma2W, rho)"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpoint — DualEndpoint-class","text":"mean (numeric) probit toxicity model, prior mean vector. cov (matrix) probit toxicity model, prior covariance matrix. precision matrix internally calculated inverse cov. ref_dose (number) probit toxicity model, reference dose \\(x*\\) (strictly positive number). use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpoint — DualEndpoint-class","text":"idea dual-endpoint models model dose-toxicity relationship, also model, time, relationship PD biomarker dose. sub-classes class define dose-biomarker relationship parametrized. class shall contain common features reduce duplicate code. (class however, must virtual need create objects construction subclass objects.) dose-toxicity relationship modeled probit regression model $$probit[p(x)] = betaZ1 + betaZ2 * x/x*,$$ $$probit[p(x)] = betaZ1 + betaZ2 * log(x/x*),$$ case option use_log_dose TRUE. , \\(p(x)\\) probability observing DLT given dose \\(x\\) \\(x*\\) reference dose. prior $$(betaZ1, log(betaZ2)) ~ Normal(mean, cov).$$ biomarker response \\(w\\) dose \\(x\\), assume $$w(x) ~ Normal(f(x), sigma2W),$$ \\(f(x)\\) function dose \\(x\\), specified sub-classes. biomarker variance \\(sigma2W\\) can fixed assigned Inverse-Gamma prior distribution; see details slot sigma2W. Finally, two endpoints \\(y\\) (binary DLT variable) \\(w\\) (biomarker) can correlated, assuming correlation level \\(rho\\) underlying continuous latent toxicity variable \\(z\\) biomarker \\(w\\). , correlation can fixed assigned prior distribution scaled Beta family; see details slot rho. Please see example vignette typing crmPackExample() full example.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpoint — DualEndpoint-class","text":"betaZ_params (ModelParamsNormal) probit toxicity model, contains prior mean, covariance matrix precision matrix internally calculated inverse covariance matrix. ref_dose (positive_number) probit toxicity model, reference dose. use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. use_fixed (logical) indicates whether fixed value sigma2W rho (parameter separately) used . slot needed internal purposes must touched user.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointBeta — DualEndpointBeta-class","title":"DualEndpointBeta — DualEndpointBeta-class","text":"DualEndpointBeta class dual endpoint model beta function dose-biomarker relationship.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"DualEndpointBeta(E0, Emax, delta1, mode, ref_dose_beta = 1, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointBeta — DualEndpointBeta-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric, rescaled beta density function: $$f(x) = E0 + (Emax - E0) * Beta(delta1, delta2) * (x/x*)^delta1 * (1 - x/x*)^delta2,$$ \\(x*\\) maximum dose (end dose range considered), \\(delta1\\) \\(delta2\\) two beta function parameters, \\(E0\\), \\(Emax\\) minimum maximum levels, respectively. ease interpretation, use parametrization based \\(delta1\\) mode, $$mode = delta1 / (delta1 + delta2),$$ multiplying \\(x*\\) gives mode dose grid. parameters can currently assigned uniform distributions fixed advance. Note E0 Emax can negative values uniform distributions reaching negative range, delta1 mode must positive uniform distributions positive range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   ref_dose = 10,   use_log_dose = TRUE,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   delta1 = c(0, 5),   mode = c(1, 15),   ref_dose_beta = 1000 )"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointEmax — DualEndpointEmax-class","title":"DualEndpointEmax — DualEndpointEmax-class","text":"DualEndpointEmax class dual endpoint model Emax function dose-biomarker relationship.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"DualEndpointEmax(E0, Emax, ED50, ref_dose_emax = 1, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointEmax — DualEndpointEmax-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric Emax function: $$f(x) = E0 + [(Emax - E0) * (x/x*)]/[ED50 + (x/x*)],$$ \\(x*\\) reference dose, \\(E0\\) \\(Emax\\) minimum maximum levels biomarker, \\(ED50\\) dose achieving half maximum effect \\(0.5 * Emax\\). parameters can currently assigned uniform distributions fixed.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointEmax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"my_model <- DualEndpointEmax(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   ED50 = c(10, 200),   ref_dose_emax = 1000 )"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointRW — DualEndpointRW-class","title":"DualEndpointRW — DualEndpointRW-class","text":"DualEndpointRW class dual endpoint model random walk prior biomarker.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"DualEndpointRW(sigma2betaW, rw1 = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used. ... parameters passed DualEndpoint().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointRW — DualEndpointRW-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled non-parametric random walk first second order. means, first order random walk assume $$betaW_i - betaW_i-1 ~ Normal(0, (x_i - x_i-1) * sigma2betaW),$$ \\(betaW_i = f(x_i)\\) biomarker mean \\(\\)-th dose gridpoint \\(x_i\\). second order random walk, second-order differences instead first-order differences biomarker means follow normal distribution \\(0\\) mean \\(2 * (x_i - x_i-2) * sigma2betaW\\) variance. variance parameter \\(sigma2betaW\\) important steers smoothness function \\(f(x)\\), .e.: large, \\(f(x)\\) wiggly; small, \\(f(x)\\) smooth. parameter can either fixed value assigned inverse gamma prior distribution.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointRW — DualEndpointRW-class","text":"Non-equidistant dose grids can used now, difference \\(x_i - x_i-1\\) included modelling assumption . Please note due impropriety random walk prior distributions, possible produce MCMC samples empty data objects (.e., sample prior). bug, theoretical feature model.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/DualEndpointRW-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )"},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwithout DLE and efficacy samples. It contain all slots in\nRuleDesign and TDDesign class object — DualResponsesDesign-class","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwithout DLE and efficacy samples. It contain all slots in\nRuleDesign and TDDesign class object — DualResponsesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model model efficacy responses using ModelEff  model class without DLE efficacy samples. contain slots RuleDesign TDDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwithout DLE and efficacy samples. It contain all slots in\nRuleDesign and TDDesign class object — DualResponsesDesign-class","text":"data data set DataDual class object Effmodel pseudo efficacy model used, object class ModelEff","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwithout DLE and efficacy samples. It contain all slots in\nRuleDesign and TDDesign class object — DualResponsesDesign-class","text":"","code":"# nolint start ##Construct the DualResponsesDesign for simulations ##The design comprises the DLE and efficacy models, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513), eff_dose=c(25,300), nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'DualResponsesDesign","title":"Initialization function for 'DualResponsesDesign","text":"Initialization function 'DualResponsesDesign\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'DualResponsesDesign","text":"","code":"DualResponsesDesign(Effmodel, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'DualResponsesDesign","text":"Effmodel please refer DualResponsesDesign class object data please refer DualResponsesDesign class object ... additional arguments TDDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'DualResponsesDesign","text":"DualResponsesDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwith DLE and efficacy samples.It contain all slots in\nRuleDesign and TDsamplesDesign class object — DualResponsesSamplesDesign-class","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwith DLE and efficacy samples.It contain all slots in\nRuleDesign and TDsamplesDesign class object — DualResponsesSamplesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model model efficacy responses using ModelEff  model class DLE efficacy samples.contain slots RuleDesign TDsamplesDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwith DLE and efficacy samples.It contain all slots in\nRuleDesign and TDsamplesDesign class object — DualResponsesSamplesDesign-class","text":"data data set DataDual class object Effmodel pseudo efficacy model used, object class ModelEff","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a class of design based on DLE responses using the LogisticIndepBeta model\nmodel and efficacy responses using ModelEff  model class\nwith DLE and efficacy samples.It contain all slots in\nRuleDesign and TDsamplesDesign class object — DualResponsesSamplesDesign-class","text":"","code":"# nolint start  ##Construct the DualResponsesSamplesDesign for simulations ##The design comprises the DLE and efficacy models, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE)  ## First for the DLE model and DLE samples ## The DLE model must be of 'ModelTox' ## (e.g 'LogisticIndepBeta') class and ## DLEsamples of 'Samples' class options<-McmcOptions(burnin=100,step=2,samples=200) DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),                               DLEdose=c(25,300),data=data) DLEsamples<-mcmc(data,DLEmodel,options) ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class and the efficacy samples Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) Effsamples<-mcmc(data,Effmodel,options)  ##The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'DualResponsesSamplesDesign","title":"Initialization function for 'DualResponsesSamplesDesign","text":"Initialization function 'DualResponsesSamplesDesign\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'DualResponsesSamplesDesign","text":"","code":"DualResponsesSamplesDesign(Effmodel, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'DualResponsesSamplesDesign","text":"Effmodel please refer DualResponsesSamplesDesign class object data please refer DualResponsesSamplesDesign class object ... additional arguments TDsamplesDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualResponsesSamplesDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'DualResponsesSamplesDesign","text":"DualResponsesSamplesDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the simulations output from dual-endpoint model based designs — DualSimulations-class","title":"Class for the simulations output from dual-endpoint model based designs — DualSimulations-class","text":"class captures trial simulations dual-endpoint model based designs. comparison parent class Simulations, contains additional slots capture dose-biomarker fits, sigma2W rho estimates.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the simulations output from dual-endpoint model based designs — DualSimulations-class","text":"rhoEst vector final posterior median rho estimates sigma2West vector final posterior median sigma2W estimates fitBiomarker list final dose-biomarker curve fits","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"DualSimulations\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"DualSimulations(rhoEst, sigma2West, fitBiomarker, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"rhoEst see DualSimulations sigma2West see DualSimulations fitBiomarker see DualSimulations ... additional parameters Simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"DualSimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"addition slots parent class SimulationsSummary, contains two slots biomarker model fit information.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/DualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of dual-endpoint simulations output — DualSimulationsSummary-class","text":"biomarkerFitAtDoseMostSelected fitted biomarker level dose often selected meanBiomarkerFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted biomarker level dose level","code":""},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":null,"dir":"Reference","previous_headings":"","what":"EffFlexi — EffFlexi-class","title":"EffFlexi — EffFlexi-class","text":"EffFlexi class efficacy model flexible form prior expressed form pseudo data. class, flexible form used describe relationship efficacy responses dose levels specified $$(W | betaW, sigma2W) ~ Normal(X * betaW, sigma2W * ),$$ \\(W\\) vector efficacy responses, \\(betaW\\) column vector mean efficacy responses dose levels, \\(X\\) design matrix entries \\(I_i,j\\) equal 1 subject \\(\\) allocated dose \\(j\\), \\(0\\) otherwise. \\(sigma2W\\) variance efficacy responses can either fixed number number inverse gamma distribution. flexible form aims capture different shapes dose-efficacy curve. addition, first (RW1) second order (RW2) random walk model can used smoothing data. random walk model used model first second order differences mean efficacy responses neighboring dose levels mean efficacy responses. RW1 model given $$betaW_j - betaW_j-1) ~ Normal(0, sigma2betaW),$$ RW2 $$betaW_j-2 - 2 * betaW_j-1 + beta_j ~ Normal(0, sigma2betaW),$$ \\(betaW_j\\) vector mean efficacy responses dose j, \\(sigma2betaW\\) prior variance can either fixed number number inverse gamma distribution. eff eff_dose pseudo efficacy responses dose levels pseudo efficacy responses observed. , eff eff_dose must vectors length least 2. positions elements specified eff eff_dose must correspond vectors.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EffFlexi — EffFlexi-class","text":"","code":"EffFlexi(eff, eff_dose, sigma2W, sigma2betaW, rw1 = TRUE, data)"},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. sigma2W (numeric) prior variance efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. sigma2betaW (numeric) prior variance random walk model used smoothing. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. data (DataDual) observed data update estimates model parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EffFlexi — EffFlexi-class","text":"model output updated value updated values parameters inverse gamma distributions \\(sigma2W\\) \\(sigma2betaW\\). EffFlexi inherits slots ModelEff class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. sigma2W (numeric) prior variance flexible efficacy form. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. sigma2betaW (numeric) prior variance random walk model mean efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (logical) indicates whether fixed value sigma2W sigma2betaW (parameter separately) used . slot needed internal purposes must touched user. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. X (matrix) design matrix efficacy responses. based pseudo observed efficacy responses. RW (matrix) difference matrix random walk model. slot needed internal purposes must used user. RW_rank (integer) rank difference matrix. slot needed internal purposes must used user.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/EffFlexi-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EffFlexi — EffFlexi-class","text":"","code":"# Obtain prior estimates for the efficacy model in flexible form, given the pseudo data. # First define an empty data set by defining the dose levels used in the study. # There are 12 dose levels used in the study, ranging from 25 to 300 mg with # increments of 25. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # Define the pseudo data, i.e.: fixed 2 dose levels 25 and 300 mg (`eff_dose`) # and the efficacy responses 1.223 and 2.513 observed at these two dose levels (`eff`). # The prior variance of the pseudo efficacy responses can be either a fixed value # or two parameters for the inverse gamma distribution, the shape (a) and the # rate (b) (`sigma2W`). # The prior variance of the random walk model can be either a fixed value or two # parameters for the inverse gamma distribution, the shape (a) and the rate (b) # (`sigma2betaW`). my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # Obtain estimates from the model given some observed data is available. data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model1 <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )"},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Effloglog — Effloglog-class","title":"Effloglog — Effloglog-class","text":"Effloglog class linear log-log efficacy model using pseudo data prior. describes relationship continuous efficacy responses corresponding dose levels log-log scale. efficacy log-log model given $$y_i = theta1 + theta2 * log(log(x_i)) + epsilon_i,$$ \\(y_i\\) efficacy response subject \\(\\), \\(x_i\\) dose level treated subject \\(\\) \\(epsilon_i\\) random error term efficacy model subject \\(\\). error term \\(epsilon_i\\) random variable follows normal distribution mean \\(0\\) variance \\(nu^{-1}\\), assumed subjects. three parameters model, intercept \\(theta1\\), slope \\(theta2\\) precision \\(nu\\) efficacy responses, also known inverse variance pseudo efficacy responses. can fixed constant gamma distribution. Therefore, single scalar value vector two positive numbers values must specified nu slot. observed efficacy responses available, output, nu display updated value precision updated values parameters gamma distribution. Effloglog inherits slots ModelEff class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effloglog — Effloglog-class","text":"","code":"Effloglog(eff, eff_dose, nu, data, const = 0)"},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. nu (numeric) precision (inverse variance) efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. data (DataDual) observed data update estimates model parameters. const (number) constant value added dose level dose level value less equal 1 special form linear log-log applied (Yeung et al. (2015).).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Effloglog — Effloglog-class","text":"prior model specified form pseudo data. First, least two dose levels fixed. , using e.g. experts' opinion, efficacy values correspond dose levels can obtained, eff eff_dose arguments represent prior form pseudo data. eff represents pseudo efficacy values. eff_dose represents dose levels pseudo efficacy values observed. Hence, positions elements specified eff eff_dose must correspond vectors. Since least 2 pseudo efficacy values needed obtain modal estimates intercept slope parameters, eff eff_dose must vectors length least 2. joint prior distribution intercept \\(theta1\\) slope \\(theta2\\) model follows bivariate normal distribution mean \\(mu\\) covariance matrix \\((nu * Q)^{-1}\\). mean \\(mu\\) \\(2 x 1\\) column vector contains prior modal estimates intercept slope. Scalar \\(nu\\) precision pseudo efficacy responses \\(Q\\) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding DLT efficacy responses observed (). Hence, \\(X0\\) (\\(X\\)) size \\(r x 2\\), \\(r >= 2\\) pseudo efficacy responses specified (\\(r\\) DLT efficacy responses observed data).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. nu (numeric) parameter prior precision pseudo efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (flag) indicates whether nu specified fixed value vector two parameters gamma distribution. slot internal purposes must used user. theta1 (number) intercept efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. theta2 (number) slope efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. Pcov (matrix) refers \\(2 x 2\\) covariance matrix estimators intercept \\(theta1\\) slope \\(theta2\\) parameters model. used output display resulting prior posterior covariance matrix \\(theta1\\) \\(theta2\\) obtained, based pseudo observed () data. slot needed internal purposes. X (matrix) design matrix based either pseudo dose levels observed dose levels (without DLT). used output display design matrix pseudo observed efficacy responses. Y (numeric) vector either contains pseudo efficacy responses observed efficacy responses (without DLT). mu (numeric) vector prior posterior modal estimates intercept (\\(theta1\\)) slope (\\(theta2\\)). slot used output display mean prior posterior bivariate normal distribution \\(theta1\\) \\(theta2\\). Q (matrix) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding observed, DLT efficacy values (). const (number) non-negative number (default 0), leading model form described . general, model form \\(y_i = theta1 + theta2 * log(log(x_i + const)) + epsilon_i\\), dose levels greater \\(1 - const\\) can considered described Yeung et al. (2015).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Effloglog-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effloglog — Effloglog-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we use an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # Define the pseudo data as first by fixing two dose levels 25 and 300 mg (`eff_dose`). # Then, the efficacy responses observed at these two dose levels are 1.223 and 2.513 (`eff`). # We specify the prior precision of the pseudo efficacy responses (`nu`) as a vector # with the shape (a) and the rate (b) parameters for the gamma distribution. # Obtain modal estimates and other estimates from the model (no observations, # only pseudo data). my_model1 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Observed data. my_data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  # Obtain posterior modal estimates and other estimates from the model given some # observed data. my_model2 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )"},{"path":"https://roche.github.io/crmPack/main/reference/FractionalCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"FractionalCRM — FractionalCRM-class","title":"FractionalCRM — FractionalCRM-class","text":"FractionalCRM class fractional CRM model based one parameter CRM (normal prior log-power parameter) well Kaplan-Meier based estimation conditional probability experience DLT non-complete observations. fractional CRM model follows paper code Guosheng Yin et al.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/FractionalCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FractionalCRM — FractionalCRM-class","text":"","code":"FractionalCRM(...)"},{"path":"https://roche.github.io/crmPack/main/reference/FractionalCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FractionalCRM — FractionalCRM-class","text":"... Arguments passed OneParLogNormalPrior skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/FractionalCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FractionalCRM — FractionalCRM-class","text":"","code":"my_model <- FractionalCRM(   skel_probs = c(0.1, 0.2, 0.3, 0.4),   dose_grid = c(10, 30, 50, 100),   sigma2 = 2 )"},{"path":"https://roche.github.io/crmPack/main/reference/GeneralData-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralData — GeneralData-class","title":"GeneralData — GeneralData-class","text":"GeneralData class general data input.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralData-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralData — GeneralData-class","text":"ID (integer) unique patient IDs. cohort (integer) cohort (non-negative sorted) indices. nObs (integer) number observations, single value.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralModel — GeneralModel-class","title":"GeneralModel — GeneralModel-class","text":"GeneralModel general model class, specific model-like classes inherit.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralModel — GeneralModel-class","text":"datamodel (function) function representing JAGS data model specification. priormodel (function) function representing JAGS prior specification. modelspecs (function) function computing list data model prior model specifications required specified completely (e.g. prior parameters, reference dose, etc.), based data slots required arguments function. Apart data arguments, function can specified one additional (optional) argument from_prior type logical length one. from_prior flag can used differentiate output modelspecs, value taken directly from_prior argument mcmc method invokes modelspecs function. , from_prior TRUE, priormodel JAGS model used (datamodel used) mcmc, hence modelspecs function return parameters required priormodel . value from_prior FALSE, JAGS models datamodel priormodel used MCMC sampler, hence modelspecs function return parameters required datamodel priormodel. init (function) function computing list starting values parameters required initialized MCMC sampler, based data slots required arguments function. datanames (character) names data slots used datamodel JAGS function. names specified . datanames_prior (character) names data slots used priormodel JAGS function. names specified . sample (character) names parameters like save MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralModel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralModel — GeneralModel-class","text":"datamodel must obey convention data input called exactly way corresponding data class. prior distributions parameters contained model function priormodel. background can used simulate prior distribution, obtaining data.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"General class for the simulations output — GeneralSimulations-class","title":"General class for the simulations output — GeneralSimulations-class","text":"class captures trial simulations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"General class for the simulations output — GeneralSimulations-class","text":"also random generator state starting simulation saved, order able reproduce outcome. just use set.seed seed argument running simulate,Design-method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"General class for the simulations output — GeneralSimulations-class","text":"data list produced Data objects doses vector final dose recommendations seed random generator state starting simulation","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"GeneralSimulations\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"GeneralSimulations(data, doses, seed)"},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"data see GeneralSimulations doses see GeneralSimulations seed see GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"GeneralSimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/GeneralSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of general simulations output — GeneralSimulationsSummary-class","text":"target target toxicity interval targetDoseInterval corresponding target dose interval nsim number simulations propDLTs proportions DLTs trials meanToxRisk mean toxicity risks patients doseSelected doses selected MTD toxAtDosesSelected true toxicity doses selected propAtTarget Proportion trials selecting target MTD doseMostSelected dose often selected MTD obsToxRateAtDoseMostSelected observed toxicity rate dose often selected nObs number patients overall nAboveTarget number patients treated target tox interval doseGrid dose grid used placebo set TRUE (default FALSE) design placebo","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Increments-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Increments — Increments-class","title":"Increments — Increments-class","text":"Increments virtual class controlling increments, specific increments classes inherit.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsHSRBeta — IncrementsHSRBeta-class","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"IncrementsHSRBeta class limiting increments using Hard Safety Rule based Bin-Beta model. Increment control based number observed DLTs number subjects dose level. probability toxicity calculated using Bin-Beta model prior (,b). probability exceeds threshold given dose, dose doses excluded escalation. hard safety rule limits escalation based observed data per dose level, independent underlying model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"IncrementsHSRBeta(target = 0.3, prob = 0.95, a = 1, b = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) target toxicity, except 0 1. prob (proportion) threshold probability (except 0 1) dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"# Limit the escalation with a hard safety criteria to the doses that are below # the first dose that is toxic with a probability of 0.95. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsMin — IncrementsMin-class","title":"IncrementsMin — IncrementsMin-class","text":"IncrementsMin class combines multiple increment rules minimum operation. Slot increments_list contains increment rules, objects class Increments. minimum individual increments taken give final maximum increment.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsMin — IncrementsMin-class","text":"","code":"IncrementsMin(increments_list)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) list increment rules.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsMin — IncrementsMin-class","text":"","code":"# As example, here we are combining 2 different increment rules.  # The first rule is the following: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed. my_increments_1 <- IncrementsRelativeDLT(   dlt_intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # The second rule is the following: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments_2 <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Now we combine the 2 rules. comb_increments <- IncrementsMin(   increments_list = list(my_increments_1, my_increments_2) )"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsNumDoseLevels-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","title":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","text":"IncrementsNumDoseLevels class increments control based number maximum dose levels increment.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsNumDoseLevels-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","text":"","code":"IncrementsNumDoseLevels(max_levels = 1L, basis_level = \"last\")"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsNumDoseLevels-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","text":"max_levels (count) see slot definition. basis_level (string) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsNumDoseLevels-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","text":"max_levels (count) maximum dose levels increment next dose. defaults 1, means dose skipping allowed - next dose can maximum one level higher current dose. basis_level (string) corresponding dose level used increment . can take one two possible values: last max. last specified (default), increment applied last given dose max specified increment applied maximum given dose level.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsNumDoseLevels-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsNumDoseLevels — IncrementsNumDoseLevels-class","text":"","code":"# In this example we define a rule for dose increments which would allow: # Maximum skip one dose level, that is 2 dose levels higher than the last dose # given. Maximum increment is explicitly defined as: my_increments <- IncrementsNumDoseLevels(max_levels = 2, basis_level = \"last\")  # Since the default method is based on the last dose given, # maximum increment can also be defined as: my_increments <- IncrementsNumDoseLevels(max_levels = 2)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelative-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelative — IncrementsRelative-class","title":"IncrementsRelative — IncrementsRelative-class","text":"IncrementsRelative class increments control based relative differences intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelative-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"IncrementsRelative(intervals, increments)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelative-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelative-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) vector left bounds relevant intervals. parameters specifies right bounds intervals. example, intervals  = c(0, 50, 100) specifies three intervals: \\((0, 50)\\), \\([50, 100)\\) \\([100, +Inf)\\). means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector length maximum allowable relative increments intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelative-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"IncrementsRelativeDLT class increments control based relative differences terms DLTs.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"IncrementsRelativeDLT(dlt_intervals, increments)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"dlt_intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"dlt_intervals (integer) vector left bounds relevant DLT intervals. parameters specifies right bounds intervals. example, dlt_intervals  = c(0, 1, 3) specifies three intervals (sets DLTs: first, 0 DLT; second 1 2 DLTs; third one, least 3 DLTs. means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector maximum allowable relative increments corresponding dlt_intervals. must length length dlt_intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"considers DLTs across cohorts observed far.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if no DLTs were observed in the whole study so far # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed so far # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed so far. my_increments <- IncrementsRelativeDLT(   dlt_intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLTCurrent-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"IncrementsRelativeDLTCurrent class increments control based relative differences current DLTs. class based number DLTs observed current cohort, cumulatively cohorts far.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"IncrementsRelativeDLTCurrent(dlt_intervals = c(0, 1), increments = c(2, 1))"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLTCurrent-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"dlt_intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"# As example, here is the rule for: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed.  my_increments <- IncrementsRelativeDLTCurrent(   dlt_intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeParts — IncrementsRelativeParts-class","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"IncrementsRelativeParts class increments control based relative differences intervals, special rules part 1 beginning part 2.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"IncrementsRelativeParts(dlt_start, clean_start, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (count) see slot definition. clean_start (count) see slot definition. ... Arguments passed IncrementsRelative intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"class works conjunction DataParts objects. part 2 just started next cohort, next maximum dose either dlt_start (e.g. \\-1) shift last part 1 dose case DLT part 1, clean_start shift (e.g. 0) case DLTs part 1. part 1 still next cohort, next dose level next higher dose level part1Ladder slot data object. part 2 started , usual relative increment rules apply, see IncrementsRelative.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (count) dose level increment starting part 2 case DLT part 1. clean_start (count) dose level increment starting part 2 case DLT part 1. less equal 0, part 1 ladder used find maximum next dose. Otherwise, relative increment rules applied find next maximum dose level.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/IncrementsRelativeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"my_increments <- IncrementsRelativeParts(dlt_start = 0, clean_start = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticIndepBeta — LogisticIndepBeta-class","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"LogisticIndepBeta class two-parameters logistic regression dose-limiting events (DLE) model prior expressed form pseudo data. model describes relationship binary DLE responses dose levels. specifically, represents relationship probabilities occurrence DLE corresponding dose levels log scale. model specified $$p(x) = exp(phi1 + phi2 * log(x)) / (1 + exp(phi1 + phi2 * log(x)))$$ \\(p(x)\\) probability occurrence DLE dose \\(x\\). two parameters model intercept \\(phi1\\) slope \\(phi2\\). LogisticIndepBeta inherits slots ModelTox class. context pseudo data, following three arguments used, binDLE, DLEdose DLEweights. DLEdose represents fixed dose levels pseudo DLE responses binDLE observed. DLEweights represents total number subjects treated per dose level DLEdose. binDLE represents number subjects observed DLE per dose level DLEdose. Hence, three vectors must length order elements vectors binDLE, DLEdose DLEweights must kept, element given vector corresponds elements remaining two vectors (see example insight). Finally, since least two DLE pseudo responses needed obtain prior modal estimates (maximum likelihood estimates) model parameters, binDLE, DLEdose DLEweights must vectors least length 2.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"LogisticIndepBeta(binDLE, DLEdose, DLEweights, data)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) number subjects observed DLE, pseudo DLE responses, depending dose levels DLEdose. Elements binDLE must correspond elements DLEdose DLEweights. DLEdose (numeric) dose levels pseudo DLE responses. Elements DLEdose must correspond elements binDLE DLEweights. DLEweights (numeric) total number subjects treated dose levels DLEdose, pseudo weights. Elements DLEweights must correspond elements binDLE DLEdose. data (Data) input data update estimates model parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"pseudo data can interpreted obtain observations trial starts. can used express prior, .e. initial beliefs model parameters. pseudo data expressed following way. First, fix least two dose levels, ask experts' opinion many subjects treated dose levels number subjects observed DLE. dose level, number subjects observed DLE, divided total number subjects treated, probability occurrence DLE particular dose level. probabilities occurrence DLE based pseudo data independent follow Beta distributions. Therefore, joint prior probability density function probabilities can obtained. Hence, change variable, joint prior probability density function two parameters model can also obtained. addition, conjugate joint prior density function two parameters model used. details form joint prior posterior probability density functions, please refer Whitehead Willamson (1998).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) vector total numbers DLE responses. must least length 2 order elements must correspond values specified DLEdose DLEweights. DLEdose (numeric) vector dose levels corresponding must least length 2 order elements must correspond values specified binDLE DLEweights. DLEweights (integer) total number subjects treated pseudo dose level DLEdose. must least length 2 order elements must correspond values specified binDLE DLEdose. phi1 (number)  intercept model. slot used output display resulting prior posterior modal estimate intercept obtained based pseudo data () observed data/responses. phi2 (number)  slope model. slot used output display resulting prior posterior modal estimate slope obtained based pseudo data () observed data/responses. Pcov (matrix) refers 2x2 covariance matrix intercept (\\(phi1\\)) slope parameters (\\(phi2\\)) model. used output display resulting prior posterior covariance matrix \\(phi1\\) \\(phi2\\) obtained, based pseudo data () observed data responses. slot needed internal purposes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticIndepBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we used an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- Data(doseGrid = seq(25, 300, 25))  # Fix two dose levels 25 and 300 mg (DLEdose). # Total number of subjects treated in each of these levels is 3, (DLEweights). # The number of subjects observed with a DLE is 1.05 at dose 25 mg and 1.8 at dose 300 mg (binDLE). my_model1 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = emptydata )  # Use observed DLE responses to obtain posterior modal estimates. my_data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model2 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = my_data )"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadane — LogisticKadane-class","title":"LogisticKadane — LogisticKadane-class","text":"LogisticKadane class logistic model parametrization Kadane et al. (1980).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadane — LogisticKadane-class","text":"","code":"LogisticKadane(theta, xmin, xmax)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadane — LogisticKadane-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ priors $$gamma ~ Unif(xmin, xmax).$$ $$rho0 ~ Unif(0, theta).$$","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadane — LogisticKadane-class","text":"slots class, required creating model, target toxicity, well minimum maximum dose range. Note can different minimum maximum dose grid data later .","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadane-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadane — LogisticKadane-class","text":"","code":"my_model <- LogisticKadane(theta = 0.33, xmin = 1, xmax = 200)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"LogisticKadaneBetaGamma class logistic model parametrization Kadane et al. (1980), using beta gamma distribution model priors.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"LogisticKadaneBetaGamma(theta, xmin, xmax, alpha, beta, shape, rate)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ prior gamma, $$gamma ~ Gamma(shape, rate).$$. prior rho0 = p(xmin), $$rho0 ~ Beta(alpha, beta).$$","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"slots class, required creating model, LogisticKadane class. addition, shape parameters Beta prior distribution rho0 shape rate parameters Gamma prior distribution gamma, required creating prior model.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticKadaneBetaGamma-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"my_model <- LogisticKadaneBetaGamma(   theta = 0.3,   xmin = 0,   xmax = 7,   alpha = 1,   beta = 19,   shape = 0.5625,   rate = 0.125 )"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormal — LogisticLogNormal-class","title":"LogisticLogNormal — LogisticLogNormal-class","text":"LogisticLogNormal class usual logistic regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"LogisticLogNormal(mean, cov, ref_dose = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormal — LogisticLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormal — LogisticLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 ) my_model #> An object of class \"LogisticLogNormal\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] -0.85  1.00 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]  1.0 -0.5 #> [2,] -0.5  1.0 #>  #> Slot \"prec\": #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 50 #>  #> Slot \"datamodel\": #> function ()  #> { #>     for (i in 1:nObs) { #>         logit(p[i]) <- alpha0 + alpha1 * log(x[i]/ref_dose) #>         y[i] ~ dbern(p[i]) #>     } #> } #> <bytecode: 0x55d06415a398> #> <environment: 0x55d066214938> #>  #> Slot \"priormodel\": #> function ()  #> { #>     theta ~ dmnorm(mean, prec) #>     alpha0 <- theta[1] #>     alpha1 <- exp(theta[2]) #> } #> <bytecode: 0x55d064190978> #> <environment: 0x55d0662146d0> #>  #> Slot \"modelspecs\": #> function (from_prior)  #> { #>     ms <- list(mean = params@mean, prec = params@prec) #>     if (!from_prior) { #>         ms$ref_dose <- ref_dose #>     } #>     ms #> } #> <bytecode: 0x55d06418d1a0> #> <environment: 0x55d0662146d0> #>  #> Slot \"init\": #> function ()  #> { #>     list(theta = c(0, 1)) #> } #> <bytecode: 0x55d06418da98> #> <environment: 0x55d0662146d0> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha0\" \"alpha1\" #>"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"LogisticLogNormalMixture class standard logistic model online mixture two bivariate log normal priors.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"LogisticLogNormalMixture(mean, cov, ref_dose, share_weight)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number). share_weight (proportion) prior weight share component.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"model can used data arising online informative component prior, time data trial main interest. Formally, achieved assuming probability DLT dose \\(x\\) given $$p(x) = \\pi * p1(x) + (1 - \\pi) * p2(x)$$ \\(\\pi\\) probability model \\(p(x)\\) model \\(p1(x)\\), informative component prior. model data arises parallel: doses xshare, DLT information yshare observed, total nObsshare data points (see DataMixture). hand, \\(1 - \\pi\\), probability separate model \\(p2(x)\\). components log normal prior distribution, can specified user, inherited LogisticLogNormal class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"share_weight (proportion) prior weight share component \\(p_{1}(x)\\).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"# Decide on the dose grid and MCMC options. dose_grid <- 1:80 my_options <- McmcOptions()  # Classic model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data <- Data(doseGrid = dose_grid) prior_samples <- mcmc(empty_data, my_model, my_options) plot(prior_samples, my_model, empty_data)   # Set up the mixture model and data share object. model_share <- LogisticLogNormalMixture(   share_weight = 0.1,   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data_share <- DataMixture(   doseGrid = dose_grid,   xshare = rep(c(10, 20, 40), each = 4),   yshare = rep(0L, 12), )  # Compare with the resulting prior model. prior_samples_share <- mcmc(empty_data_share, model_share, my_options) plot(prior_samples_share, model_share, empty_data_share)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalSub — LogisticLogNormalSub-class","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"LogisticLogNormalSub class standard logistic model bivariate (log) normal prior subtractive dose standardization.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"LogisticLogNormalSub(mean, cov, ref_dose = 0)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"covariate dose \\(x\\) minus reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * (x - x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticLogNormalSub-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"my_model <- LogisticLogNormalSub(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormal — LogisticNormal-class","title":"LogisticNormal — LogisticNormal-class","text":"LogisticNormal class usual logistic regression model bivariate normal prior intercept slope.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormal — LogisticNormal-class","text":"","code":"LogisticNormal(mean, cov, ref_dose = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormal — LogisticNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormal — LogisticNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ Normal(mean, cov).$$","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormal — LogisticNormal-class","text":"","code":"# Define the dose-grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )  my_options <- McmcOptions(burnin = 10, step = 2, samples = 100)  samples <- mcmc(empty_data, my_model, my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>   [1] -1.28172198 -0.91263381 -0.84405106 -2.31540826  0.26039531 -2.81306991 #>   [7] -1.93818598 -1.55773031 -0.17703084  0.65051522 -0.54425317 -0.76189022 #>  [13] -1.57848996 -2.83113303 -0.86956325 -2.33926023 -1.42749961 -0.26033265 #>  [19] -0.07507878 -1.40390143 -1.40474496 -0.70139458 -1.29395370 -0.08718175 #>  [25]  0.62445512 -0.89527904 -0.96347041 -1.12736238 -1.65521032 -0.51599000 #>  [31] -0.98051007 -0.55845133  1.34984139 -1.06425906 -0.46247190 -1.99213131 #>  [37] -0.75401503 -0.86030280  0.15593017 -1.52553068 -1.66683538 -1.62776717 #>  [43]  0.85500369  0.01949620  0.89506849 -0.13949628 -0.88095571 -1.84352346 #>  [49] -0.32337662 -2.71247857 -0.96291384 -1.68068886 -2.78054384 -0.44674460 #>  [55] -0.10688214 -1.66804330 -1.98607321  0.66316963 -3.68779257 -1.31953032 #>  [61] -0.64016095  0.44947898 -0.54498698 -2.26981563 -2.52956391 -1.65725360 #>  [67]  0.10752441 -0.45023046 -1.54793482 -1.34433425  0.13035572 -0.25966413 #>  [73] -0.94558214 -0.21954168 -2.20596121 -2.43564320 -1.06732996 -1.04280477 #>  [79] -0.66471577 -1.98245385 -1.48046011  1.20211523 -0.94319135 -2.66687422 #>  [85] -0.97075016 -1.23042763  0.19418780 -2.23919317 -0.56863786 -0.47219052 #>  [91] -1.59667862 -0.13121223 -1.15667041 -0.64900711 -0.50219450 -1.53902898 #>  [97] -1.56562425 -2.26532284 -2.13357069 -1.32866433 #>  #> $alpha1 #>   [1]  1.647602576  0.416706465  1.462739301  1.347508480  1.239470225 #>   [6]  1.243767288  0.817265745  1.479875716 -0.462258064  0.100318395 #>  [11]  1.682549609  1.380302697  2.409436229  1.595091349  1.040829953 #>  [16]  1.305568442  0.773210453  1.568752868  0.309456234  0.392763002 #>  [21]  0.655729564  2.711745455  0.289646896 -0.981123383  0.737937533 #>  [26]  1.951346271  1.217401952  1.104652583  0.806164160  0.002680763 #>  [31]  0.821455274  0.823940524  0.837442299 -0.096357894 -0.423244129 #>  [36]  0.548364759  0.472675881  1.020461421 -0.038352251  0.903535694 #>  [41]  2.166726310 -0.333677021  1.155748479 -0.978885507 -0.408955082 #>  [46]  0.770572890  0.707805054 -0.026908312  1.498419455  0.587718245 #>  [51] -0.511621686  1.170323418  1.850537529  0.644725801  1.671478901 #>  [56]  1.164691082  3.243649502 -0.354419929  3.915672384  2.952221582 #>  [61] -0.142567273  1.568172562  0.455798993  1.651685747  3.010929717 #>  [66]  0.626592298 -0.057492560 -0.551171316  0.601978895  1.487436798 #>  [71]  1.708737655  1.277048364  1.545828256  0.223281492  1.444919687 #>  [76]  0.659723853  0.188583799  1.845668239  1.070939621  2.514663954 #>  [81]  2.365549371 -0.674574249  0.565026550  1.372022688 -0.863660200 #>  [86]  2.374537154 -0.553016135  0.567557061  0.898252875 -0.864522184 #>  [91]  2.189765690  0.765217625  0.818001981  0.535027475 -0.193464648 #>  [96]  2.365791151  3.277787671  0.806255212  0.371558845  1.625319912 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 210 #>  #> Slot \"burnin\": #> [1] 10 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"LogisticNormalFixedMixture class standard logistic regression model fixed mixture multiple bivariate (log) normal priors intercept slope parameters. weights normal priors fixed, hence additional model parameters introduced. type prior often used better approximate given posterior distribution, information given terms mixture.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"LogisticNormalFixedMixture(components, weights, ref_dose, log_normal = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive normalized sum 1. ref_dose (number) reference dose \\(x*\\) (strictly positive number). log_normal (flag) log normal prior specified, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ normal prior used $$(alpha0, log(alpha1)) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ log normal prior used. weights \\(w1, ..., wK\\) components fixed sum 1. slots class comprise list components parameters. Every single component contains mean vector covariance matrix bivariate normal distributions. Remaining slots weights components well reference dose. Moreover, special indicator slot specifies whether log normal prior used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive must sum 1. ref_dose (positive_number) reference dose. log_normal (flag) log normal prior used, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalFixedMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"my_model <- LogisticNormalFixedMixture(   components = list(     comp1 = ModelParamsNormal(       mean = c(-0.85, 1),       cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)     ),     comp2 = ModelParamsNormal(       mean = c(1, 1.5),       cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)     )   ),   weights = c(0.3, 0.7),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalMixture — LogisticNormalMixture-class","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"LogisticNormalMixture class standard logistic regression model mixture two bivariate normal priors intercept slope parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"LogisticNormalMixture(comp1, comp2, weightpar, ref_dose)"},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. See ModelParamsNormal details. comp2 (ModelParamsNormal) bivariate normal prior specification second component. See ModelParamsNormal details. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w * Normal(mean1, cov1) + (1 - w) * Normal(mean2, cov2).$$ weight w first component assigned beta prior B(, b).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. comp2 (ModelParamsNormal) bivariate normal prior specification second component. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (positive_number) reference dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"weight two normal priors model parameter, hence flexible mixture. type prior often used mixture minimal informative informative component, order make CRM robust data deviations informative component.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/LogisticNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"my_model <- LogisticNormalMixture(   comp1 = ModelParamsNormal(     mean = c(-0.85, 1),     cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)   ),   comp2 = ModelParamsNormal(     mean = c(1, 1.5),     cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)   ),   weightpar = c(a = 1, b = 1),   ref_dose = 50 )"},{"path":"https://roche.github.io/crmPack/main/reference/McmcOptions-class.html","id":null,"dir":"Reference","previous_headings":"","what":"McmcOptions — McmcOptions-class","title":"McmcOptions — McmcOptions-class","text":"McmcOptions class three canonical MCMC options well Random Number Generator settings.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/McmcOptions-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"McmcOptions — McmcOptions-class","text":"","code":"McmcOptions(   burnin = 10000L,   step = 2L,   samples = 10000L,   rng_kind = NA_character_,   rng_seed = NA_integer_ )"},{"path":"https://roche.github.io/crmPack/main/reference/McmcOptions-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"McmcOptions — McmcOptions-class","text":"burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burn-. samples (count) number resulting samples. rng_kind (string) name RNG type. Possible types : Wichmann-Hill, Marsaglia-Multicarry, Super-Duper, Mersenne-Twister. NA (default), RNG kind chosen [rjags]. rng_seed (number) RNG seed corresponding chosen rng_kind. must integer value NA (default), means seed chosen [rjags].","code":""},{"path":"https://roche.github.io/crmPack/main/reference/McmcOptions-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"McmcOptions — McmcOptions-class","text":"iterations (count) number MCMC iterations. burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burnin. words, sample iteration = 1,...,iterations, saved (- burnin) mod step = 0. example, iterations = 6, burnin = 0 step = 2, samples iterations 2,4,6 saved. rng_kind (string) Random Number Generator (RNG) type used rjags. must one following four values: base::Wichmann-Hill, base::Marsaglia-Multicarry, base::Super-Duper, base::Mersenne-Twister, NA_character_. NA_character_ (default), RNG kind chosen rjags. rng_seed (number) Random Number Generator (RNG) seed used rjags chosen rng_kind. must integer scalar NA_integer_, means seed chosen rjags.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/McmcOptions-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"McmcOptions — McmcOptions-class","text":"","code":"# Set up MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. McmcOptions(burnin = 10000, step = 2, samples = 10000) #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 30000 #>  #> Slot \"burnin\": #> [1] 10000 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>"},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a minimally informative prior — MinimalInformative","title":"Construct a minimally informative prior — MinimalInformative","text":"function constructs minimally informative prior, captured LogisticNormal (LogisticLogNormal) object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"MinimalInformative(   dosegrid,   refDose,   threshmin = 0.2,   threshmax = 0.3,   probmin = 0.05,   probmax = 0.05,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a minimally informative prior — MinimalInformative","text":"dosegrid dose grid refDose reference dose threshmin toxicity probability threshold unlikely (see probmin) minimum dose (default: 0.2) threshmax toxicity probability threshold unlikely (see probmax) maximum dose (default: 0.3) probmin prior probability exceeding threshmin minimum dose (default: 0.05) probmax prior probability threshmax maximum dose (default: 0.05) ... additional arguments computations, see Quantiles2LogisticNormal, e.g. refDose logNormal=TRUE obtain minimal informative log normal prior.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a minimally informative prior — MinimalInformative","text":"see Quantiles2LogisticNormal","code":""},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a minimally informative prior — MinimalInformative","text":"Based proposal Neuenschwander et al (2008, Statistics Medicine), minimally informative prior distribution constructed. required key input minimum (\\(d_{1}\\) notation Appendix .1 paper) maximum value (\\(d_{J}\\)) dose grid supplied function. threshmin probability threshold \\(q_{1}\\), probability DLT larger \\(q_{1}\\) 5% probability. Therefore \\(q_{1}\\) 95% quantile beta distribution hence \\(p_{1} = 0.95\\). Likewise, threshmax probability threshold \\(q_{J}\\), probability DLT smaller \\(q_{J}\\) 5% probability (\\(p_{J} = 0.05\\)). probabilities \\(1 - p_{1}\\) \\(p_{J}\\) can controlled arguments probmin probmax, respectively. Subsequently, doses supplied dosegrid argument, beta distributions set assumption prior medians linear log-dose logit scale, Quantiles2LogisticNormal used transform resulting quantiles approximating LogisticNormal (LogisticLogNormal) model. Note reference dose required computations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/MinimalInformative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"# Setting up a minimal informative prior  # max.time is quite small only for the purpose of showing the example. They  # should be increased for a real case. set.seed(132) coarseGrid <- c(0.1, 10, 30, 60, 100) minInfModel <- MinimalInformative(dosegrid = coarseGrid,                                   refDose=50,                                   threshmin=0.2,                                   threshmax=0.3,                                   control=## for real case: leave out control                                      list(max.time=0.1))  #> It: 1, obj value: 0.6727662311  # Plotting the result matplot(x=coarseGrid,         y=minInfModel$required,         type=\"b\", pch=19, col=\"blue\", lty=1,         xlab=\"dose\",         ylab=\"prior probability of DLT\") matlines(x=coarseGrid,          y=minInfModel$quantiles,          type=\"b\", pch=19, col=\"red\", lty=1) legend(\"right\",        legend=c(\"quantiles\", \"approximation\"),        col=c(\"blue\", \"red\"),        lty=1,        bty=\"n\")"},{"path":"https://roche.github.io/crmPack/main/reference/ModelEff-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelEff — ModelEff-class","title":"ModelEff — ModelEff-class","text":"ModelEff parent class efficacy models using pseudo data prior. dedicated efficacy models prior specified form pseudo data (data trial starts). data must obey convention DataDual class. refers observed efficacy/biomarker responses (w DataDual), dose levels responses observed (x DataDual), dose levels considered study (doseGrid DataDual), finally specifications DataDual class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelEff-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelEff — ModelEff-class","text":"data (DataDual) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ModelLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelLogNormal — ModelLogNormal-class","title":"ModelLogNormal — ModelLogNormal-class","text":"ModelLogNormal class model reference dose bivariate normal prior model parameters alpha0 natural logarithm alpha1, .e.: $$(alpha0, log(alpha1)) ~ Normal(mean, cov),$$. Transformations log, e.g. identity, can specified priormodel slot. parameter alpha1 log-normal distribution default ensure positivity alpha1 guarantees exp(alpha1) > 1. slots class contain mean vector, covariance precision matrices bivariate normal distribution, well reference dose. Note precision matrix inverse covariance matrix JAGS. (\"normal\") model specific classes inherit class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelLogNormal — ModelLogNormal-class","text":"","code":"ModelLogNormal(mean, cov, ref_dose = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/ModelLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelLogNormal — ModelLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelLogNormal — ModelLogNormal-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (positive_number) reference dose.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ModelParamsNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelParamsNormal — ModelParamsNormal-class","title":"ModelParamsNormal — ModelParamsNormal-class","text":"ModelParamsNormal class bivariate normal model parameters, .e. mean vector, covariance matrix precision matrix. precision matrix inverse covariance matrix JAGS computed internally object constructor function.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelParamsNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean, cov)"},{"path":"https://roche.github.io/crmPack/main/reference/ModelParamsNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelParamsNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) mean vector. cov (matrix) covariance matrix. prec (matrix) precision matrix, inverse matrix cov.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ModelParamsNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean = c(1, 6), cov = diag(2)) #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] 1 6 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> Slot \"prec\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>"},{"path":"https://roche.github.io/crmPack/main/reference/ModelPseudo-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelPseudo — ModelPseudo-class","title":"ModelPseudo — ModelPseudo-class","text":"ModelPseudo parent class models express prior form pseudo data (data trial starts).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ModelTox-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelTox — ModelTox-class","title":"ModelTox — ModelTox-class","text":"ModelTox parent class DLE (dose-limiting events) models using pseudo data prior. dedicated DLE models toxicity models prior specified form pseudo data (data trial starts). data must obey convention Data class. refers observed DLE responses (y Data), dose levels (x Data) responses observed, dose levels considered study (doseGrid Data), finally specifications Data class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ModelTox-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelTox — ModelTox-class","text":"data (Data) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/NextBest-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBest — NextBest-class","title":"NextBest — NextBest-class","text":"NextBest virtual class finding next best dose, specific next best dose classes inherit.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestDualEndpoint — NextBestDualEndpoint-class","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"NextBestDualEndpoint class next best dose based dual endpoint model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"NextBestDualEndpoint(   target,   overdose,   max_overdose_prob,   target_relative = TRUE,   target_thresh = 0.01 )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition. target_relative (flag) see slot definition. target_thresh (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"rule, first admissible doses found, toxicity probability fall overdose category max_overdose_prob. Next, picks (remaining admissible doses) one maximizes probability target biomarker range. default (target_relative = TRUE) target specified relative maximum biomarker level across dose grid relative Emax parameter case parametric model selected (.e. DualEndpointBeta, DualEndpointEmax). However, target_relative = FALSE, absolute biomarker range can used target.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) biomarker target range needs reached. example, target range \\((0.8, 1.0)\\) target_relative = TRUE means target dose least \\(80\\%\\) maximum biomarker level. example, \\((0.5, 0.8)\\) mean target dose \\(50\\%\\) \\(80\\%\\) maximum biomarker level. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). max_overdose_prob (proportion) maximum overdose probability allowed. target_relative (flag) target specified relative? TRUE, target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. target_thresh (proportion) target probability threshold needs fulfilled target probability used deriving next best dose (default 0.01).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestDualEndpoint-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"# Target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT) > 0.35 (safety). my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Now, using absolute target on the natural biomarker scale. my_next_best_absolute <- NextBestDualEndpoint(   target = c(200, 300),   overdose = c(0.35, 1),   max_overdose_prob = 0.25,   target_relative = FALSE )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestInfTheory-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestInfTheory — NextBestInfTheory-class","title":"NextBestInfTheory — NextBestInfTheory-class","text":"NextBestInfTheory class next best dose based information theory proposed https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestInfTheory-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestInfTheory — NextBestInfTheory-class","text":"","code":"NextBestInfTheory(target, asymmetry)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestInfTheory-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) see slot definition. asymmetry (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestInfTheory-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) target toxicity probability, except 0 1. asymmetry (number) value asymmetry exponent divergence function describes rate penalization overly toxic . must value \\((0, 2)\\) interval.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMTD — NextBestMTD-class","title":"NextBestMTD — NextBestMTD-class","text":"NextBestMTD class next best dose based MTD estimate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMTD — NextBestMTD-class","text":"","code":"NextBestMTD(target, derive)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) see slot definition. derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) target toxicity probability, except 0 1. derive (function) function derives final next best MTD estimate, based vector posterior MTD samples. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMTD — NextBestMTD-class","text":"","code":"# In the example below, the MTD is defined as the dose for which prob(DLE) = 0.33 # and we will use the 25th quantile of the posterior of MTD as our next best dose. next_best_mtd <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGain-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGain — NextBestMaxGain-class","title":"NextBestMaxGain — NextBestMaxGain-class","text":"NextBestMaxGain class find next best dose maximum gain value based pseudo DLT efficacy models without samples. based solely probabilities occurrence DLT values mean efficacy responses obtained using modal estimates DLT efficacy model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes (except EffFlexi).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGain-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"NextBestMaxGain(prob_target_drt, prob_target_eot)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGain-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGain-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) target probability occurrence DLT used trial. prob_target_eot (proportion) target probability occurrence DLT used end trial.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGain-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"my_next_best <- NextBestMaxGain(0.35, 0.3)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGainSamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"NextBestMaxGainSamples class find next best dose maximum gain value based pseudo DLT efficacy models DLT efficacy samples. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGainSamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"NextBestMaxGainSamples(prob_target_drt, prob_target_eot, derive, mg_derive)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGainSamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"prob_target_drt (proportion) see slot definition NextBestMaxGain. prob_target_eot (proportion) see slot definition NextBestMaxGain. derive (function) see slot definition. mg_derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGainSamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number. mg_derive (function) derives, based vector posterior dose samples give maximum gain value, final next best estimate dose gives maximum gain value. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMaxGainSamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. # For `mg_derive` function (which takes the sample of doses which give the maximum # gain), we will use the 50% posterior quantile (the median or th 50th percentile) # of the sample. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMinDist-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMinDist — NextBestMinDist-class","title":"NextBestMinDist — NextBestMinDist-class","text":"NextBestMinDist class next best dose based minimum distance target probability.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMinDist-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"NextBestMinDist(target)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMinDist-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMinDist-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) single target toxicity probability, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestMinDist-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"# In the example below, the MTD is defined as the dose with the toxicity rate # with minimal distance to the target of 30%. next_best_min_dist <- NextBestMinDist(target = 0.3)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRM — NextBestNCRM-class","title":"NextBestNCRM — NextBestNCRM-class","text":"NextBestNCRM class next best dose finds next dose high posterior probability target toxicity interval.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"NextBestNCRM(target, overdose, max_overdose_prob)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestNCRM — NextBestNCRM-class","text":"avoid numerical problems, dose selection algorithm implemented follows: First admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, maximum probability fall target category calculated. 5% (.e. just numerical error), corresponding dose next recommended dose. Otherwise, highest admissible dose next recommended dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) target toxicity interval (limits included). overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). used filter probability samples. max_overdose_prob (proportion) maximum overdose posterior probability allowed, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35,1]. Finally we would like to constrain the # probability of overdosing below 25%. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRMLoss — NextBestNCRMLoss-class","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"NextBestNCRMLoss class based NCRM rule loss function. class similar NextBestNCRM class, differences addition loss function re-defined toxicity intervals, see toxicity interval documentation note details. NCRM rule, first admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, loss function calculated, .e. losses %*% target. Finally, corresponding dose lowest loss function (Bayes risk) recommended next dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"NextBestNCRMLoss(   target,   overdose,   unacceptable = c(1, 1),   max_overdose_prob,   losses )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. unacceptable (numeric) see slot definition. max_overdose_prob (proportion) see slot definition NextBestNCRM. losses (numeric) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) target toxicity interval (limits included). probability range excluding 0 1. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included) excessive toxicity interval (lower limit excluded, upper limit included) unacceptable provided. probability range. used filter probability samples. unacceptable (numeric) unacceptable toxicity interval (lower limit excluded, upper limit included). must specified overdose include 1. Otherwise, c(1, 1) (default), essentially scalar equals 1. probability range. losses (numeric) vector specifying loss function. unacceptable provided, vector length must 4, otherwise 3.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"loss function vector either 3 4 values. loss function values must specified interval, -dosing, target toxicity, overdosing toxicity -dosing, target toxicity, overdosing (excessive) toxicity, unacceptable toxicity intervals.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestNCRMLoss-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35, 1]. We would like to constrain the probability # of overdosing below 25%. The loss function is c(1, 0, 1, 2). my_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.25,   losses = c(1, 0, 1, 2) )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTD — NextBestTD-class","title":"NextBestTD — NextBestTD-class","text":"NextBestTD class find next best dose based pseudo DLT model without samples. Namely, find two next best doses, one allocation trial second final recommendation end trial without involving samples, .e. DLT responses incorporated dose-allocation. based solely probabilities occurrence DLT obtained using modal estimates model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTD — NextBestTD-class","text":"","code":"NextBestTD(prob_target_drt, prob_target_eot)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) target probability (except 0 1) occurrence DLT used trial. prob_target_eot (proportion) target probability (except 0 1) occurrence DLT used end trial.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTD — NextBestTD-class","text":"","code":"my_next_best <- NextBestTD(0.35, 0.3)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTDsamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTDsamples — NextBestTDsamples-class","title":"NextBestTDsamples — NextBestTDsamples-class","text":"NextBestTDsamples class find next best dose based Pseudo DLT model samples. Namely, find two next best doses, one allocation trial second final recommendation end trial. Hence, two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTDsamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"NextBestTDsamples(prob_target_drt, prob_target_eot, derive)"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTDsamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTDsamples — NextBestTDsamples-class","text":"prob_target_drt (proportion) see slot definition NextBestTD. prob_target_eot (proportion) see slot definition NextBestTD. derive (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTDsamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTDsamples — NextBestTDsamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestTDsamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. my_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestThreePlusThree-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestThreePlusThree — NextBestThreePlusThree-class","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"NextBestThreePlusThree class next best dose implements classical 3+3 dose recommendation. input required, hence class slots.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/NextBestThreePlusThree-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"NextBestThreePlusThree()"},{"path":"https://roche.github.io/crmPack/main/reference/NextBestThreePlusThree-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"# Next best dose class object using the classical 3+3 design. my_next_best <- NextBestThreePlusThree()"},{"path":"https://roche.github.io/crmPack/main/reference/OneParExpPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParExpPrior — OneParExpPrior-class","title":"OneParExpPrior — OneParExpPrior-class","text":"OneParExpPrior class standard CRM exponential prior power parameter skeleton prior probabilities. implementation version one-parameter CRM (O’Quigley et al. 1990).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/OneParExpPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"OneParExpPrior(skel_probs, dose_grid, lambda)"},{"path":"https://roche.github.io/crmPack/main/reference/OneParExpPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_probs see slot definition. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. lambda see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/OneParExpPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. lambda (number) rate parameter prior exponential distribution theta.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/OneParExpPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"my_model <- OneParExpPrior(   skel_probs = c(0.1, 0.3, 0.5, 0.7, 0.9),   dose_grid = 1:5,   lambda = 2 )"},{"path":"https://roche.github.io/crmPack/main/reference/OneParLogNormalPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParLogNormalPrior — OneParLogNormalPrior-class","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"OneParLogNormalPrior class standard CRM normal prior log power parameter skeleton prior probabilities.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/OneParLogNormalPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"OneParLogNormalPrior(skel_probs, dose_grid, sigma2)"},{"path":"https://roche.github.io/crmPack/main/reference/OneParLogNormalPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/OneParLogNormalPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/OneParLogNormalPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"my_model <- OneParLogNormalPrior(   skel_probs = seq(from = 0.1, to = 0.9, length = 5),   dose_grid = 1:5,   sigma2 = 2 )"},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormal — ProbitLogNormal-class","title":"ProbitLogNormal — ProbitLogNormal-class","text":"ProbitLogNormal class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"ProbitLogNormal(mean, cov, ref_dose = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormal — ProbitLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormal — ProbitLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormal — ProbitLogNormal-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"my_model <- ProbitLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 7.2 )"},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormalRel — ProbitLogNormalRel-class","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"ProbitLogNormalRel class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"ProbitLogNormalRel(mean, cov, ref_dose = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"covariate dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * x/x*,$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/ProbitLogNormalRel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"my_model <- ProbitLogNormalRel(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )"},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","title":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","text":"class captures trial simulations design using DLE efficacy responses. design model ModelTox class efficacy model EffFlexi class contains slots GeneralSimulations, PseudoSimulations PseudoDualSimulations object. comparison parent class PseudoDualSimulations, contains additional slots capture sigma2betaW estimates.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"This is a class which captures the trial simulations design using both the\nDLE and efficacy responses. The design of model from ModelTox\nclass and the efficacy model from EffFlexi class\nIt contains all slots from\nGeneralSimulations, PseudoSimulations\nand PseudoDualSimulations object.\nIn comparison to the parent class PseudoDualSimulations,\nit contains additional slots to\ncapture the sigma2betaW estimates. — PseudoDualFlexiSimulations-class","text":"sigma2betaWest vector final posterior mean sigma2betaW estimates","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"Initialization function 'PseudoDualFlexiSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"","code":"PseudoDualFlexiSimulations(sigma2betaWest, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"sigma2betaWest please refer PseudoDualFlexiSimulations class object ... additional parameters PseudoDualSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualFlexiSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'PseudoDualFlexiSimulations' class — PseudoDualFlexiSimulations","text":"PseudoDualFlexiSimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class PseudoDualSimulations — PseudoDualSimulations-class","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"class captures trial simulations design using DLE efficacy responses. design model ModelTox class efficacy model ModelEff class (except EffFlexi class). contains slots GeneralSimulations PseudoSimulations object. comparison parent class PseudoSimulations, contains additional slots capture dose-efficacy curve sigma2 estimates.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class PseudoDualSimulations — PseudoDualSimulations-class","text":"fitEff list final values. DLE efficacy samples generated, contains final fitted values. DLE efficacy samples used, contains modal estimates parameters two models posterior estimates probabilities occurrence DLE expected efficacy responses. FinalGstarEstimates vector final estimates Gstar end simulations. FinalGstarAtDoseGrid vector final estimates Gstar dose Grid end simulations FinalGstarCIs list 95% credibility interval final estimates Gstar FinalGstarRatios vector ratios CI, ratio upper lower 95% credibility interval final estimates Gstar FinalOptimalDose vector final optimal dose, minimum final TDtargetEndOfTrial estimates Gstar estimates FinalOptimalDoseAtDoseGrid vector final optimal dose, minimum final TDtargetEndOfTrial estimates Gstar estimates dose Grid sigma2est vector final posterior mean sigma2 estimates","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"Initialization function 'DualPseudoSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"","code":"PseudoDualSimulations(   fitEff,   FinalGstarEstimates,   FinalGstarAtDoseGrid,   FinalGstarCIs,   FinalGstarRatios,   FinalOptimalDose,   FinalOptimalDoseAtDoseGrid,   sigma2est,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"fitEff please refer PseudoDualSimulations class object FinalGstarEstimates please refer PseudoDualSimulations class object FinalGstarAtDoseGrid please refer PseudoDualSimulations class object FinalGstarCIs please refer PseudoDualSimulations class object FinalGstarRatios please refer PseudoDualSimulations class object FinalOptimalDose please refer PseudoDualSimulations class object FinalOptimalDoseAtDoseGrid please refer PseudoDualSimulations class object sigma2est please refer PseudoDualSimulations class object ... additional parameters PseudoSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'DualPseudoSimulations' class — PseudoDualSimulations","text":"PseudoDualSimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"contains slots PseudoSimulationsSummary object. addition slots parent class PseudoSimulationsSummary, contains four slots efficacy model fit information.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoDualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"targetGstar target dose level gain value maximum targetGstarAtDoseGrid dose level dose Grid closest Gstar GstarSummary six-number table summary (lowest, 25th, 50th (median), 75th percentile, mean highest value) final Gstar values obtained across simulations ratioGstarSummary six-number summary table ratios upper lower 95% credibility intervals final Gstar across simulations EffFitAtDoseMostSelected fitted expected mean efficacy value dose often selected meanEffFit list mean, lower (2.5%) upper (97.5%) quantiles fitted expected efficacy value dose level.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class PseudoSimulations — PseudoSimulations-class","title":"Class PseudoSimulations — PseudoSimulations-class","text":"class captures trial simulations designs using pseudo model. design DLE responses model ModelTox class object. contains slots GeneralSimulations object. Additional slots fit stopReasons compared general class GeneralSimulations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class PseudoSimulations — PseudoSimulations-class","text":"fit list final values. samples involved, final fitted values. samples involved, included final modal estimates model parameters posterior estimates probabilities occurrence DLE. FinalTDtargetDuringTrialEstimates vector final estimates (last estimate ) TDtargetDuringTrial end simulations/trial stops FinalTDtargetEndOfTrialEstimates vector final estimates last estimate TDtargetEndOfTrial trial stops FinalTDtargetDuringTrialAtDoseGrid vector dose levels dose grid closest final TDtargetDuringTrial estimates FinalTDtargetEndOfTrialAtDoseGrid vector  dose levels dose grid closest final TDtargetEndOfTrial estimates FinalTDEOTCIs list 95% credibility interval final estimates TDtargetEndOfTrial FinalTDEOTRatios vector ratios CI, ratio upper lower 95% credibility intervals final estimates TDtargetEndOfTrial FinalCIs list final 95% credibility intervals TDtargetEndofTrial estimates final optimal dose estimates DLE efficacy responses incorporated simulations FinalRatios vector final ratios, ratios upper lower 95% credibility interval final estimates TDtargetEndOfTrial final optimal dose estimates (DLE efficacy responses incorporated) simulations stopReasons add slot description","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"Initialization function 'PseudoSimulations' class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"","code":"PseudoSimulations(   fit,   FinalTDtargetDuringTrialEstimates,   FinalTDtargetEndOfTrialEstimates,   FinalTDtargetDuringTrialAtDoseGrid,   FinalTDtargetEndOfTrialAtDoseGrid,   FinalTDEOTCIs,   FinalTDEOTRatios,   FinalCIs,   FinalRatios,   stopReasons,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"fit please refer PseudoSimulations class object FinalTDtargetDuringTrialEstimates please refer PseudoSimulations class object FinalTDtargetEndOfTrialEstimates please refer PseudoSimulations class object FinalTDtargetDuringTrialAtDoseGrid please refer PseudoSimulations class object FinalTDtargetEndOfTrialAtDoseGrid please refer PseudoSimulations class object FinalTDEOTCIs please refer PseudoSimulations class object FinalTDEOTRatios please refer PseudoSimulations class object FinalCIs please refer PseudoSimulations class object FinalRatios please refer PseudoSimulations class object stopReasons please refer PseudoSimulations class object ... additional parameters GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function of the 'PseudoSimulations' class — PseudoSimulations","text":"PseudoSimulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/PseudoSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"targetEndOfTrial target probability DLE wanted end trial targetDoseEndOfTrial dose level corresponds target probability DLE wanted end trial, TDEOT targetDoseEndOfTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted end trial targetDuringTrial target probability DLE wanted trial targetDoseDuringTrial dose level corresponds target probability DLE wanted trial. TDDT targetDoseDuringTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted trial TDEOTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want end trial across simulations TDDTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want trial across simulations FinalDoseRecSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final optimal doses, either TDEOT DLE response incorporated escalation procedure minimum TDEOT Gstar DLE efficacy responses incorporated, across simulations ratioTDEOTSummary six-number summary table final ratios upper lower 95% credibility intervals final TDEOTs across simulations FinalRatioSummary six-number summary table final ratios upper lower 95% credibility intervals final optimal doses across simulations #@slot doseRec dose level recommend subsequent study nsim number simulations propDLE proportions DLE trials meanToxRisk mean toxicity risks patients doseSelected doses selected MTD (targetDoseEndOfTrial) toxAtDosesSelected true toxicity doses selected propAtTargetEndOfTrial Proportion trials selecting doseGrid closest MTD, targetDoseEndOfTrial propAtTargetDuringTrial Proportion trials selecting doseGrid closest targetDoseDuringTrial doseMostSelected dose often selected MTD obsToxRateAtDoseMostSelected observed toxicity rate dose often selected nObs number patients overall nAboveTargetEndOfTrial number patients treated targetDoseEndOfTrial nAboveTargetDuringTrial number patients treated targetDoseDuringTrial doseGrid dose grid used fitAtDoseMostSelected fitted toxicity rate dose often selected meanFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Quantiles2LogisticNormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"function uses generalized simulated annealing optimize LogisticNormal model close possible given prior quantiles.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Quantiles2LogisticNormal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"","code":"Quantiles2LogisticNormal(   dosegrid,   refDose,   lower,   median,   upper,   level = 0.95,   logNormal = FALSE,   parstart = NULL,   parlower = c(-10, -10, 0, 0, -0.95),   parupper = c(10, 10, 10, 10, 0.95),   seed = 12345,   verbose = TRUE,   control = list(threshold.stop = 0.01, maxit = 50000, temperature = 50000, max.time =     600) )"},{"path":"https://roche.github.io/crmPack/main/reference/Quantiles2LogisticNormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"dosegrid dose grid refDose reference dose lower lower quantiles median medians upper upper quantiles level credible level (lower, upper) intervals (default: 0.95) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used parstart starting values parameters. default, determined medians supplied. parlower lower bounds parameters (intercept alpha slope beta, corresponding standard deviations correlation.) parupper upper bounds parameters seed seed random number generation verbose verbose? (default) control additional options optimisation routine, see GenSA details","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Quantiles2LogisticNormal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert prior quantiles (lower, median, upper) to logistic (log)\nnormal model — Quantiles2LogisticNormal","text":"list best approximating model (LogisticNormal LogisticLogNormal), resulting quantiles, required quantiles distance required quantiles, well final parameters (used running algorithm second time)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Report.html","id":null,"dir":"Reference","previous_headings":"","what":"A Reference Class to represent sequentially updated reporting objects. — Report","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"Reference Class represent sequentially updated reporting objects.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Report.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"object object report df data frame columns sequentially added dfNames names strings sequentially added","code":""},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for rule-based designs — RuleDesign-class","title":"Class for rule-based designs — RuleDesign-class","text":"difference Design class model, stopping increments slots missing.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for rule-based designs — RuleDesign-class","text":"nextBest find next best dose, object class NextBest cohortSize rules cohort sizes, object class CohortSize data dose grid, previous data, etc., contained object class Data startingDose starting dose? Must lie grid data","code":""},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for rule-based designs — RuleDesign-class","text":"","code":"emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(nextBest = NextBestThreePlusThree(),                        cohortSize = CohortSizeConst(size=3L),                        data = emptydata,                        startingDose = 5)"},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"RuleDesign\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"RuleDesign(nextBest, cohortSize, data, startingDose)"},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"nextBest see RuleDesign cohortSize see RuleDesign data see RuleDesign startingDose see RuleDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/RuleDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"RuleDesign object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindow-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindow — SafetyWindow-class","title":"SafetyWindow — SafetyWindow-class","text":"SafetyWindow class safety window.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowConst — SafetyWindowConst-class","title":"SafetyWindowConst — SafetyWindowConst-class","text":"SafetyWindowConst class safety window length used gap kept constant.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"SafetyWindowConst(gap, follow, follow_min)"},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap (integer) vector, constant gap patients. follow (count) long follow patient. period time patient cohort needs followed next cohort opens. follow_min (count) minimum follow . least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"# This is to have along the study constant parameters settings of safety window # length, regardless of the cohort size. my_win_len <- SafetyWindowConst(   gap = c(7, 5, 3),   follow = 7,   follow_min = 14 )"},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowSize — SafetyWindowSize-class","title":"SafetyWindowSize — SafetyWindowSize-class","text":"SafetyWindowSize class safety window length based cohort size. class used decide rolling rule clinical perspective.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"SafetyWindowSize(gap, size, follow, follow_min)"},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap see slot definition. size see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowSize-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap (list) observed period previous patient next patient can dosed. used follows. instance, cohort size 4 want specify three time intervals four consecutive patients, .e. 7 units time 1st 2nd patient, 5 units 2nd 3rd one, finally 3 units 3rd 4th one, , gap = list(c(7L, 5L, 3L)). Sometimes, want interval 1st 2nd patient increased safety consideration rest time intervals remain constant, regardless cohort size . , gap = list(c(7L, 3L)) package automatically repeat last element vector remaining time intervals. size (integer) vector left bounds relevant cohort size intervals. used follows. instance, want change gap based cohort size, .e. time interval 1st 2nd patient = 9 units time rest time intervals 5 units time cohort size equal larger 4. time interval 1st 2nd patient = 7 units time rest time intervals 3 units time cohort size smaller 4, specify size = c(0L, 4L). means, right bound intervals exclusive interval, last interval goes last value infinity. follow (count) period time patient cohort needs followed next cohort opens. follow_min (count) least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SafetyWindowSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"# Rule for having patient gap (7,3,3,3,...) for cohort size < 4, and # patient gap (9,5,5,5...) for cohort size >= 4. my_window_len <- SafetyWindowSize(   gap = list(c(7, 3), c(9, 5)),   size = c(1, 4),   follow = 7,   follow_min = 14 )"},{"path":"https://roche.github.io/crmPack/main/reference/Samples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the MCMC output — Samples-class","title":"Class for the MCMC output — Samples-class","text":"Class MCMC output","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Samples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the MCMC output — Samples-class","text":"data list entry contains samples (vector-valued) parameter vector/matrix format (number samples) x (dimension parameter). options McmcOptions used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Samples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class for the MCMC output — Samples-class","text":"","code":"# Saving the mcmc options which were used to generate the samples options <- McmcOptions(burnin=10000,                        step=2,                        samples=10000)  # Create an object of class 'Samples' # Here the parameters 'alpha' and 'beta' are randomly generated. Of coure in  # a real example these would come as an output from mcmc procedures samples <- Samples(data=list(alpha=rnorm(10000),beta=rnorm(10000)),                    options=options)"},{"path":"https://roche.github.io/crmPack/main/reference/Samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for ","title":"Initialization function for ","text":"Initialization function \"Samples\"","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for ","text":"","code":"Samples(data, options)"},{"path":"https://roche.github.io/crmPack/main/reference/Samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for ","text":"data see Samples options see Samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for ","text":"Samples object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Simulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the simulations output from model based designs — Simulations-class","title":"Class for the simulations output from model based designs — Simulations-class","text":"class captures trial simulations model based designs. Additional slots fit stopReasons compared general class GeneralSimulations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Simulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the simulations output from model based designs — Simulations-class","text":"fit list final fits stopReasons list stopping reasons simulation run","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Simulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for the ","title":"Initialization function for the ","text":"Initialization function \"Simulations\" class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Simulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for the ","text":"","code":"Simulations(fit, stopReasons, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/Simulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for the ","text":"fit see Simulations stopReasons see Simulations ... additional parameters GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Simulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for the ","text":"Simulations object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of model-based simulations output — SimulationsSummary-class","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"addition slots parent class GeneralSimulationsSummary, contains two slots model fit information.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/SimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of model-based simulations output — SimulationsSummary-class","text":"fitAtDoseMostSelected fitted toxicity rate dose often selected meanFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Stopping-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Stopping — Stopping-class","title":"Stopping — Stopping-class","text":"Stopping class stopping rules.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAll-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAll — StoppingAll-class","title":"StoppingAll — StoppingAll-class","text":"StoppingAll class testing stopping rule consists many single stopping rules turn objects class Stopping. single stopping rules must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAll-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAll — StoppingAll-class","text":"","code":"StoppingAll(stop_list)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAll-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAll-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) list stopping rules.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAll-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAll — StoppingAll-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAll`) which would then be # summarized by the `all` function, meaning that the study would be stopped only # if all of the single stopping rules are `TRUE`. my_stopping <- StoppingAll(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAny-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAny — StoppingAny-class","title":"StoppingAny — StoppingAny-class","text":"StoppingAny class testing stopping rule consists many single stopping rules turn objects class Stopping. least one single stopping rule must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAny-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAny — StoppingAny-class","text":"","code":"StoppingAny(stop_list)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAny-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAny-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) list stopping rules.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingAny-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAny — StoppingAny-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAny`) which would then be # summarized by the `any` function, meaning that the study would be stopped if # any of the single stopping rules is `TRUE`. my_stopping <- StoppingAny(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingCohortsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"StoppingCohortsNearDose class stopping based number cohorts near next best dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingCohortsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"StoppingCohortsNearDose(nCohorts = 2L, percentage = 50)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingCohortsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) see slot definition. percentage (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingCohortsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) number required cohorts. percentage (number) percentage (including 0 100) within next best dose cohorts must lie.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingCohortsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"# Here, is the rule for stopping the study if at least 3 cohorts were dosed # at a dose within (1 +/- 0.2) of the next best dose. my_stopping <- StoppingCohortsNearDose(   nCohorts = 3,   percentage = 0.2 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingHighestDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingHighestDose — StoppingHighestDose-class","title":"StoppingHighestDose — StoppingHighestDose-class","text":"StoppingHighestDose class stopping based highest dose. , stopping occurs highest dose reached.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingHighestDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"StoppingHighestDose()"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingHighestDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"# The following stopping rule is met when: # - next proposed dose is highest dose, and # - there are already at least 3 patients on that dose, and # - we are sure that this dose is safe, e.g. the probability to be in (0%, 20%) # interval of the DLT rate is above 50%. my_stopping <- StoppingHighestDose() &   StoppingPatientsNearDose(nPatients = 3, percentage = 0) &   StoppingTargetProb(target = c(0, 0.2), prob = 0.5)  # We note that this rule would then need to be combined with the other standard # stopping rules, when the MTD is found based on being near e.g. a 30% DLT # probability or having reached maximal sample size, in the manner of: # stop_rule <- stop_high | stop_low | stop_sample_size # nolintr."},{"path":"https://roche.github.io/crmPack/main/reference/StoppingList-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingList — StoppingList-class","title":"StoppingList — StoppingList-class","text":"StoppingList class testing stopping rule consists many single stopping rules turn objects class Stopping. summary slot stores function takes logical vector size stop_list returns single logical value. example, function specified summary function, stopping rules defined stop_list must satisfied order result rule TRUE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingList-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingList — StoppingList-class","text":"","code":"StoppingList(stop_list, summary)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingList-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingList — StoppingList-class","text":"stop_list (list) see slot definition. summary (function) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingList-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingList — StoppingList-class","text":"stop_list (list) list stopping rules. summary (function) summary function combine results stopping rules single result.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingList-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingList — StoppingList-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingList`) which will then be # summarized (in this specific example) with the `any` function, meaning that # the study would be stopped if any of the single stopping rules is `TRUE`. my_stopping <- StoppingList(   stop_list = c(my_stopping1, my_stopping2, my_stopping3),   summary = any )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"StoppingLowestDoseHSRBeta class stopping based Hard Safety Rule using Beta posterior distribution Beta(,b) prior Bin-Beta model based observed data lowest dose level. rule triggered first dose considered toxic (.e. threshold probability) based observed data lowest dose level Beta(,b) prior distribution. default prior Beta(1,1). case placebo used, rule evaluated second dose dose grid, .e. lowest non-placebo dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"StoppingLowestDoseHSRBeta(target = 0.3, prob = 0.95, a = 1, b = 1)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) target toxicity. prob (proportion) threshold probability lowest dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"stopping rule independent underlying model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"# Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(0.5,0.5) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9,   a = 0.5,   b = 0.5 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDCV-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDCV — StoppingMTDCV-class","title":"StoppingMTDCV — StoppingMTDCV-class","text":"StoppingMTDCV class stopping rule based precision MTD calculated coefficient variation (CV) MTD. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDCV-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"StoppingMTDCV(target = 0.3, thresh_cv = 40)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDCV-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) see slot definition. thresh_cv (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDCV-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) toxicity target MTD (except 0 1). thresh_cv (number) threshold (percentage > 0) CV considered accurate enough stop trial. stopping occurs CV less equal tresh_cv.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDCV-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"# Stopping the study if the MTD estimation is precise enough, i.e. if robust # coefficient of variation of the MTD is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDdistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDdistribution — StoppingMTDdistribution-class","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"StoppingMTDdistribution class stopping based posterior distribution MTD. used cases stopping occurs probability MTD > thresh * next_dose greater equal prob, next_dose recommended next best dose. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDdistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"StoppingMTDdistribution(target, thresh, prob)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDdistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) see slot definition. thresh (proportion) see slot definition. prob (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDdistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) target toxicity probability (except 0 1) defining MTD. thresh (proportion) threshold (except 0 1) relative recommended next best dose. prob (proportion) required minimum probability, except 0 1.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMTDdistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"# As example, here is the rule for stopping the study if there is at least 0.9 # probability that MTD > 0.5 * next_dose. Here MTD is defined as the dose for # which prob(DLT) = 0.33 my_stopping <- StoppingMTDdistribution(   target = 0.33,   thresh = 0.5,   prob = 0.9 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMaxGainCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"StoppingMaxGainCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate : (1) target dose (.e. dose corresponds given target probability occurrence DLT prob_target), (2) max gain dose (.e. dose gives maximum gain), depending one two smaller.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMaxGainCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"StoppingMaxGainCIRatio(target_ratio, prob_target)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMaxGainCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMaxGainCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMaxGainCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinCohorts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinCohorts — StoppingMinCohorts-class","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"StoppingMinCohorts class stopping based minimum number cohorts.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinCohorts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"StoppingMinCohorts(nCohorts)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinCohorts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinCohorts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) minimum required number cohorts.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinCohorts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"# As example, here is the rule for stopping the study if at least 6 cohorts # were already dosed. my_stopping <- StoppingMinCohorts(nCohorts = 6)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinPatients-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinPatients — StoppingMinPatients-class","title":"StoppingMinPatients — StoppingMinPatients-class","text":"StoppingMinPatients class stopping based minimum number patients","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinPatients-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"StoppingMinPatients(nPatients)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinPatients-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinPatients-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) minimum allowed number patients.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingMinPatients-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"# As example, here is the rule for stopping the study if at least 20 patients # were already dosed my_stopping <- StoppingMinPatients(nPatients = 20)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingPatientsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"StoppingPatientsNearDose class stopping based number patients near next best dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingPatientsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"StoppingPatientsNearDose(nPatients, percentage = 50)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingPatientsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) see slot definition. percentage (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingPatientsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) number required patients. percentage (number) percentage (including 0 100) within next best dose patients must lie.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingPatientsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"# As example, here is the rule for stopping the study if at least 9 patients # were dosed at a dose within (1 +/- 0.2) of the next best dose.  my_stopping <- StoppingPatientsNearDose(   nPatients = 9,   percentage = 20 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingSpecificDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingSpecificDose — StoppingSpecificDose-class","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"StoppingSpecificDose class testing stopping rule specific dose dose grid next best dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingSpecificDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"StoppingSpecificDose(rule, dose)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingSpecificDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) see slot definition. dose (number) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingSpecificDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) stopping rule available package. dose (positive_number) dose defined part dose grid data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingSpecificDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"# Stop if highest dose 80 is safe. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 )  # Stop if lowest dose 10 is toxic. lowest_dose_toxic <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0.3, 1), prob = 0.8),   dose = 10 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTDCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTDCIRatio — StoppingTDCIRatio-class","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"StoppingTDCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate target dose (.e. dose corresponds given target probability occurrence DLT prob_target).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTDCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"StoppingTDCIRatio(target_ratio, prob_target)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTDCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTDCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTDCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingTDCIRatio(   target_ratio = 5,   prob_target = 0.3 )"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetBiomarker-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"StoppingTargetBiomarker class stopping based probability target biomarker.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetBiomarker-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"StoppingTargetBiomarker(target, prob, is_relative = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetBiomarker-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) see slot definition. prob (proportion) see slot definition. is_relative (flag) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetBiomarker-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) biomarker target range needs reached. example, target = c(0.8, 1.0) is_relative = TRUE means target dose least 80% maximum biomarker level. is_relative (flag) target relative? (default), target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. prob (proportion) required target probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetBiomarker-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"# Stopping the study if there is at least 0.5 probability that the biomarker # (efficacy) is within the biomarker target range of [0.9, 1.0] (relative to the # maximum for the biomarker).  my_stopping <- StoppingTargetBiomarker(target = c(0.9, 1), prob = 0.5)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetProb-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetProb — StoppingTargetProb-class","title":"StoppingTargetProb — StoppingTargetProb-class","text":"StoppingTargetProb class stopping based probability DLT rate target toxicity interval.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetProb-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"StoppingTargetProb(target, prob)"},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetProb-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) see slot definition. prob (proportion) see slot definition.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetProb-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) target toxicity interval, e.g. c(0.2, 0.35). prob (proportion) required target toxicity probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/StoppingTargetProb-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"# As example, here is the rule for stopping the study if the posterior # probability that [0.2 =< Prob(DLT | dose) <= 0.35] for the next best dose # is above 0.5. my_stopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)"},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Design class using DLE responses only based on the pseudo DLE model without sample — TDDesign-class","title":"Design class using DLE responses only based on the pseudo DLE model without sample — TDDesign-class","text":"class design based DLE responses using 'LogisticIndepBeta' class model used without samples. addition slots simple RuleDesign, objects class contain:","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Design class using DLE responses only based on the pseudo DLE model without sample — TDDesign-class","text":"model pseudo DLE model used, object class ModelTox stopping stopping rule(s) trial, object class Stopping increments control increments dose levels, object class Increments PLcohortSize rules cohort sizes placebo, planned object class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design class using DLE responses only based on the pseudo DLE model without sample — TDDesign-class","text":"","code":"# nolint start  ##Specified the design to run simulations ##The design comprises a model, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and no DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3)  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                    data=data,startingDose=25)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'TDDesign' class — TDDesign","title":"Initialization function for 'TDDesign' class — TDDesign","text":"Initialization function 'TDDesign' class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'TDDesign' class — TDDesign","text":"","code":"TDDesign(model, stopping, increments, PLcohortSize = CohortSizeConst(0L), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'TDDesign' class — TDDesign","text":"model please refer TDDesign class object stopping please refer TDDesign class object increments please refer TDDesign class object PLcohortSize see TDDesign ... additional arguments RuleDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'TDDesign' class — TDDesign","text":"TDDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model\nand DLE samples are also used.\nIn addition to the slots in the more simple RuleDesign,\nobjects of this class contain: — TDsamplesDesign-class","title":"This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model\nand DLE samples are also used.\nIn addition to the slots in the more simple RuleDesign,\nobjects of this class contain: — TDsamplesDesign-class","text":"class design based DLE responses using 'LogisticIndepBeta' class model DLE samples also used. addition slots simple RuleDesign, objects class contain:","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model\nand DLE samples are also used.\nIn addition to the slots in the more simple RuleDesign,\nobjects of this class contain: — TDsamplesDesign-class","text":"model pseudo DLE model used, object class ModelTox stopping stopping rule(s) trial, object class Stopping increments control increments dose levels, object class Increments PLcohortSize rules cohort sizes placebo, planned object class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a class of design based only on DLE responses using the 'LogisticIndepBeta' class model\nand DLE samples are also used.\nIn addition to the slots in the more simple RuleDesign,\nobjects of this class contain: — TDsamplesDesign-class","text":"","code":"# nolint start  ##Specified the design to run simulations ##The design comprises a model, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  samples <- mcmc(data=data, model=model, options=McmcOptions(burnin=100,step=2,samples=200))  ##Then the escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25 design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for 'TDsamplesDesign' class — TDsamplesDesign","title":"Initialization function for 'TDsamplesDesign' class — TDsamplesDesign","text":"Initialization function 'TDsamplesDesign' class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for 'TDsamplesDesign' class — TDsamplesDesign","text":"","code":"TDsamplesDesign(   model,   stopping,   increments,   PLcohortSize = CohortSizeConst(0L),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for 'TDsamplesDesign' class — TDsamplesDesign","text":"model see TDsamplesDesign stopping see TDsamplesDesign increments see TDsamplesDesign PLcohortSize see TDsamplesDesign ... additional arguments RuleDesign","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TDsamplesDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for 'TDsamplesDesign' class — TDsamplesDesign","text":"TDsamplesDesign class object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TITELogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TITELogisticLogNormal — TITELogisticLogNormal-class","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"TITELogisticLogNormal class TITE-CRM based logistic regression model using bivariate normal prior intercept log slope parameters. class inherits LogisticLogNormal.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TITELogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"TITELogisticLogNormal(weight_method = \"linear\", ...)"},{"path":"https://roche.github.io/crmPack/main/reference/TITELogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/TITELogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/TITELogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"my_model <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"linear\" )  my_model1 <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"adaptive\" )"},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"Creates new 3+3 design object dose grid","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"","code":"ThreePlusThreeDesign(doseGrid)"},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"doseGrid dose grid used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"object class RuleDesign 3+3 design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ThreePlusThreeDesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a new 3+3 design object from a dose grid — ThreePlusThreeDesign","text":"","code":"# inizialing a 3+3 design  myDesign <- ThreePlusThreeDesign(doseGrid=c(5, 10, 15, 25, 35, 50, 80))"},{"path":"https://roche.github.io/crmPack/main/reference/Validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate — Validate","title":"Validate — Validate","text":"Validate class Reference Class help programming validation new S4 classes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate — Validate","text":"Starting empty msg vector, check returning FALSE vector gets new element - string explaining failure validation.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Validate.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Validate — Validate","text":"msg (character) cumulative messages.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/Validate.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Validate — Validate","text":"check(test, string = \"\") Check whether test TRUE; , return NULL. Otherwise, add string message cumulative messages vector msg. result() Return either cumulative messages vector msg (contains error messages checks), NULL, msg empty (.e. checks successful).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"method combining two atomic stopping rules","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"# S4 method for Stopping,Stopping &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"## Example of combining two atomic stopping rules with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping <- myStopping1 & myStopping2"},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-StoppingAll-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"method combining atomic stopping list","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-StoppingAll-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"# S4 method for Stopping,StoppingAll &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-StoppingAll-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"e1 Stopping object e2 StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-StoppingAll-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"modified StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-Stopping-StoppingAll-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <-  myStopping3 & (myStopping1 | myStopping2 )"},{"path":"https://roche.github.io/crmPack/main/reference/and-StoppingAll-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"method combining stopping list atomic","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-StoppingAll-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"# S4 method for StoppingAll,Stopping &amp;(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/and-StoppingAll-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"e1 StoppingAll object e2 Stopping object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-StoppingAll-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"modified StoppingAll object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/and-StoppingAll-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 | myStopping2 ) & myStopping3"},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate posterior with (log) normal distribution — approximate","title":"Approximate posterior with (log) normal distribution — approximate","text":"recommended use set.seed , order able reproduce resulting approximating model exactly.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"approximate(object, model, data, ...)  # S4 method for Samples approximate(   object,   model,   data,   points = seq(from = min(data@doseGrid), to = max(data@doseGrid), length = 5L),   refDose = median(points),   logNormal = FALSE,   verbose = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate posterior with (log) normal distribution — approximate","text":"object Samples object model GeneralModel object data Data object ... additional arguments (see methods) points optional parameter, gives dose values approximation rely (default: 5 values equally spaced minimum maximum dose grid) refDose reference dose used (default: median points) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used verbose verbose (progress statements plot)? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate posterior with (log) normal distribution — approximate","text":"approximation model","code":""},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Approximate posterior with (log) normal distribution — approximate","text":"approximate(Samples): ... argument can transport additional arguments Quantiles2LogisticNormal, e.g. order control approximation quality, etc.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/approximate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Approximate the posterior distribution with a bivariate normal # max.time and maxit are very small only for the purpose of showing the example. They  # should be increased for a real case. set.seed(94) posterior <- approximate(object = samples,                          model = model,                          data = data,                          logNormal=TRUE,                          control = list(threshold.stop = 0.1,                                         max.time = 1,                                         maxit = 1))   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/assertions.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional Assertions for checkmate — assertions","title":"Additional Assertions for checkmate — assertions","text":"provide additional assertion functions can used together checkmate functions. described individual help pages linked .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/assertions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional Assertions for checkmate — assertions","text":"Depending function prefix. assert_ functions return object invisibly successful, otherwise throw error message. check_ functions return TRUE successful, otherwise string error message. test_ functions just return TRUE FALSE.","code":""},{"path":[]},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"biomarker(xLevel, model, samples, ...)  # S4 method for integer,DualEndpoint,Samples biomarker(xLevel, model, samples, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"xLevel (integer) levels doses patients given w.r.t dose grid. See Data details. model (DualEndpoint) model. samples (Samples) samples model's parameters store value biomarker levels doses dose grid. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker levels.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"function simply returns specific columns (indices equal xLevel) biomarker samples matrix, included samples object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker(xLevel = integer, model = DualEndpoint, samples = Samples):","code":""},{"path":"https://roche.github.io/crmPack/main/reference/biomarker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"# Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(1L, 2L, 3L, 4L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L),   w = c(     0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6, 0.52, 0.54,     0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 500 ) my_samples <- mcmc(my_data, my_model, my_options)  # Obtain the biomarker levels (samples) for the second dose from the dose grid, # which is 0.5. biomarker(   xLevel = 2L,   model = my_model,   samples = my_samples ) #>   [1] 0.4744253 0.5336028 0.4994221 0.4774579 0.4283865 0.4496548 0.4856586 #>   [8] 0.4806701 0.5559312 0.4785456 0.3343232 0.4918587 0.5144552 0.5587353 #>  [15] 0.5629420 0.4846505 0.4162423 0.4054259 0.5506604 0.4199561 0.4999374 #>  [22] 0.5151278 0.5135610 0.4797593 0.5223675 0.5342320 0.4615869 0.4361408 #>  [29] 0.3962743 0.3944166 0.3629657 0.4159575 0.4528658 0.4749158 0.4786238 #>  [36] 0.3930679 0.2684473 0.3101835 0.3549875 0.3416461 0.3193655 0.2746795 #>  [43] 0.2426086 0.1539910 0.2343500 0.3687986 0.3169905 0.2415800 0.2790160 #>  [50] 0.4091709 0.3650563 0.2969469 0.3346420 0.4093306 0.4008673 0.4773953 #>  [57] 0.5062619 0.5280829 0.4332057 0.3696746 0.4377967 0.3428914 0.3775724 #>  [64] 0.2991334 0.3978964 0.4684684 0.3551491 0.4029050 0.5018663 0.5176535 #>  [71] 0.5080524 0.4822987 0.4450687 0.4795981 0.4326122 0.4633039 0.5271592 #>  [78] 0.5121077 0.4339593 0.4846184 0.4808545 0.4882949 0.4567012 0.3306336 #>  [85] 0.3526940 0.3160598 0.4123525 0.3676334 0.2711569 0.1959490 0.2412763 #>  [92] 0.1527027 0.1113395 0.2399144 0.2994824 0.2382471 0.2921630 0.3484807 #>  [99] 0.3595584 0.3702571 0.4294700 0.3854652 0.5201244 0.3537298 0.4019385 #> [106] 0.3901634 0.3862875 0.3645383 0.3730064 0.4071300 0.4071030 0.3956522 #> [113] 0.3645451 0.4418185 0.5191758 0.5521732 0.4769758 0.5021577 0.5126513 #> [120] 0.5447026 0.6281469 0.5789371 0.4264295 0.5561971 0.5560444 0.4622581 #> [127] 0.3128123 0.2381830 0.3816000 0.4255432 0.3589696 0.3579796 0.3332295 #> [134] 0.2772762 0.2561791 0.3620626 0.4143511 0.4574743 0.4644538 0.5419991 #> [141] 0.4247204 0.5038797 0.3940690 0.2989853 0.2587642 0.2911117 0.3378677 #> [148] 0.4930590 0.5174604 0.5445586 0.4982197 0.5035711 0.4780655 0.4046799 #> [155] 0.1967657 0.2570097 0.3210769 0.2865516 0.3613042 0.4294187 0.4872894 #> [162] 0.4467669 0.4752401 0.4694344 0.4956814 0.4614450 0.4645918 0.3591754 #> [169] 0.3248432 0.3343448 0.3303009 0.3495345 0.4399383 0.3654238 0.2867778 #> [176] 0.4996557 0.5054017 0.3971563 0.4371577 0.5097871 0.5615365 0.5421581 #> [183] 0.5722693 0.4634534 0.3883254 0.2606444 0.3130147 0.3175924 0.3919232 #> [190] 0.4494960 0.4613006 0.4095389 0.4402353 0.4230291 0.3650949 0.4399640 #> [197] 0.3850456 0.4593856 0.4117610 0.4923489 0.4058206 0.4982573 0.3336403 #> [204] 0.3789735 0.4246688 0.4767430 0.4538727 0.4439913 0.3703212 0.2810785 #> [211] 0.3463441 0.4420346 0.5191975 0.3951287 0.4523759 0.4110818 0.4585164 #> [218] 0.4082385 0.4076993 0.4661897 0.5376773 0.3846682 0.3387264 0.3140839 #> [225] 0.2803113 0.3356651 0.4478781 0.4514240 0.4901169 0.4755455 0.4091770 #> [232] 0.5089148 0.4206731 0.3548420 0.3957311 0.4424549 0.3838424 0.3852780 #> [239] 0.4233047 0.4188146 0.4775118 0.4054635 0.4216462 0.3213937 0.4260336 #> [246] 0.4118431 0.4955622 0.4754350 0.3688356 0.3297656 0.3398266 0.4648902 #> [253] 0.4767326 0.4532896 0.5471984 0.5423492 0.4719091 0.4449990 0.4921454 #> [260] 0.4303315 0.5053932 0.4899798 0.4791497 0.5020099 0.5283703 0.4702636 #> [267] 0.4820805 0.4833213 0.5054488 0.3687419 0.3670123 0.3338654 0.3594345 #> [274] 0.3630284 0.4004855 0.3399571 0.3803471 0.4385208 0.3868691 0.4470375 #> [281] 0.4452678 0.4047496 0.5036504 0.5370006 0.4612188 0.6027583 0.4469685 #> [288] 0.4639952 0.3947280 0.2570555 0.3276241 0.3469990 0.3447696 0.4034697 #> [295] 0.3581507 0.4085140 0.3974927 0.4002995 0.3373366 0.3233367 0.3211885 #> [302] 0.3689837 0.4053326 0.3811828 0.3892841 0.4233618 0.4160227 0.3253079 #> [309] 0.3309402 0.3905057 0.4141655 0.4378269 0.2954318 0.3972450 0.3441413 #> [316] 0.3275224 0.4144762 0.3909432 0.3414643 0.2376838 0.2999451 0.4078663 #> [323] 0.3879259 0.4447675 0.4457199 0.5314222 0.5216830 0.4850345 0.5357053 #> [330] 0.4965191 0.4478521 0.5693333 0.4879248 0.4936486 0.5655122 0.5657154 #> [337] 0.4678493 0.3584870 0.3965160 0.3162875 0.3007697 0.3874578 0.3792887 #> [344] 0.4082345 0.4405382 0.4551997 0.4233223 0.4449468 0.4965295 0.5294008 #> [351] 0.5040423 0.4654395 0.4905852 0.4428297 0.5314663 0.4963476 0.4626560 #> [358] 0.4855195 0.4044457 0.3322461 0.3437278 0.3826959 0.3819099 0.4242274 #> [365] 0.5743362 0.5686572 0.4648790 0.5095770 0.4438859 0.3525618 0.3251516 #> [372] 0.4251361 0.4124183 0.3832952 0.4595976 0.5169111 0.5732210 0.5535096 #> [379] 0.4490863 0.4834424 0.5796030 0.5166879 0.4255063 0.5367911 0.6815779 #> [386] 0.5758858 0.5393441 0.3499941 0.3212333 0.2665642 0.3673614 0.3130961 #> [393] 0.3421086 0.3552124 0.3761839 0.4173636 0.5240442 0.6291681 0.4440378 #> [400] 0.4690656 0.4639665 0.4977231 0.5887365 0.5953261 0.5146475 0.5434057 #> [407] 0.5206227 0.5588010 0.6123999 0.6155998 0.5868062 0.4330710 0.3221813 #> [414] 0.2857946 0.3849895 0.3908387 0.3891427 0.3539628 0.3537740 0.3068550 #> [421] 0.3218380 0.3417878 0.3948854 0.4422701 0.5172234 0.4802057 0.4535157 #> [428] 0.4407192 0.4197793 0.3899521 0.3730932 0.3389409 0.4765546 0.5388778 #> [435] 0.6011014 0.6254597 0.6281414 0.4754604 0.4462123 0.4946238 0.5104654 #> [442] 0.4055849 0.4428850 0.4388007 0.5173626 0.5758072 0.4908108 0.4691270 #> [449] 0.5029098 0.5166422 0.4841820 0.5439563 0.4948350 0.3982853 0.5250162 #> [456] 0.6269930 0.6637342 0.4746607 0.3475975 0.3052749 0.3578466 0.4162688 #> [463] 0.4140464 0.5147759 0.4064557 0.5267760 0.5547773 0.5171549 0.5934014 #> [470] 0.6079341 0.4952799 0.3861047 0.3877829 0.5230239 0.4980797 0.3753793 #> [477] 0.2842786 0.3247726 0.3305626 0.3610989 0.4224936 0.4820477 0.4280641 #> [484] 0.5141259 0.4876756 0.4547695 0.4752349 0.4887177 0.4486234 0.5565775 #> [491] 0.5088247 0.5097013 0.4913993 0.3688381 0.3828927 0.4129855 0.4690746 #> [498] 0.3949517 0.3533481 0.3388971"},{"path":"https://roche.github.io/crmPack/main/reference/check_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if vectors are of compatible lengths — check_length","title":"Check if vectors are of compatible lengths — check_length","text":"Two vectors compatible size : least one vector size 1 vectors size.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(x, len)  assert_length(x, len, .var.name = checkmate::vname(x), add = NULL)  test_length(x, len)"},{"path":"https://roche.github.io/crmPack/main/reference/check_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if vectors are of compatible lengths — check_length","text":"x () first vector, object length() function defined. len (count) length second vector. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if vectors are of compatible lengths — check_length","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/check_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(1:5, 1) #> [1] TRUE check_length(1:5, 6) #> [1] \"x is of length 5 which is not allowed; the allowed lengths are: 1 or 6\" check_length(1:5, 5) #> [1] TRUE check_length(10, 1) #> [1] TRUE check_length(10, 9) #> [1] TRUE"},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability vector — check_probabilities","title":"Check if an argument is a probability vector — check_probabilities","text":"Check every element given numerical vector matrix represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"check_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  assert_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   .var.name = checkmate::vname(x),   add = NULL )  test_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  expect_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability vector — check_probabilities","text":"x (numeric) vector matrix numerical values check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . len [integer(1)] Exact expected length x. unique [logical(1)] Must values unique? Default FALSE. sorted [logical(1)] Elements must sorted ascending order. Missing values ignored. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability vector — check_probabilities","text":"TRUE successful, otherwise string error message.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if an argument is a probability vector — check_probabilities","text":"missing non-finite values x, functions returns FALSE, regardless values elements x.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/check_probabilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"x <- c(0, 0.2, 0.1, 0.3, 1) check_probabilities(x) #> [1] TRUE check_probabilities(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probabilities(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a single probability value — check_probability","title":"Check if an argument is a single probability value — check_probability","text":"Check given value represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(x, bounds_closed = TRUE)  assert_probability(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability(x, bounds_closed = TRUE)  expect_probability(x, bounds_closed = TRUE, info = NULL, label = vname(x))"},{"path":"https://roche.github.io/crmPack/main/reference/check_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a single probability value — check_probability","text":"x (number) single value check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a single probability value — check_probability","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/check_probability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(0.5) #> [1] TRUE check_probability(0, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability(0, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability range — check_probability_range","title":"Check if an argument is a probability range — check_probability_range","text":"Check given numerical interval represents probability range, sub-interval (0, 1) interval, can optionally closed side.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"check_probability_range(x, bounds_closed = TRUE)  assert_probability_range(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability_range(x, bounds_closed = TRUE)  expect_probability_range(   x,   bounds_closed = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/main/reference/check_probability_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability range — check_probability_range","text":"x (number) interval check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_probability_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability range — check_probability_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/check_probability_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"x <- c(0, 0.2) check_probability_range(x) #> [1] TRUE check_probability_range(rev(x)) #> [1] \"Must be sorted\" check_probability_range(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability_range(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://roche.github.io/crmPack/main/reference/check_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a numerical range — check_range","title":"Check that an argument is a numerical range — check_range","text":"argument x numerical range (conditions must met): object type: integer double. vector length two value first number less second number. Equalness allowed unique flag set TRUE. Lower bound interval greater equal lower upper bound interval less equal upper. contains finite (given finite TRUE) non-missing values.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  assert_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  expect_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://roche.github.io/crmPack/main/reference/check_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a numerical range — check_range","text":"x [] Object check. lower [numeric(1)] Lower value elements x must greater equal . upper [numeric(1)] Upper value elements x must lower equal . finite [logical(1)] Check finite values? Default FALSE. unique [logical(1)] Must values unique? Default FALSE. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/check_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a numerical range — check_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/check_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(c(1, 5)) #> [1] TRUE check_range(c(-5, 1)) #> [1] TRUE check_range(c(4, 1)) #> [1] \"x must be a valid numerical range. Must be sorted\" check_range(c(1, 1)) #> [1] \"x must be a valid numerical range. Contains duplicated values, position 2\" check_range(c(1, 1), unique = FALSE) #> [1] TRUE check_range(1:3) #> [1] \"x must be a valid numerical range. Must have length 2, but has length 3\""},{"path":"https://roche.github.io/crmPack/main/reference/crmPack-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-oriented implementation of CRM designs — crmPack-package","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Object-oriented implementation CRM designs","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPack-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Sabanes Bove D, Yeung WY, Palermo G, Jaki T (2019). \"Model-Based Dose Escalation Designs R crmPack.\" Journal Statistical Software, 89(10), 1-22. doi:10.18637/jss.v089.i10 (URL: http://doi.org/10.18637/jss.v089.i10).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPack-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Object-oriented implementation of CRM designs — crmPack-package","text":"Daniel Sabanes Bove daniel.sabanesbove@gmx.net, W Wai Yin Yeung winnie.yeung@roche.com Giuseppe Palermo giuseppe.palermo@roche.com, Thomas Jaki jaki.thomas@gmail.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackExample.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the example pdf for crmPack — crmPackExample","title":"Open the example pdf for crmPack — crmPackExample","text":"Calling helper function open example.pdf document, residing doc subfolder package installation directory.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackExample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the example pdf for crmPack — crmPackExample","text":"","code":"crmPackExample()"},{"path":"https://roche.github.io/crmPack/main/reference/crmPackExample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the example pdf for crmPack — crmPackExample","text":"nothing","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackExample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the example pdf for crmPack — crmPackExample","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackHelp.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the browser with help pages for crmPack — crmPackHelp","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"convenience function opens browser help pages crmPack.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackHelp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"","code":"crmPackHelp()"},{"path":"https://roche.github.io/crmPack/main/reference/crmPackHelp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"nothing","code":""},{"path":"https://roche.github.io/crmPack/main/reference/crmPackHelp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function to Subsets of Data Frame. — dapply","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"dapply splits data df subsets defined f, applies function FUN subset. results row-binded returned data.frame object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"dapply(df, f, FUN, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/dapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"df (data frame) data set divided groups. f (factor formula list) factor sense .factor(f) defines grouping, list factors case interaction used grouping. f can also formula form ~ g1 + ... + gk split interaction variables g1, ..., gk. parameter passed directly split() function. FUN (function) function applied subset df defined f. ... parameters passed lapply(), used applying function FUN groups defined f.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"data.frame object results FUN.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"df <- data.frame(   dose = c(0.1, 6, 6, 5, 0.1, 5, 6, 6),   cohort = c(\"B\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\") )  dapply(   df,   f = ~cohort,   FUN = function(coh) {     data.frame(my_cohort = coh$cohort[1], my_max = max(coh$dose))   } ) #>   my_cohort my_max #> 1         A      5 #> 2         B      6  dapply(   df,   f = ~cohort,   FUN = function(coh) {     coh$dose <- sort(coh$dose, decreasing = TRUE)     coh   } ) #>   dose cohort #> 1  5.0      A #> 2  5.0      A #> 3  0.1      A #> 4  6.0      B #> 5  6.0      B #> 6  6.0      B #> 7  6.0      B #> 8  0.1      B"},{"path":"https://roche.github.io/crmPack/main/reference/dinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the density of Inverse gamma distribution — dinvGamma","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"Compute density Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"","code":"dinvGamma(x, a, b, log = FALSE, normalize = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/dinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"x vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution log logical; TRUE, probabilities p given log(p) normalize logical; TRUE, output normalized","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing the Doses for a given independent variable, Model and Samples — dose","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"function computes dose reaching specific target value given variable dose depends . meaning variable depends type model. instance, single agent dose escalation model pseudo DLE (dose-limiting events)/toxicity model, variable represents probability occurrence DLE. efficacy models, represents expected efficacy. doses computed based samples model parameters (samples).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"dose(x, model, samples, ...)  # S4 method for numeric,LogisticNormal,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormal,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormalSub,Samples dose(x, model, samples)  # S4 method for numeric,ProbitLogNormal,Samples dose(x, model, samples)  # S4 method for numeric,ProbitLogNormalRel,Samples dose(x, model, samples)  # S4 method for numeric,LogisticKadane,Samples dose(x, model, samples)  # S4 method for numeric,LogisticKadaneBetaGamma,Samples dose(x, model, samples)  # S4 method for numeric,LogisticNormalMixture,Samples dose(x, model, samples)  # S4 method for numeric,LogisticNormalFixedMixture,Samples dose(x, model, samples)  # S4 method for numeric,LogisticLogNormalMixture,Samples dose(x, model, samples)  # S4 method for numeric,DualEndpoint,Samples dose(x, model, samples)  # S4 method for numeric,LogisticIndepBeta,Samples dose(x, model, samples)  # S4 method for numeric,LogisticIndepBeta,missing dose(x, model)  # S4 method for numeric,Effloglog,missing dose(x, model)  # S4 method for numeric,EffFlexi,Samples dose(x, model, samples)  # S4 method for numeric,OneParLogNormalPrior,Samples dose(x, model, samples)  # S4 method for numeric,OneParExpPrior,Samples dose(x, model, samples)"},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"x (proportion numeric) value independent variable dose depends. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, x must size sample. model (GeneralModel ModelPseudo) model. samples (Samples) samples model's parameters used compute resulting doses. Can also missing models. ... model specific parameters samples used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"number numeric vector doses. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length prob.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() function computes doses corresponding value given independent variable, using samples model parameter(s). work multivariate model parameters, assume model specific dose() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose(x = numeric, model = LogisticNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalSub, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormalRel, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticKadane, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticKadaneBetaGamma, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalFixedMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = DualEndpoint, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = Effloglog, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = EffFlexi, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). method x must scalar. dose(x = numeric, model = OneParLogNormalPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x). dose(x = numeric, model = OneParExpPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() prob() methods inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/dose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = my_model, samples = my_samples) #>  [1] 23.65451 23.65451 23.65451 23.65451 51.94636 45.49342 86.30145 86.30145 #>  [9] 86.30145 49.81079 49.81079 49.81079 49.81079 49.81079 12.23630 12.23630 #> [17] 12.23630 12.23630 92.53088 92.53088  # Create data from the 'Data' (or 'DataDual') class. dlt_data <- Data(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = dlt_data )  # Get samples from posterior. dlt_sample <- mcmc(data = dlt_data, model = dlt_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = dlt_model, samples = dlt_sample) #>  [1]     10.07613     10.07613     22.15191 850756.88704     48.50700 #>  [6]     48.50700     48.50700     72.06078     72.06078     72.06078 #> [11]   2590.71936    155.17055    155.17055    155.17055    212.47066 #> [16]    156.91934    234.83714    234.83714    196.82793     90.86247 dose(x = c(0.45, 0.6), model = dlt_model) #> [1] 144.6624 247.7348"},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Function for a Given Model Type — doseFunction","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"function returns dose() method computes dose reaching specific target value given independent variable, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"doseFunction(model, ...)  # S4 method for GeneralModel doseFunction(model, ...)  # S4 method for ModelPseudo doseFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"model (GeneralModel ModelPseudo) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"dose() method computes doses.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"doseFunction(GeneralModel): doseFunction(ModelPseudo):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/doseFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  dose_fun <- doseFunction(my_model, alpha0 = 2, alpha1 = 3) dose_fun(0.6) #> [1] 29.38579"},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"function computes value expected efficacy specified dose level, based model specific parameters. model parameters (samples) obtained based prior specified form pseudo data combined observed responses ().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"efficacy(dose, model, samples, ...)  # S4 method for numeric,Effloglog,Samples efficacy(dose, model, samples)  # S4 method for numeric,Effloglog,missing efficacy(dose, model)  # S4 method for numeric,EffFlexi,Samples efficacy(dose, model, samples)"},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"dose (numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (ModelEff) efficacy model pseudo data prior. samples (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... model specific parameters samples used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"numeric vector values expected efficacy. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy() function computes expected efficacy given doses, using samples model parameter(s). work multivariate model parameters, assume model specific efficacy() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy(dose = numeric, model = Effloglog, samples = Samples): compute expected efficacy specified dose level, based samples Effloglog model parameters. efficacy(dose = numeric, model = Effloglog, samples = missing): compute expected efficacy specified dose level, based Effloglog model parameters. model parameters (except dose) present model object. efficacy(dose = numeric, model = EffFlexi, samples = Samples): compute expected efficacy specified dose level, based samples EffFlexi model parameters. given dose dose vector outside dose grid range, NA_real returned dose warning thrown.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/efficacy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"# Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (in flexible form for prior) and efficacy samples.  # Empty data (i.e. no observed data), dose grid only. my_data <- DataDual(doseGrid = seq(25, 300, 25))  my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_options <- McmcOptions(   burnin = 100, step = 2, samples = 200, rng_kind = \"Mersenne-Twister\", rng_seed = 94 )  my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Efficacy for dose 75. efficacy(dose = 75, model = my_model, samples = my_samples) #>   [1]   9.07133091   1.53424048  11.07308839   6.74968857  -2.87681905 #>   [6]  -0.52774208   0.98461243   8.07698912  -2.44894407  -5.85523700 #>  [11]  11.31738072  -5.20839309  -3.53568739   1.84098767   2.63215398 #>  [16]   1.08547205  -1.14150225  -1.17196071  -4.07450990   3.83602092 #>  [21]  -1.51766461   9.58344159  12.66103757  -4.07515232   4.55952976 #>  [26]   3.07600733  -0.45143577  12.68867587  -0.79739141  -6.60007580 #>  [31]   6.08270229  -5.09099874   1.30242100  -1.38790974   2.11417328 #>  [36]   8.37133821   1.50986899   6.84880575   5.43897499   2.79542447 #>  [41]  11.45417302   2.06748782   1.35245992  -1.23701296   7.91038987 #>  [46]   6.51728419  -5.90538823   0.50485996   4.46024145  -6.19234053 #>  [51]  -1.03422769  -4.60878828  -7.09786728   6.77762041  -7.80093619 #>  [56]  -0.35335674   0.06016899   5.09042210  -1.08931226  -5.13714299 #>  [61] -11.25227813   6.94417969  -0.18607453   6.70974746   7.07740656 #>  [66]   1.81144127  -1.46201083  -3.59961582   5.98766120  -3.06347907 #>  [71]   1.48952524  -3.87648489   9.53195596  -5.09183042   2.55946664 #>  [76]   5.36514495   3.35805663   4.04528900  -2.47968051   2.38776563 #>  [81]   3.30544598   6.08668755   8.10409159  -2.86897901  -2.56968895 #>  [86]  -2.71078157   6.57400099  -0.64078913  -0.77931969   0.44535965 #>  [91]   2.48733763   1.62006538   5.18380783  15.91917003  14.37031355 #>  [96]  -4.95225083  -0.11454594   3.37173952   4.36757735   9.93988922 #> [101]   0.14708030   0.66970048   2.93648731   6.62081659  -5.72655553 #> [106]   7.32219826   3.85369534  -5.64247557   3.26712563   1.53773741 #> [111]   5.36646375  -2.24826433   1.53796441  -1.47481547   5.66412948 #> [116]  -0.08562487   0.92285513   6.54480180   2.76592451   9.04534245 #> [121]   2.67298217   9.37451070   3.31718865  -4.39655806  -2.77475285 #> [126]   0.73845209  -1.14838485  -0.04538310  13.15372079  -8.24336360 #> [131]   1.00955294   3.84117706   7.63816224   7.15423998  -0.31603848 #> [136]  -5.15339494   4.46319473   0.61902688   1.75161458  -3.48460935 #> [141]   1.03111557   7.35215316  14.50755214   0.45564792  -0.33913496 #> [146]  -1.04517173   8.55653204  -0.33228919   7.57900504   5.90623049 #> [151]   0.95421800   9.08101740   9.43334290  -7.55120809  -2.72471203 #> [156]  -7.35230299   3.70368743   3.84477094   4.16388471  -1.68082994 #> [161]  -1.92123896   2.04731124  -2.26118158   1.72862392  -1.79117652 #> [166]   3.04772415   1.34065202   6.35926350  -1.78732266  -3.18937218 #> [171]  -5.18426934   6.64292813   0.21495831  -5.04417938  -3.64536665 #> [176]   6.97433099   4.69569241  10.84773802  10.07835651   7.98940931 #> [181]  -1.64566370  -6.87224825  -4.75312374  -1.98193506  11.94430550 #> [186]   7.12994070  11.82172904   5.74335173   4.51767170   1.09675636 #> [191]   5.90817166  -1.89174876  -0.15421814   2.06690552   1.63930492 #> [196]   3.77873641   2.64667197   9.84146185   2.29768549  -0.54599122  # Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (linear log-log efficacy) and no samples. my_model_ll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 0 )  efficacy(dose = 75, model = my_model_ll) #> [1] 1.885121"},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"function returns efficacy() function computes expected efficacy given dose level, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"efficacyFunction(model, ...)  # S4 method for ModelEff efficacyFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"model (ModelEff) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacy() function computes expected efficacy.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacyFunction(ModelEff):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/efficacyFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"my_data <- DataDual(   doseGrid = c(0.001, seq(25, 300, 25)),   placebo = TRUE )  my_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 2 )  eff_fun <- efficacyFunction(my_model, theta1 = -4.8, theta2 = 3.7) eff_fun(30) #> [1] -0.2011775"},{"path":"https://roche.github.io/crmPack/main/reference/enable_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Verbose Logging — enable_logging","title":"Verbose Logging — enable_logging","text":"family wrappers selected futile.logger functions control logging mechanism crmPack. crmPack uses futile.logger package logging purposes. messages logged crmPack logged crmPack logger futile.logger::TRACE level. Hence, enabling verbose logging means logging threshold set futile.logger::TRACE crmPack logger, disabling verbose logging means set futile.logger::FATAL.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/enable_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verbose Logging — enable_logging","text":"","code":"enable_logging()  disable_logging()  is_logging_enabled()  log_trace(msg, ..., capture = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/enable_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verbose Logging — enable_logging","text":"msg message log ... Optional arguments populate format string capture Capture print output variables instead interpolate","code":""},{"path":"https://roche.github.io/crmPack/main/reference/enable_logging.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verbose Logging — enable_logging","text":"enable_logging(): simple wrapper futile.logger::flog.threshold() enables crmPack verbose logging setting logging threshold futile.logger::TRACE crmPack logger. disable_logging(): simple wrapper futile.logger::flog.threshold() disables crmPack verbose logging setting logging threshold futile.logger::FATAL crmPack logger. is_logging_enabled(): simple wrapper futile.logger::flog.logger() checks whether current threshold level crmPack logger verbose, futile.logger::TRACE. returns TRUE current logging level verbose, FALSE otherwise. log_trace(): simple wrapper futile.logger::flog.trace() prints log message crmPack logger.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain hypothetical trial course table for a design — examine","title":"Obtain hypothetical trial course table for a design — examine","text":"generic function takes design generates dataframe showing beginning several hypothetical trial courses design. means, generated dataframe one can read : many cohorts required optimal case (DLTs observed) order reach highest dose specified dose grid (stopping rule fulfilled) assuming DLTs observed certain dose level, next recommended dose possible number DLTs observed actual relative increments used cases whether trial stop certain cohort Examining \"single trial\" behavior dose escalation design first important step evaluating design, replaced studying solely operating characteristics \"many trials\". cohort sizes also taken design, assuming DLTs occur dose listed.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"examine(object, ..., maxNoIncrement = 100L)  # S4 method for Design examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)  # S4 method for RuleDesign examine(object, ..., maxNoIncrement = 100L)  # S4 method for DADesign examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)"},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain hypothetical trial course table for a design — examine","text":"object design (Design RuleDesign object) want examine ... additional arguments (see methods) maxNoIncrement maximum number contiguous next doses 0 DLTs , .e. increment (default 100) mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain hypothetical trial course table for a design — examine","text":"data frame","code":""},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtain hypothetical trial course table for a design — examine","text":"examine(Design): Examine model-based CRM examine(RuleDesign): Examine rule-based design examine(DADesign): Examine model-based CRM","code":""},{"path":"https://roche.github.io/crmPack/main/reference/examine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3)  # Examine the design set.seed(4235) # MCMC parameters are set to small values only to show this example. They should be # increased for a real case. options <- McmcOptions(burnin=10,step=1,samples=20) examine(design, options) #> Error in if (doseDiff == 0) {    noIncrementCounter <- noIncrementCounter + 1L} else {    noIncrementCounter <- 0L}: missing value where TRUE/FALSE needed  ## example where examine stops because stopping rule already fulfilled myStopping4 <- StoppingMinPatients(nPatients=3) myStopping <- (myStopping1 & myStopping2) | myStopping4 design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3) examine(design,mcmcOptions=options) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1       NA  TRUE        NA #> 3    5    0       10 FALSE       100 #> 4    5    1       NA  TRUE        NA #> 5   10    0       15  TRUE        50 #> 6   10    1       10  TRUE         0  ## example where examine stops because infinite looping ## (note that here a very low threshold is used for the parameter ## \"maxNoIncrement\" in \"examine\" to keep the execution time short) myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.00001)) myStopping <- (myStopping1 & myStopping2) design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3) examine(design, mcmcOptions=options, maxNoIncrement = 2) #> Warning: Stopping because 2 times no increment vs. previous dose #>    dose DLTs nextDose  stop increment #> 1     3    0        5 FALSE        67 #> 2     3    1        1 FALSE       -67 #> 3     5    0       10 FALSE       100 #> 4     5    1       10 FALSE       100 #> 5    10    0       20 FALSE       100 #> 6    10    1        1 FALSE       -90 #> 7    20    0       20 FALSE         0 #> 8    20    1       15  TRUE       -25 #> 9    20    0       20 FALSE         0 #> 10   20    1       10 FALSE       -50  # nolint end  # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(nextBest = NextBestThreePlusThree(),                        cohortSize = CohortSizeConst(size=3L),                        data = emptydata,                        startingDose = 5)    # Examine the design set.seed(4235) examine(myDesign) #>    dose DLTs nextDose  stop increment #> 1     5    0       10 FALSE       100 #> 2     5    1        5 FALSE         0 #> 3     5    2       NA  TRUE        NA #> 4     5    3       NA  TRUE        NA #> 5    10    0       15 FALSE        50 #> 6    10    1       10 FALSE         0 #> 7    10    2        5 FALSE       -50 #> 8    10    3        5 FALSE       -50 #> 9    15    0       25 FALSE        67 #> 10   15    1       15 FALSE         0 #> 11   15    2       10 FALSE       -33 #> 12   15    3       10 FALSE       -33 #> 13   25    0       35 FALSE        40 #> 14   25    1       25 FALSE         0 #> 15   25    2       15 FALSE       -40 #> 16   25    3       15 FALSE       -40 #> 17   35    0       50 FALSE        43 #> 18   35    1       35 FALSE         0 #> 19   35    2       25 FALSE       -29 #> 20   35    3       25 FALSE       -29 #> 21   50    0       80 FALSE        60 #> 22   50    1       50 FALSE         0 #> 23   50    2       35 FALSE       -30 #> 24   50    3       35 FALSE       -30 # nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(doseGrid=c(0.1, 0.5,1, 1.5, 3, 6,                                seq(from=10, to=80, by=2)),Tmax=60) # Initialize the mDA-CRM model npiece_=10 Tmax_=60  lambda_prior<-function(k){   npiece_/(Tmax_*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2) # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0,20),                                    increments=c(1,0.33)) # Choose the rule for selecting the next dose nextMaxDose <- maxDose(myIncrements,data=emptydata)  myNextBest <- NextBestNCRM(target=c(0.2,0.35),                            overdose=c(0.35,1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping2 <- StoppingMinPatients(nPatients=50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow=SafetyWindowConst(c(6,2),7,7)  # Initialize the design design <- DADesign(model=model,                    increments=myIncrements,                    nextBest=myNextBest,                    stopping=myStopping,                    cohortSize=mySize,                    data=emptydata,                    safetyWindow=mysafetywindow,                    startingDose=3)  set.seed(4235) # MCMC parameters are set to small values only to show this example. They should be # increased for a real case. # This procedure will take a while. options <- McmcOptions(burnin=10,step=1,samples=100) # examine(design, mcmcOptions=options)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit method for the Samples class — fit","title":"Fit method for the Samples class — fit","text":"Note new generic function necessary fitted function allows first argument object appear signature. need also arguments signature.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit method for the Samples class — fit","text":"","code":"fit(object, model, data, ...)  # S4 method for Samples,GeneralModel,Data fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,DualEndpoint,DataDual fit(object, model, data, quantiles = c(0.025, 0.975), middle = mean, ...)  # S4 method for Samples,LogisticIndepBeta,Data fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,Effloglog,DataDual fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for Samples,EffFlexi,DataDual fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit method for the Samples class — fit","text":"object Samples object model GeneralModel object data Data object ... unused points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit method for the Samples class — fit","text":"data frame required information (see method details)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit method for the Samples class — fit","text":"fit(object = Samples, model = GeneralModel, data = Data): method returns data frame dose, middle, lower upper quantiles dose-toxicity curve fit(object = Samples, model = DualEndpoint, data = DataDual): method returns data frame dose, middle, lower upper quantiles, dose-tox dose-biomarker (suffix \"Biomarker\") curves, grid points (Note currently grid points can used, DualEndpointRW models allow ) fit(object = Samples, model = LogisticIndepBeta, data = Data): method return data frame dose, middle lower upper quantiles dose-DLE curve using DLE samples “LogisticIndepBeta” model class fit(object = Samples, model = Effloglog, data = DataDual): method returns data frame dose, middle, lower, upper quantiles dose-efficacy curve using efficacy samples “Effloglog” model class fit(object = Samples, model = EffFlexi, data = DataDual): method returns data frame dose, middle, lower upper quantiles dose-efficacy curve using efficacy samples “EffFlexi” model class","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit method for the Samples class — fit","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses fitted <- fit(object = samples,               model = model,               data = data,               quantiles=c(0.025, 0.975),               middle=mean)   # ---------------------------------------------- # A different example using a different model ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!   model <- LogisticIndepBeta(binDLE=c(1.05,1.8),                            DLEweights=c(3,3),                            DLEdose=c(25,300),                            data=data) options <- McmcOptions(burnin=100,                        step=2,                        samples=200) ## samples must be from 'Samples' class (object slot in fit) samples <- mcmc(data,model,options)  fitted <- fit(object=samples, model=model, data=data)  # nolint end # nolint start  # Create some data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses fitted <- fit(object = samples,               model = model,               data = data,               quantiles=c(0.025, 0.975),               middle=mean)  # nolint end ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-DLE curve ## at all dose levels using a DLE sample, a DLE model and the data ## samples must be from 'Samples' class (object slot) ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'Model' or 'ModelTox' class e.g using 'LogisticIbdepBeta' model class model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ## samples must be from 'Samples' class (object slot in fit) samples<-mcmc(data,model,options)  fit(object=samples, model=model,data=data) #>    dose    middle      lower     upper #> 1    25 0.2362155 0.08981218 0.4190492 #> 2    50 0.3682220 0.20111117 0.5781557 #> 3    75 0.4575540 0.27620943 0.6661194 #> 4   100 0.5223768 0.33161940 0.7239995 #> 5   125 0.5717475 0.37825701 0.7709958 #> 6   150 0.6107229 0.40917199 0.8141918 #> 7   175 0.6423542 0.42871110 0.8437866 #> 8   200 0.6685943 0.44575657 0.8651832 #> 9   225 0.6907535 0.46059389 0.8819519 #> 10  250 0.7097445 0.47392655 0.8953912 #> 11  275 0.7262234 0.48877922 0.9063659 #> 12  300 0.7406746 0.51041966 0.9148683 ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, a pseudo efficacy model and the data ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel<-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0) ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) Effsamples <- mcmc(data=data,model=Effmodel,options=options) fit(object=Effsamples, model=Effmodel,data=data) #>    dose   middle      lower    upper #> 1    25 0.465844 -0.1165332 1.007491 #> 2    50 0.822886  0.3886473 1.180275 #> 3    75 1.003435  0.5768330 1.403713 #> 4   100 1.121531  0.6228397 1.630016 #> 5   125 1.208159  0.6601782 1.787815 #> 6   150 1.276017  0.6894266 1.902756 #> 7   175 1.331491  0.7064292 2.018253 #> 8   200 1.378223  0.6925712 2.105017 #> 9   225 1.418476  0.6806345 2.173231 #> 10  250 1.453748  0.6701746 2.233005 #> 11  275 1.485081  0.6687583 2.286102 #> 12  300 1.513225  0.6801521 2.333796 # nolint start  ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, the 'EffFlexi' efficacy model and the data ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)  ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) Effsamples <- mcmc(data=data,model=Effmodel,options=options) fit(object=Effsamples, model=Effmodel,data=data) #>    dose    middle      lower     upper #> 1    25 0.7036011  0.6866660 0.7158120 #> 2    50 0.4494999  0.4100730 0.5051847 #> 3    75 0.5795760  0.5125865 0.6297975 #> 4   100 0.6321164 -1.3094061 2.4041159 #> 5   125 0.5879013 -1.3602565 2.2919075 #> 6   150 0.5246635  0.5162698 0.5419775 #> 7   175 0.6355070 -1.7183340 3.1674019 #> 8   200 0.8103666 -3.1066777 5.2791132 #> 9   225 1.0235281 -4.1707667 5.8087216 #> 10  250 1.4342934 -4.1558082 6.0408674 #> 11  275 1.9401852 -1.9698781 5.1282467 #> 12  300 2.5119573  2.5075891 2.5129950  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/fitGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"Get fitted values gain values dose levels based given pseudo DLE model, DLE sample, pseudo efficacy model, Efficacy sample data. method returns data frame dose, middle, lower upper quantiles gain value samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"","code":"fitGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples,DataDual fitGain(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/fitGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"DLEmodel DLE pseudo model ModelTox class object DLEsamples DLE samples Samples class object Effmodel efficacy pseudo model ModelEff class object Effsamples efficacy samples Samples class object data data input DataDual class object ... additional arguments methods points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"fitGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples,   data = DataDual ): method returns data frame dose, middle, lower, upper quantiles gain values obtained given DLE efficacy samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted values for the gain values at all dose levels based on\na given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample\nand data. This method returns a data frame with dose, middle, lower and upper quantiles\nof the gain value samples — fitGain","text":"","code":"##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values ## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and ## a efficacy sample ## data must be from 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),                y=c(0,0,0,0,0,1,1,0),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),                placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model Effmodel<-Effloglog(c(1.223,2.513),c(25,300),nu=c(a=1,b=0.025),data=data,c=0) ## samples must be from 'Samples' class (object slot in fit) options<-McmcOptions(burnin=100,step=2,samples=200) ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) Effsamples <- mcmc(data=data,model=Effmodel,options=options)  fitGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,         Effmodel=Effmodel, Effsamples=Effsamples,data=data) #>    dose    middle      lower     upper #> 1    25 0.3438477 -0.1699007 0.8544627 #> 2    50 0.5987149  0.2547977 0.9663746 #> 3    75 0.6767000  0.3040261 1.0822600 #> 4   100 0.7013123  0.2964078 1.1623733 #> 5   125 0.7042382  0.2695312 1.2074615 #> 6   150 0.6972572  0.2438631 1.2303285 #> 7   175 0.6855757  0.2240500 1.2498266 #> 8   200 0.6717347  0.2064641 1.2612999 #> 9   225 0.6570509  0.1851396 1.2673728 #> 10  250 0.6422299  0.1680738 1.2696973 #> 11  275 0.6276542  0.1555099 1.2693313 #> 12  300 0.6135277  0.1446233 1.2668871"},{"path":"https://roche.github.io/crmPack/main/reference/fitPEM.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"Get fitted DLT free survival (piecewise exponential model). function returns data frame dose, middle, lower upper quantiles PEM curve. hazard=TRUE,","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitPEM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )  # S4 method for Samples,DALogisticLogNormal,DataDA fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/fitPEM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"object mcmc samples model mDA-CRM model data data input, DataDA class object quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean hazard hazard time plotted based PEM? (default) Otherwise ... ... additional arguments methods","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitPEM.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"fitPEM(object = Samples, model = DALogisticLogNormal, data = DataDA): method works DALogisticLogNormal model class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/fitPEM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted DLT free survival (piecewise exponential model).\nThis function returns a data frame with dose, middle, lower and upper\nquantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"# nolint start  # Create the data data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=c(0,15,30,40,55,70,75,85),                Tmax=60) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior<-function(k){   npiece_/(data@Tmax*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)  #Obtain the posterior  options <- McmcOptions(burnin=10,                        step=2,                        samples=1e2)  set.seed(94) samples <- mcmc (data,model,options)   # Extract the posterior mean hazard (and empirical 2.5 and 97.5 percentile) # for the piecewise exponential model # If hazard=FALSE, the posterior PEM will be plot fitted  <- fitPEM(object = samples,                   model = model,                   data=data,                   quantiles=c(0.025,0.975),                   middle=mean,                   hazard=TRUE)  # nolint end"},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"","code":"gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for numeric,ModelTox,Samples,ModelEff,Samples gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for numeric,ModelTox,missing,Effloglog,missing gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample. Otherwise, dose must size sample. model_dle (ModelTox) pseudo DLE (dose-limiting events)/toxicity model. samples_dle (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. model_eff (ModelEff) efficacy model pseudo data prior. samples_eff (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"gain values.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"function computes gain values given dose level, pseudo DLE Efficacy models well given DLE Efficacy samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = Samples,   model_eff = ModelEff,   samples_eff = Samples ): gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = missing,   model_eff = Effloglog,   samples_eff = missing ): Compute gain value given dose level, pseudo DLE Efficacy models without DLE Efficacy samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/gain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and\nUsing Optional Samples. — gain","text":"","code":"# Obtain the gain value for a given dose, a pseudo DLE and efficacy models # as well as DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  samples_dle <- mcmc(emptydata, model_dle, mcmc_opts)  # Efficacy model (Effloglog) and samples. model_effloglog <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  samples_effloglog <- mcmc(emptydata, model_effloglog, mcmc_opts)  # Gain values for dose level 75 and Effloglog efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effloglog,   samples_eff = samples_effloglog ) #>   [1] 0.6408328 0.9328737 1.3317937 0.9755601 1.5632863 0.6305203 0.9138837 #>   [8] 1.3243097 1.6300890 0.6922057 0.6948791 1.1977047 0.7107659 1.3493244 #>  [15] 1.1315107 0.5192456 1.6181089 1.1255197 0.6139932 1.1130316 0.2994175 #>  [22] 0.7625404 0.2999797 0.8641572 1.2187100 1.2814324 0.3824490 0.9207420 #>  [29] 1.1403403 0.3695379 1.4697527 0.9047391 0.4072838 0.4086533 0.9336283 #>  [36] 1.0253846 1.2746207 1.2389333 1.5941384 1.1963421 0.5599394 0.5972302 #>  [43] 1.0144189 0.8002580 0.4502802 1.1163495 0.5809296 1.4244017 0.9590778 #>  [50] 1.2828274 1.5297917 0.8138715 0.7212816 1.4461675 1.0349981 0.7453069 #>  [57] 1.0210496 1.2419379 1.3741230 1.0986051 0.8758285 1.1735655 0.5976080 #>  [64] 0.8904322 1.6233541 0.8059716 1.4919759 1.1787462 1.0145394 1.3836082 #>  [71] 1.2268082 1.1704848 1.2750769 0.9169179 0.5963439 1.5454189 0.7963324 #>  [78] 1.7116639 0.9309376 0.9485817 0.9387339 1.1573696 0.6048362 0.9319197 #>  [85] 1.1612720 0.9907762 0.9403920 1.1415660 1.3232608 0.9664984 0.6543996 #>  [92] 0.9952130 0.8423264 1.0979808 0.7735316 1.0236896 0.3128155 0.7172526 #>  [99] 1.2987465 1.3156077 0.8861968 0.8041023 1.3887307 0.7626237 1.0574967 #> [106] 0.5654114 0.9387753 1.1332396 1.3187461 1.3750455 1.2840815 1.0980457 #> [113] 0.5106619 0.3654438 0.9253451 0.8131477 0.9423602 1.2746120 1.4926014 #> [120] 1.2882855 0.9578128 0.6690747 1.7255752 0.6915817 1.1805667 1.5462893 #> [127] 1.4799990 1.2547675 1.4885465 1.5331700 0.8000799 0.9242831 0.8972873 #> [134] 0.5822894 1.4211837 1.4711264 1.0189077 1.1383444 0.5706135 1.3398664 #> [141] 0.6468929 0.4029541 1.3724370 1.1276486 1.0439208 1.5059942 1.3998324 #> [148] 0.1770508 1.4076756 1.1154960 1.5349931 1.0484810 1.4391473 0.4710791 #> [155] 0.5403335 0.7005458 1.8050641 1.4848396 0.7156361 1.3325150 0.7362993 #> [162] 1.3438726 0.8285547 0.3849198 1.5678709 1.2341540 0.5106456 0.2668566 #> [169] 0.5504141 1.3424511 0.9247626 1.0576609 1.3647710 1.7021687 1.6352920 #> [176] 0.3140200 1.0421455 1.1013259 1.5020743 0.6462236 1.4313372 1.3540828 #> [183] 0.7369552 0.6403422 0.9502782 1.2130977 0.7939327 1.1204203 1.1277037 #> [190] 1.3037997 0.3774526 1.2877474 0.9799113 0.8576480 1.0937620 1.1248835 #> [197] 1.2573625 1.4749750 0.8422842 1.3569855  # Efficacy model (EffFlexi) and samples. model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  samples_effflexi <- mcmc(emptydata, model_effflexi, mcmc_opts)  # Gain values for dose level 75 and EffFlexi efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effflexi,   samples_eff = samples_effflexi ) #>   [1] -3.641258479 -0.166594269  2.829620278  0.373952783 -0.531216668 #>   [6] -0.849105460 -0.065925460  3.754745902 -2.791016053 -1.147059424 #>  [11] -1.622033918  2.597111740  1.197175328  1.369203404  2.781684703 #>  [16]  0.962836870  0.211708598  0.973357798 -1.811698890  3.131962728 #>  [21] -0.389066338  2.691613664  0.042115612 -0.943475453  0.096550011 #>  [26]  1.572014038  0.857323140  3.656854731  4.916892544 -0.050870353 #>  [31]  7.615495164  6.990399000  0.189376787  1.216857254  2.122802942 #>  [36] -0.343985681 -2.044233401  0.405325747 -4.692310210  0.183203671 #>  [41]  1.751732491  2.472171778  3.907644282  0.509817220  0.963978404 #>  [46] -1.910024280  2.548437823  3.584017283 -2.961184300  5.625251529 #>  [51]  1.411365107  1.823892403 -0.555407059  2.214243352  5.325509511 #>  [56]  3.230107442 -0.180554045 -1.519353539  4.392940449 -0.324944427 #>  [61]  1.937776867  4.713343578  0.002247316  3.826853736  2.683337672 #>  [66] -0.992753550 -1.479189994  3.914210627  3.570068719 -2.851355623 #>  [71]  1.326984049 -0.689519459  1.802278904  3.385245313  1.734210398 #>  [76]  2.017888700 -0.782043480  1.546538605  1.576855927 -2.485716994 #>  [81]  1.739378275 -0.097576690  1.330695648 -0.641331468 -2.137687696 #>  [86]  3.549640751 -5.127964328 -2.174882417  0.374979399 -0.439305187 #>  [91]  2.640830551  7.110037040 -0.355985551  0.748719357  1.057974680 #>  [96] -2.568168383  0.837028308  4.035940395 -2.650119496  2.069409492 #> [101]  0.168311973 -0.354353317 -0.945395850  0.042061322 -1.886457022 #> [106]  0.480350580 -1.311068287  1.189967273 -0.357601100  5.239007064 #> [111]  4.423448654  5.845130739 -0.844561461  1.896738757 -2.956209402 #> [116]  0.466760455 -3.277578269  4.374041653  2.898278267  2.501704743 #> [121]  0.347510835  0.037178121  6.489170359  6.496274308  2.145448273 #> [126]  6.512057312  2.766912660  0.715474276 -4.413271023 -0.770319686 #> [131]  0.814217755  0.918800050  3.731321024 -0.218731762 -0.464509686 #> [136] -0.426412729 -0.208224708 -1.318230637  0.595482918  2.551353508 #> [141]  2.526157319  0.873345642 -2.385976068 -3.150363936 -0.720407718 #> [146] -0.589728368  2.352961488  0.987534174  1.044477211  3.451487245 #> [151]  7.431615588 -0.459645433  4.732831808  1.766993618 -1.165560079 #> [156] -0.887049698 -7.853038676 -2.497354236  2.770452213  5.268456605 #> [161] -0.097615890  2.467869827  2.685456166  2.494766869  2.567079551 #> [166]  8.717333592 -1.737184651 -0.528517049  4.013972818  1.902246000 #> [171]  3.727450039 -3.394227948 -0.874971561  2.259698149  6.547521168 #> [176]  0.918450022  2.950616237 -1.445793249  3.845205913  1.820144472 #> [181]  3.163183920  0.222833102 -0.428068347  0.478277681  3.585246116 #> [186]  4.655750990  2.230958985  2.182741536  5.235442639 -0.754730037 #> [191]  0.857802805  2.543688576 -0.414278366  1.772843364 -5.108692368 #> [196] -1.306825956  1.140343944  3.245963440  1.547776394 -0.642978970  # Obtain the gain value for a given dose, a pseudo DLE and efficacy models # without DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) data <- Data(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  # Efficacy model and samples. model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Gain value for dose level 75. gain(   dose = 75,   model_dle = model_dle,   model_eff = model_eff ) #> [1] 1.020657"},{"path":"https://roche.github.io/crmPack/main/reference/get-Samples-character-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"specify pos parameter like extract Samples object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/get-Samples-character-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# S4 method for Samples,character get(x, pos = -1L, envir = NULL, mode = NULL, inherits = NULL)"},{"path":"https://roche.github.io/crmPack/main/reference/get-Samples-character-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"x Samples object pos name parameter envir vectorial parameters, can give indices elements like extract. NULL, whole vector samples returned mode used inherits used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/get-Samples-character-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"data frame suitable use ggmcmc","code":""},{"path":"https://roche.github.io/crmPack/main/reference/get-Samples-character-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # now extract the alpha0 samples (intercept of the regression model) alpha0samples <- get(samples, \"alpha0\")  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/getEff.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"method extracts efficacy responses subjects categorizes respect DLT, .e. DLT DLT. efficacy responses reported together corresponding dose levels.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getEff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"getEff(object, ...)  # S4 method for DataDual getEff(object, no_dlt = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/getEff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"object (DataDual) object responses dose levels extracted. ... arguments passed class-specific methods. no_dlt (flag) DLT responses returned? Otherwise, responses returned.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getEff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"list efficacy responses categorized DLT value.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getEff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"# Example data. data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Get the efficacy response and their corresponding dose levels # categorized by the DLT. getEff(data) #> $x_no_dlt #> [1]  25  50  25  50  75 150 #>  #> $w_no_dlt #> [1] 0.31 0.42 0.59 0.45 0.60 0.52 #>  #> $x_dlt #> [1] 300 250 #>  #> $w_dlt #> [1] 0.7 0.6 #>"},{"path":"https://roche.github.io/crmPack/main/reference/getMinInfBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the minimal informative unimodal beta distribution — getMinInfBeta","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"defined Neuenschwander et al (2008), function computes parameters minimal informative unimodal beta distribution, given request p-quantile q, .e. X ~ (, b) Pr(X <= q) = p.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getMinInfBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"","code":"getMinInfBeta(p, q)"},{"path":"https://roche.github.io/crmPack/main/reference/getMinInfBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"p probability (> 0 < 1) q quantile (> 0 < 1)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getMinInfBeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the minimal informative unimodal beta distribution — getMinInfBeta","text":"two resulting beta parameters b list","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getResultList.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to obtain simulation results list — getResultList","title":"Helper function to obtain simulation results list — getResultList","text":"function fun can use variables visible . names variables given vector vars.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getResultList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to obtain simulation results list — getResultList","text":"","code":"getResultList(fun, nsim, vars, parallel = NULL)"},{"path":"https://roche.github.io/crmPack/main/reference/getResultList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to obtain simulation results list — getResultList","text":"fun simulation function single iteration, takes single parameter iteration index nsim number simulations conducted vars names variables parallel shall iterations parallelized across cores? NULL, parallelization done. scalar positive number, many cores used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getResultList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to obtain simulation results list — getResultList","text":"list simulation results (one iteration corresponds one list element)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/getResultList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Helper function to obtain simulation results list — getResultList","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_all_equivalent.html","id":null,"dir":"Reference","previous_headings":"","what":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"helper function ensures default tolerance level equal 1e-10, ignores names attributes. contrast .equal(), always returns logical type object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_all_equivalent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"","code":"h_all_equivalent(target, current, tolerance = 1e-10)"},{"path":"https://roche.github.io/crmPack/main/reference/h_all_equivalent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"target (numeric) target values. current (numeric) current values. tolerance (number) relative differences smaller reported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_all_equivalent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"TRUE target current differ desired tolerance without looking names attributes, FALSE otherwise.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_check_fun_formals.html","id":null,"dir":"Reference","previous_headings":"","what":"Checking Formals of a Function — h_check_fun_formals","title":"Checking Formals of a Function — h_check_fun_formals","text":"helper function checks whether given function fun required allowed arguments. argument check based names arguments. logic verified .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_check_fun_formals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checking Formals of a Function — h_check_fun_formals","text":"","code":"h_check_fun_formals(fun, mandatory = NULL, allowed = NULL)"},{"path":"https://roche.github.io/crmPack/main/reference/h_check_fun_formals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checking Formals of a Function — h_check_fun_formals","text":"fun (function) function name whose argument names checked. mandatory (character NULL) names arguments must present fun. mandatory specified NULL (default) requirement ignored. allowed (character NULL) names arguments allowed fun. Names belong allowed simply allowed. allowed parameter independent mandatory, sense mandatory specified character vector, repeated allowed. allowed specified NULL (default), means must arguments fun (except ones specified mandatory).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_dose_grid_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Grid Range — h_dose_grid_range","title":"Getting the Dose Grid Range — h_dose_grid_range","text":"helper function gets dose grid range given data object. returns c(-Inf, Inf) range determined. happens dose grid empty placebo grid.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_dose_grid_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Grid Range — h_dose_grid_range","text":"","code":"h_dose_grid_range(data)"},{"path":"https://roche.github.io/crmPack/main/reference/h_dose_grid_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Grid Range — h_dose_grid_range","text":"data (Data) data object contains dose grid.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_dose_grid_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Grid Range — h_dose_grid_range","text":"numeric vector containing minimum maximum doses grid c(-Inf, Inf).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_find_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"simple wrapper findInterval() function invokes findInterval(), takes output replaces elements \\(0\\) value custom number specified replacement argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_find_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(..., replacement = -Inf)"},{"path":"https://roche.github.io/crmPack/main/reference/h_find_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"... Arguments passed base::findInterval x numeric. vec numeric, sorted (weakly) increasingly, length N,     say. rightmost.closed logical; true, rightmost interval,     vec[N-1] .. vec[N] treated closed, see . .inside logical; true, returned indices coerced     1,...,N-1, .e., 0 mapped 1     N N-1. left.open logical; true intervals open left     closed right; formulas , \\(\\le\\)     swapped \\(<\\) (\\(>\\) \\(\\ge\\)),     rightmost.closed means ‘leftmost closed’.  may     useful, e.g., survival analysis computations. replacement (number) custom number used replacement \\(0\\). Default -Inf.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_find_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(1, c(2, 4, 6)) #> [1] -Inf h_find_interval(3, c(2, 4, 6)) #> [1] 1 h_find_interval(1, c(2, 4, 6), replacement = -1) #> [1] -1"},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Formatting Using C-style Formats — h_format_number","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"helper function conditionally formats number formatC() function using \"E\" format specific number digits given user. number formatted absolute value less 0.001 greater 10000. Otherwise, number formatted. Additionally, custom prefix suffix can appended character string formatted number, changes marked.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(x, digits = 5, prefix = \"\", suffix = \"\")"},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"x (number) number formatted. digits (function) desired number significant digits. prefix (string) prefix added front formatted number. suffix (string) suffix appended formatted number.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"Either formatted x string unchanged x formatting condition met.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_format_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(50000) #> [1] \"5.00000E+04\" h_format_number(50000, prefix = \"P\", suffix = \"S\") #> [1] \"P5.00000E+04S\""},{"path":"https://roche.github.io/crmPack/main/reference/h_in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check which elements are in a given range — h_in_range","title":"Check which elements are in a given range — h_in_range","text":"simple helper function tests whether elements given vector matrix within specified interval.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check which elements are in a given range — h_in_range","text":"","code":"h_in_range(x, range = c(0, 1), bounds_closed = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/h_in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check which elements are in a given range — h_in_range","text":"x (numeric) vector matrix elements test. range (numeric) interval, .e. sorted two-elements vector. bounds_closed (logical) bounds range treated closed? can scalar vector length two. scalar, value applies lower bound range[1] upper bound range[2]. vector two flags, first flag corresponds lower bound , second upper bound .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check which elements are in a given range — h_in_range","text":"logical vector matrix length equal length x, every element x, indicates whether given element x range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check which elements are in a given range — h_in_range","text":"","code":"x <- 1:4 h_in_range(x, range = c(1, 3)) #> [1]  TRUE  TRUE  TRUE FALSE h_in_range(x, range = c(1, 3), bounds_closed = FALSE) #> [1] FALSE  TRUE FALSE FALSE h_in_range(x, range = c(1, 3), bounds_closed = c(FALSE, TRUE)) #> [1] FALSE  TRUE  TRUE FALSE mat <- matrix(c(2, 5, 3, 10, 4, 9, 1, 8, 7), nrow = 3) h_in_range(mat, range = c(1, 5)) #>      [,1]  [,2]  [,3] #> [1,] TRUE FALSE  TRUE #> [2,] TRUE  TRUE FALSE #> [3,] TRUE FALSE FALSE"},{"path":"https://roche.github.io/crmPack/main/reference/h_info_theory_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the Information Theoretic Distance — h_info_theory_dist","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"Helper function provides value divergence given equation (7) reference https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_info_theory_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(prob, target, asymmetry)"},{"path":"https://roche.github.io/crmPack/main/reference/h_info_theory_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"prob (numeric) vector matrix probabilities DLT occurring. target (number ) single target probability DLT. asymmetry (number) describes rate penalization overly toxic , range 0 2.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_info_theory_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(c(0.5, 0.2), 0.4, 1.2) #> [1] 0.040000 0.329877"},{"path":"https://roche.github.io/crmPack/main/reference/h_is_positive_definite.html","id":null,"dir":"Reference","previous_headings":"","what":"Testing Matrix for Positive Definiteness — h_is_positive_definite","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"helper function checks whether given numerical matrix x positive-definite square matrix given size, without missing values. function used test given matrix covariance matrix, since every symmetric positive semi-definite matrix covariance matrix.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_is_positive_definite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"","code":"h_is_positive_definite(x, size = 2, tol = 1e-08)"},{"path":"https://roche.github.io/crmPack/main/reference/h_is_positive_definite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"x (matrix) matrix checked. size (integer) size square matrix x checked . tol (number) given tolerance number used check whether eigenvalue positive . eigenvalue considered positive greater tol.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_is_positive_definite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"TRUE given matrix positive-definite, FALSE otherwise.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_is_positive_definite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"positive definiteness test implemented function based following characterization valid real matrices: symmetric matrix positive-definite eigenvalues positive. function eigenvalue considered positive greater tol.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":null,"dir":"Reference","previous_headings":"","what":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"helper function appends dummy value given slots Data class object, total number observations (indicated object@nObs) equals 1. Otherwise, object changed.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"h_jags_add_dummy(object, where, dummy = 0)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"object (Data) object dummy values added. (character) names slots object dummy number appended. dummy (number) dummy number appended selected slots object. Default 0.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"Data object slots updated dummy number.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"main motivation behind function related JAGS. one observation, data passed correctly JAGS, .e. e.g. x y treated like scalars data file. Therefore necessary add dummy values vectors case change number observations (nObs), addition zeros affect results JAGS computations.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_add_dummy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"# Create some data of class 'Data' my_data <- Data(   x = 0.1,   y = 0,   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  my_data_2 <- Data(   x = c(0.1, 0.5),   y = c(0, 1),   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Append dummy to `x` and `y`. h_jags_add_dummy(my_data, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.0 #>  #> Slot \"y\": #> [1] 0 0 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 #>  #> Slot \"cohort\": #> [1] 1 #>  #> Slot \"nObs\": #> [1] 1 #>   # Append dummy to `x` and `y`. No effect as `my_data_2@nObs != 1`. h_jags_add_dummy(my_data_2, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.5 #>  #> Slot \"y\": #> [1] 0 1 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 2 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 #>  #> Slot \"cohort\": #> [1] 1 2 #>  #> Slot \"nObs\": #> [1] 2 #>"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_extract_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"simple helper function extracts sample rjags::mcarray.object S3 class object. rjags::mcarray.object object used rjags::jags.samples() function represent MCMC output JAGS model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_extract_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"","code":"h_jags_extract_samples(x)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_extract_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"x rjags::mcarray.object object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting Data for JAGS — h_jags_get_data","title":"Getting Data for JAGS — h_jags_get_data","text":"simple helper function prepares object data argument rjags::jags.model(), invoked mcmc() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"h_jags_get_data(model, data, from_prior)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting Data for JAGS — h_jags_get_data","text":"model (GeneralModel) input model. data (GeneralData) input data. from_prior (flag) sample prior ? case data appended output, .e. variables required model@priormodel model returned data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  jags_data <- h_jags_get_data(my_model, my_data, from_prior = FALSE) jags_data #> $nObs #> [1] 8 #>  #> $y #> [1] 0 0 0 0 0 0 1 0 #>  #> $x #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> $mean #> [1] -0.85  1.00 #>  #> $prec #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #> $ref_dose #> [1] 56 #>"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_model_inits.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"simple helper function prepares object inits argument rjags::jags.model(), invoked mcmc() method. inits argument specifies initial values model parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_model_inits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"h_jags_get_model_inits(model, data)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_model_inits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"model (GeneralModel) input model. data (GeneralData) input data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_model_inits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"list starting values parameters required initialized MCMC JAGS sampler.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_get_model_inits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  h_jags_get_model_inits(model = my_model, data = my_data) #> $theta #> [1] 0 1 #>"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_join_models.html","id":null,"dir":"Reference","previous_headings":"","what":"Joining JAGS Models — h_jags_join_models","title":"Joining JAGS Models — h_jags_join_models","text":"helper function joins two JAGS models way body second model appended body first model (order). , first, body-extended model returned. arguments model1, model2 model functions () combined way.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_join_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Joining JAGS Models — h_jags_join_models","text":"","code":"h_jags_join_models(model1, model2)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_join_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Joining JAGS Models — h_jags_join_models","text":"model1 (function) first model join. model2 (function) second model join.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_join_models.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Joining JAGS Models — h_jags_join_models","text":"joined models.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_join_models.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Joining JAGS Models — h_jags_join_models","text":"model1 model2 functions must multi-expression body, .e. braced expression(s). Environments attributes function bodies preserved way joining.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Writing JAGS Model to a File — h_jags_write_model","title":"Writing JAGS Model to a File — h_jags_write_model","text":"function converts R function JAGS model text writes given file. \"model text\" conversion, format numbers absolute value less 0.001 greater 10000 changed. numbers converted scientific format specified number significant digits using formatC() function.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"h_jags_write_model(model, file = NULL, digits = 5)"},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writing JAGS Model to a File — h_jags_write_model","text":"model (function) function containing JAGS model. file (string NULL) name file (including optional path) model saved. NULL, file created R_crmPack folder placed temporary directory indicated tempdir() function. digits (count) desired number significant digits numbers used JAGS input, see formatC().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writing JAGS Model to a File — h_jags_write_model","text":"name file model saved.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Writing JAGS Model to a File — h_jags_write_model","text":"JAGS syntax allows truncation specification like dnorm(...) (...), illegal R. overcome incompatibility, use dummy operator \\%_\\% (...), .e. dnorm(...) \\%_\\% (...) model's code. dummy operator \\%_\\% removed just saving JAGS code file. Due technical issues related conversion numbers scientific format, required body model function contain TEMP_NUM_PREF_ _TEMP_NUM_SUF character constants body.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_jags_write_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"# Some model function my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  h_jags_write_model(my_model, digits = 5) #> [1] \"/tmp/RtmpmhCwMJ/R_crmPack/jags_model_fun14d5dbec95c.txt\""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"simple helper function takes DualEndpoint object updates use_fixed, priormodel, modelspecs, init, sample slots regard given parameter dose-biomarker relationship \\(f(x)\\) defined DualEndpointBeta class. update solely depends whether given parameter's value param fixed-valued scalar two-elements numeric vector. later case, assumed param represents two parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). See help page DualEndpointBeta class details.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"","code":"h_model_dual_endpoint_beta(   param,   param_name,   param_suffix = c(\"_low\", \"_high\"),   priormodel = NULL,   de )"},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"param (numeric) value given param_name parameter dose-biomarker relationship function \\(f(x)\\). Either fixed-valued scalar vector two elements parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). param_name (string) name parameter \\(f(x)\\), whose value depends param. param_suffix (character) two suffixes appended elements param_name used updating modelspecs. value argument ignored param scalar. priormodel (function NULL) function representing JAGS prior specification appended existing de@priormodel specification param scalar. Otherwise, de@priormodel remains unchanged. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to parameters\nof the function that models dose-biomarker relationship defined in the\nDualEndpointBeta class. — h_model_dual_endpoint_beta","text":"DualEndpoint model updated use_fixed, priormodel, modelspecs, init, sample slots.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_rho.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard DLT biomarker correlation rho.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_rho.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"","code":"h_model_dual_endpoint_rho(use_fixed, rho, comp)"},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_rho.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"use_fixed (flag) indicates whether fixed value DLT biomarker correlation rho used . rho supposed fixed value, prior distribution scaled Beta family used. See details , rho argument. rho (numeric) DLT biomarker correlation. must either fixed value (-1 1), named vector two elements, named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_rho.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to DLT and biomarker\ncorrelation. — h_model_dual_endpoint_rho","text":"list updated model components.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2W.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard biomarker regression variance sigma2W.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2W.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"","code":"h_model_dual_endpoint_sigma2W(use_fixed, sigma2W, comp)"},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2W.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"use_fixed (flag) indicates whether fixed value biomarker regression variance sigma2W used . sigma2W supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2W argument. sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2W.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to biomarker\nregression variance. — h_model_dual_endpoint_sigma2W","text":"list updated model components.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2betaW.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"simple helper function takes DualEndpoint object updates priormodel, modelspecs, init, sample slots according random walk variance.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2betaW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"","code":"h_model_dual_endpoint_sigma2betaW(use_fixed, sigma2betaW, de)"},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2betaW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"use_fixed (flag) indicates whether fixed value sigma2betaW used . sigma2betaW supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2betaW argument. sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_model_dual_endpoint_sigma2betaW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to prior variance\nfactor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"DualEndpoint model updated priormodel, modelspecs, init, sample slots.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_eligible_doses.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"Helper function gets eligible doses dose grid. eligible doses doses exceed given doselimit. placebo design, safety allows (.e. least one non-placebo dose exceed dose limit), placebo dose excluded eligible doses.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_eligible_doses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"h_next_best_eligible_doses(dose_grid, doselimit, placebo, levels = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_eligible_doses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo. levels (flag) TRUE levels eligible doses returned, otherwise, doses (default).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_eligible_doses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"numeric vector eligible doses eligible dose levels levels flag TRUE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_eligible_doses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"dose_grid <- c(0.001, seq(25, 200, 25)) h_next_best_eligible_doses(dose_grid, 79, TRUE) #> [1] 25 50 75 h_next_best_eligible_doses(dose_grid, 24, TRUE) #> [1] 0.001"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Helper function nextBest-NextBestMaxGain() method. computes 95% credibility intervals given target dose max gain dose. also returns ratio upper lower bounds interval.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"","code":"h_next_best_mg_ci(dose_target, dose_mg, prob_target, placebo, model, model_eff)"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"dose_target (number) target dose estimate. dose_mg (number) dose corresponding maximum gain. prob_target (proportion) target DLT probability. placebo (flag) TRUE first dose level dose grid used considered placebo. needed adjust max gain dose using efficacy constant value. placebo used, model_eff@const added dose_mg. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Yeung, W.Y., Whitehead, J., Reigner, B., Beyer, U., Diack, Ch., Jaki, T. (2015), Bayesian adaptive dose-escalation procedures binary continuous responses utilizing gain function, Pharmaceutical Statistics, doi:10.1002/pst.1706","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_doses_at_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"Helper function given target doses finds dose grid closest target. four different targets context nextBest-NextBestMaxGain() method: \\(min(`dose_mg`, `dose_target_drt`)\\), dose_mg, dose_target_drt dose_target_eot.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_doses_at_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"","code":"h_next_best_mg_doses_at_grid(   dose_target_drt,   dose_target_eot,   dose_mg,   dose_grid,   doselimit,   placebo )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_doses_at_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"dose_target_drt (number) target dose estimate trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"Helper function creates plot nextBest-NextBestMaxGain() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"","code":"h_next_best_mg_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   max_gain,   next_dose,   doselimit,   data,   model,   model_eff )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mg_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. max_gain (number) maximum gain estimate. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. data (DataDual) data object dose grid fetched. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mgsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"Helper function creates plot nextBest-NextBestMaxGainSamples() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mgsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"","code":"h_next_best_mgsamples_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   dose_mg_samples,   next_dose,   doselimit,   dose_grid_range )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_mgsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_mg_samples (numeric) every sample, dose (dose grid) gives maximum gain value. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. dose_grid_range (numeric) dose grid range.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_ncrm_loss_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"Helper function creates plot nextBest-NextBestNCRMLoss() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_ncrm_loss_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"","code":"h_next_best_ncrm_loss_plot(   prob_mat,   posterior_loss,   max_overdose_prob,   dose_grid,   max_eligible_dose_level,   doselimit,   next_dose,   is_unacceptable_specified )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_ncrm_loss_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"prob_mat (numeric) matrix probabilities grid doses given interval. is_unacceptable_specified TRUE, must 4 intervals (columns) prob_mat: underdosing, target, excessive, unacceptable. Otherwise, must 3 intervals (columns): underdosing, target, overdose. Number rows must equal number doses grid. posterior_loss (numeric) posterior losses. max_overdose_prob (number) maximum overdose posterior probability allowed. dose_grid (numeric) dose grid. max_eligible_dose_level (number) maximum eligible dose level dose_grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose. is_unacceptable_specified (flag) unacceptable interval specified?","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_td_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"Helper function creates plot nextBest-NextBestTD() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_td_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"","code":"h_next_best_td_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   data,   prob_dlt,   doselimit,   next_dose )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_td_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. data (Data) data object dose grid fetched. prob_dlt (numeric) DLT probabilities doses grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_tdsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"Helper function creates plot nextBest-NextBestTDsamples() method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_tdsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"","code":"h_next_best_tdsamples_plot(   dose_target_drt_samples,   dose_target_eot_samples,   dose_target_drt,   dose_target_eot,   dose_grid_range,   nextBest,   doselimit,   next_dose )"},{"path":"https://roche.github.io/crmPack/main/reference/h_next_best_tdsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"dose_target_drt_samples (numeric) vector -trial samples. dose_target_eot_samples (numeric) vector end--trial samples. dose_target_drt (number) target -trial estimate. dose_target_eot (number) target end--trial estimate. dose_grid_range (numeric) range dose grid. nextBest (NextBestTDsamples) rule next best dose. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_null_if_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting NULL for NA — h_null_if_na","title":"Getting NULL for NA — h_null_if_na","text":"simple helper function replaces NA object NULL object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_null_if_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(x)"},{"path":"https://roche.github.io/crmPack/main/reference/h_null_if_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting NULL for NA — h_null_if_na","text":"x () atomic object length 1. definition \"atomic\", see .atomic().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_null_if_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting NULL for NA — h_null_if_na","text":"NULL x NA, otherwise, x.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_null_if_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(NA) #> NULL"},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_cohort_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"helper function prepares ggplot geom reference lines separating different cohorts plot Data class object. Lines either vertical horizontal green color longdash type.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_cohort_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"","code":"h_plot_data_cohort_lines(cohort, placebo, vertical = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_cohort_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"cohort (integer) cohort indices. placebo (flag) placebo included doses? , function returns NULL object case doses given cohort equal need separate . vertical (flag) line vertical? Otherwise horizontal.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_cohort_lines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"geom object returned placebo equal TRUE one unique values cohort. Otherwise, function returns NULL object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Data for Plotting — h_plot_data_df","title":"Preparing Data for Plotting — h_plot_data_df","text":"helper function prepares data.frame object based Data class object. resulting data frame used plot function Data class objects.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Data for Plotting — h_plot_data_df","text":"","code":"h_plot_data_df(data, blind = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Data for Plotting — h_plot_data_df","text":"data (Data) object data extracted converted data frame. blind (flag) data blinded? TRUE, cohort, DLTs assigned first subjects cohort. addition, placebo () set active dose level cohort. ... arguments passed data.frame constructor. can e.g. extra column_name = value pair based slot x (case might subclass Data) appear Data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_plot_data_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preparing Data for Plotting — h_plot_data_df","text":"data.frame object values plot.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursively Apply a Function to a List — h_rapply","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function recursively iterates \"list-like\" object checks whether element given class. , replaces element result execution given function. Otherwise, element length greater 1 (.e. scalar), replaces element result h_rapply(), recursively called element. remaining case, , element given class scalar, element remains unchanged.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"h_rapply(x, fun, classes, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursively Apply a Function to a List — h_rapply","text":"x () \"list-like\" object subsetting operator [[ defined. fun (function) function one \"principal\" argument, passing arguments via .... classes (character) class names. ... arguments passed function fun.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursively Apply a Function to a List — h_rapply","text":"\"list-like\" object similar structure x.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function conceptually similar rapply() function. However, differs rapply() two major ways. First, h_rapply() limited objects type list expression . can \"list-like\" object type subsetting operator [[ defined. can , example, object type language, often obtained body() function. second difference flexibility rapply() result structured available h_rapply() user. , h_rapply() element x, class included classes, replaced result applying fun element. behavior corresponds rapply() invoked fixed = replace. function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_rapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"# Some model function. my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  # Replace format of numbers using `formatC` function. h_rapply(   x = body(my_model),   fun = formatC,   classes = c(\"integer\", \"numeric\"),   digits = 3,   format = \"E\" ) #> { #>     alpha0 <- mean(\"1.000E+00\":\"1.000E+01\") #>     alpha1 <- \"6.000E+05\" #> }"},{"path":"https://roche.github.io/crmPack/main/reference/h_slots.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Slots from a S4 Object — h_slots","title":"Getting the Slots from a S4 Object — h_slots","text":"helper function extracts requested slots S4 class object. simple wrapper methods::slot() function.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_slots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Slots from a S4 Object — h_slots","text":"","code":"h_slots(object, names, simplify = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/h_slots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Slots from a S4 Object — h_slots","text":"object (S4) object formally defined S4 class. names (character) vector names slots fetched. function assumes every element names, exists slot name object. simplify (flag) output simplified? effect single slot extracted, .e. names just single string.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_slots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Slots from a S4 Object — h_slots","text":"list slots extracted object according names, single slot simplification required possible.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a named vector of type numeric — h_test_named_numeric","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"simple helper function tests whether object named numerical vector.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(   x,   subset.of = NULL,   must.include = NULL,   permutation.of = NULL,   identical.to = NULL,   disjunct.from = NULL,   lower = 0 + .Machine$double.xmin,   finite = TRUE,   any.missing = FALSE,   len = 2,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"x () object check. subset.[character] Names provided x must subset set subset.. must.include [character] Names provided x must superset set must.include. permutation.[character] Names provided x must permutation set permutation.. Duplicated names permutation.stripped duplicated names x thus lead failed check. Use argument instead identical.order names relevant. identical.[character] Names provided x must identical vector identical.. Use argument instead permutation.order names relevant. disjunct.[character] Names provided x must may present vector disjunct.. lower [numeric(1)] Lower value elements x must greater equal . finite [logical(1)] Check finite values? Default FALSE. .missing [logical(1)] vectors missing values allowed? Default TRUE. len [integer(1)] Exact expected length x. ... parameters passed checkmate::test_numeric().","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"TRUE x named vector type numeric, otherwise FALSE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"function based checkmate::test_numeric() checkmate::test_names() functions.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_test_named_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(1:2, permutation.of = c(\"a\", \"b\")) #> [1] FALSE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"a\", \"b\")) #> [1] TRUE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"b\", \"a\")) #> [1] TRUE"},{"path":"https://roche.github.io/crmPack/main/reference/h_validate_combine_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Combining S4 Class Validation Results — h_validate_combine_results","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"simple helper function combines two outputs calls result() function placed slot Validate() reference class.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_validate_combine_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(v1, v2)"},{"path":"https://roche.github.io/crmPack/main/reference/h_validate_combine_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"v1 (logical character) output result() function Validate() reference class, combined v2. v2 (logical character) output result() function Validate() reference class, combined v1.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/h_validate_combine_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(TRUE, \"some_message\") #> [1] \"some_message\""},{"path":"https://roche.github.io/crmPack/main/reference/is.bool.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a boolean option — is.bool","title":"Predicate checking for a boolean option — is.bool","text":"Predicate checking boolean option","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.bool.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a boolean option — is.bool","text":"","code":"is.bool(x)"},{"path":"https://roche.github.io/crmPack/main/reference/is.bool.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a boolean option — is.bool","text":"x object checked","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.bool.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a boolean option — is.bool","text":"Returns TRUE x length one logical vector (.e., scalar)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a probability range — is.probRange","title":"Predicate checking for a probability range — is.probRange","text":"Predicate checking probability range","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a probability range — is.probRange","text":"","code":"is.probRange(x, bounds = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/is.probRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a probability range — is.probRange","text":"x object checked bounds whether include bounds 0 1 (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a probability range — is.probRange","text":"Returns TRUE x probability range","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a probability — is.probability","title":"Predicate checking for a probability — is.probability","text":"Predicate checking probability","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a probability — is.probability","text":"","code":"is.probability(x, bounds = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/is.probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a probability — is.probability","text":"x object checked bounds whether include bounds 0 1 (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a probability — is.probability","text":"Returns TRUE x probability","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.range.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicate checking for a numeric range — is.range","title":"Predicate checking for a numeric range — is.range","text":"Predicate checking numeric range","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicate checking for a numeric range — is.range","text":"","code":"is.range(x)"},{"path":"https://roche.github.io/crmPack/main/reference/is.range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicate checking for a numeric range — is.range","text":"x object checked","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicate checking for a numeric range — is.range","text":"Returns TRUE x numeric range","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.scalar.html","id":null,"dir":"Reference","previous_headings":"","what":"Checking for scalar — is.scalar","title":"Checking for scalar — is.scalar","text":"Checking scalar","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.scalar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checking for scalar — is.scalar","text":"","code":"is.scalar(x)"},{"path":"https://roche.github.io/crmPack/main/reference/is.scalar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checking for scalar — is.scalar","text":"x input","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.scalar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checking for scalar — is.scalar","text":"Returns TRUE x length one vector (.e., scalar)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.wholenumber.html","id":null,"dir":"Reference","previous_headings":"","what":"checks for whole numbers (integers) — is.wholenumber","title":"checks for whole numbers (integers) — is.wholenumber","text":"checks whole numbers (integers)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.wholenumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checks for whole numbers (integers) — is.wholenumber","text":"","code":"is.wholenumber(x, tol = .Machine$double.eps^0.5)"},{"path":"https://roche.github.io/crmPack/main/reference/is.wholenumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checks for whole numbers (integers) — is.wholenumber","text":"x numeric vector tol tolerance","code":""},{"path":"https://roche.github.io/crmPack/main/reference/is.wholenumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"checks for whole numbers (integers) — is.wholenumber","text":"TRUE FALSE element x","code":""},{"path":"https://roche.github.io/crmPack/main/reference/logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for logit function — logit","title":"Shorthand for logit function — logit","text":"Shorthand logit function","code":""},{"path":"https://roche.github.io/crmPack/main/reference/logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for logit function — logit","text":"","code":"logit(x)"},{"path":"https://roche.github.io/crmPack/main/reference/logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for logit function — logit","text":"x function argument","code":""},{"path":"https://roche.github.io/crmPack/main/reference/logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for logit function — logit","text":"logit(x)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for value matching with tolerance — matchTolerance","title":"Helper function for value matching with tolerance — matchTolerance","text":"modified version match supports tolerance.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for value matching with tolerance — matchTolerance","text":"","code":"matchTolerance(x, table)  x %~% table"},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for value matching with tolerance — matchTolerance","text":"x values matched table values matched ","code":""},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for value matching with tolerance — matchTolerance","text":"vector length x empty vector table empty.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Helper function for value matching with tolerance — matchTolerance","text":"x %~% table: Helper function checking inclusion table tolerance","code":""},{"path":"https://roche.github.io/crmPack/main/reference/matchTolerance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper function for value matching with tolerance — matchTolerance","text":"","code":"myDose <- c(rep(0.030, 6), rep(0.050, 3), rep(0.075, 4), rep(0.1, 9), rep(0.15, 7)) doseGrid <- seq(from = .025, to = .15, by = .005)  myDose %in% doseGrid #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE #> [13] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [25]  TRUE  TRUE  TRUE  TRUE  TRUE matchTolerance(myDose, doseGrid) #>  [1]  2  2  2  2  2  2  6  6  6 11 11 11 11 16 16 16 16 16 16 16 16 16 26 26 26 #> [26] 26 26 26 26 myDose %~% doseGrid #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE  matchTolerance(c(myDose, 500), doseGrid) #>  [1]  2  2  2  2  2  2  6  6  6 11 11 11 11 16 16 16 16 16 16 16 16 16 26 26 26 #> [26] 26 26 26 26 NA c(myDose, 500) %~% doseGrid #>  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [25]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE"},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the maximum possible next dose — maxDose","title":"Determine the maximum possible next dose — maxDose","text":"Determine upper limit next dose based increments rule. Increments control based number dose levels Increment rule determine maximum possible next dose based maximum dose levels increment next dose. Increment rule can applied last dose maximum dose given far. Determine maximum possible dose escalation.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the maximum possible next dose — maxDose","text":"","code":"maxDose(increments, data, ...)  # S4 method for IncrementsRelative,Data maxDose(increments, data, ...)  # S4 method for IncrementsNumDoseLevels,Data maxDose(increments, data, ...)  # S4 method for IncrementsHSRBeta,Data maxDose(increments, data, ...)  # S4 method for IncrementsRelativeParts,DataParts maxDose(increments, data, ...)  # S4 method for IncrementsRelativeDLT,Data maxDose(increments, data, ...)  # S4 method for IncrementsRelativeDLTCurrent,Data maxDose(increments, data, ...)  # S4 method for IncrementsMin,Data maxDose(increments, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the maximum possible next dose — maxDose","text":"increments rule, object class Increments data data input, object class Data ... arguments","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the maximum possible next dose — maxDose","text":"maximum possible next dose","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine the maximum possible next dose — maxDose","text":"function outputs maximum possible next dose, based corresponding rule increments data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the maximum possible next dose — maxDose","text":"maxDose(increments = IncrementsRelative, data = Data): Determine maximum possible next dose based relative increments maxDose(increments = IncrementsRelativeParts, data = DataParts): Determine maximum possible next dose based relative increments part 1 2 maxDose(increments = IncrementsRelativeDLT, data = Data): Determine maximum possible next dose based relative increments determined DLTs far maxDose(increments = IncrementsRelativeDLTCurrent, data = Data): Determine maximum possible next dose based relative increments determined DLTs current cohort. maxDose(increments = IncrementsMin, data = Data): Determine maximum possible next dose based multiple increment rules (taking minimum across individual increments).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxDose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the maximum possible next dose — maxDose","text":"","code":"# Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6, 8,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!   # In this example we define a rule for dose increments which would allow: #   - doubling the dose if the last dose was below 20 #   - only increasing the dose by 1.33 if the last dose was equal or above 20 myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Based on the rule above, we then calculate the maximum dose allowed nextMaxDose <- maxDose(myIncrements,                        data=data)  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8, 12, 12, 12, 16, 16, 16, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0),   ID = 1:17,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, seq(from = 10, to = 80, by = 2)) )  # In this first example we define a rule for dose increments which would allow: # Maximum skip one dose level, that is 2 dose levels higher than the last dose # given. Maximum increment is explicitly defined as: my_increments <- IncrementsNumDoseLevels(max_levels = 2, basis_level = \"last\") # Since the default method is based on the last dose given, maximum increment # can also be defined as: my_increments <- IncrementsNumDoseLevels(max_levels = 2)  # Based on the rule above, we then calculate the maximum dose allowed my_max_dose <- maxDose(my_increments, data = my_data)  # In this second example we define a rule for dose increments which would allow: # Maximum skip one dose level, that is 2 dose levels higher than the max dose # given. Maximum increment is explicitly defined as: my_increments <- IncrementsNumDoseLevels(max_levels = 2, basis_level = \"max\")  # Based on the rule above, we then calculate the maximum dose allowed. max_dose <- maxDose(my_increments, data = my_data)  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8, 6, 6, 6),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8,       seq(from = 10, to = 80, by = 2)     ) ) #> Used default patient IDs!  # In this example we define a rule for dose increments that limits the further # dose escalation to doses below 6, because dose 6 is above the probability # toxicity threshold. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)  # Based on the rule above, we then calculate the maximum dose allowed. my_next_max_dose <- maxDose(my_increments, data = my_data)  # Create an object of class 'DataParts'. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 )  next_max_dose <- maxDose(my_increments, data = my_data) # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!   # In this example we define a rule for dose increments which would allow: #   - doubling the dose if no DLTs were yet observed #   - only increasing the dose by 1.33 if 1 or 2 DLTs were already observed #   - only increasing the dose by 1.2 if at least 3 DLTs were already observed myIncrements <- IncrementsRelativeDLT(dlt_intervals = c(0, 1, 3),                                       increments = c(1, 0.33, 0.2))  # Based on the rule above, we then calculate the maximum dose allowed nextMaxDose <- maxDose(myIncrements,                        data=data)  # nolint end  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # In this example we define a rule for dose increments which would allow: #   - doubling the dose if no DLTs were observed in current cohort #   - only increasing the dose by 1.33 if 1 or 2 DLTs were observed in current cohort #   - only increasing the dose by 1.2 if at least 3 DLTs were observed in current cohort my_increments <- IncrementsRelativeDLTCurrent(   dlt_intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # Based on the rule above, we then calculate the maximum dose allowed next_max_dose <- maxDose(my_increments,   data = data ) # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6, 8,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!   # As example, here we are combining 2 different increment rules.  # The first rule is the following: #      maximum doubling the dose if no DLTs were observed at the current dose #      or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose #      or maximum increasing the dose by 1.22 if 3 or more DLTs were observed  # The second rule is the following: #   maximum doubling the dose if the current dose is <20 #   OR only maximum increasing the dose by 1.33 if the current dose is >=20  myIncrements1 <- IncrementsRelativeDLT(dlt_intervals = c(0, 1, 3),                                        increments = c(1, 0.33, 0.2))  myIncrements2 <- IncrementsRelative(intervals=c(0, 20),                                     increments=c(1, 0.33))  # Now we combine the 2 rules combIncrement <- IncrementsMin(increments_list=                                 list(myIncrements1,myIncrements2))  # Finally we then calculate the maximum dose allowed by taking the minimum of the two rules nextMaxDose <- maxDose(combIncrement,                        data)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking maximum sizes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"maxSize(...)  # S4 method for CohortSize maxSize(...)"},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMax","code":""},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"maxSize(CohortSize): method combining cohort size rules taking maximum","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/maxSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the maximum of the sample sizes of # the single rules mySize <- maxSize(mySize1, mySize2)"},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining Posterior Samples for all Model Parameters — mcmc","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"function actually runs JAGS MCMC machinery produce posterior samples model parameters required derived values. generic function, customized versions may conveniently defined specific subclasses GeneralData, GeneralModel, McmcOptions input.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"mcmc(data, model, options, ...)  # S4 method for GeneralData,GeneralModel,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointRW,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointBeta,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,DualEndpointEmax,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,OneParLogNormalPrior,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for GeneralData,OneParExpPrior,McmcOptions mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for DataMixture,GeneralModel,McmcOptions mcmc(   data,   model,   options,   from_prior = data@nObs == 0L & data@nObsshare == 0L,   ... )  # S4 method for Data,LogisticIndepBeta,McmcOptions mcmc(data, model, options, ...)  # S4 method for DataDual,Effloglog,McmcOptions mcmc(data, model, options, ...)  # S4 method for DataDual,EffFlexi,McmcOptions mcmc(data, model, options, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"data (GeneralData) input data. model (GeneralModel) input model. options (McmcOptions) MCMC options. ... used. from_prior (flag) sample prior ? Default TRUE number observations data 0. models might necessary specify manually though.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"posterior samples, object class Samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"mcmc(data = GeneralData, model = GeneralModel, options = McmcOptions): Standard method uses JAGS. mcmc(data = GeneralData, model = DualEndpointRW, options = McmcOptions): Standard method uses JAGS. DualEndpointRW model, required least two (case random walk prior first order biomarker level) three doses grid. mcmc(data = GeneralData, model = DualEndpointBeta, options = McmcOptions): Standard method uses JAGS. DualEndpointBeta model, required value ref_dose_beta slot greater maximum dose grid. requirement comes definition beta function used model dose-biomarker relationship DualEndpointBeta model. requirement must least one dose grid. mcmc(data = GeneralData, model = DualEndpointEmax, options = McmcOptions): Standard method uses JAGS. DualEndpointEmax model, required least one dose grid. mcmc(data = GeneralData, model = OneParLogNormalPrior, options = McmcOptions): Standard method uses JAGS. OneParLogNormalPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = GeneralData, model = OneParExpPrior, options = McmcOptions): Standard method uses JAGS. OneParExpPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = DataMixture, model = GeneralModel, options = McmcOptions): Method DataMixture different from_prior default mcmc(data = Data, model = LogisticIndepBeta, options = McmcOptions): Obtain posterior samples model parameters based pseudo 'LogisticsIndepBeta' DLE model. joint prior posterior probability density function intercept \\(\\phi_1\\) (phi1) slope \\(\\phi_2\\) (phi2) given Whitehead Williamson (1998) TsuTakawa (1975). However, since asymptotically, joint posterior probability density bivariate normal use bivariate normal distribution generate posterior samples intercept slope parameters. prior samples intercept slope bivariate normal distribution mean covariance matrix given Whitehead Williamson (1998) used. mcmc(data = DataDual, model = Effloglog, options = McmcOptions): Obtain posterior samples model parameters Efficacy log log model. Given value \\(\\nu\\), precision efficacy responses, joint prior posterior probability intercept \\(\\theta_1\\) (theta1) slope \\(\\theta_2\\) (theta2) bivariate normal distribution.  \\(\\nu\\) (nu), precision efficacy responses either fixed value gamma distribution. gamma distribution used, samples nu first generated. mean nu samples used generate samples intercept slope parameters model mcmc(data = DataDual, model = EffFlexi, options = McmcOptions): Obtain posterior samples estimates Efficacy Flexible form. mcmc procedure based described Lang Brezger (2004) samples mean efficacy responses dose levels, samples sigma2 \\(sigma^2\\), variance efficacy response samples sigma2betaW \\(sigma^2_{beta_W}\\), variance random walk model generated. Please refer Lang Brezger (2004) procedures form joint prior posterior probability density mean efficacy responses. addition, sigma2 sigma2betaW can fixed inverse-gamma prior posterior distribution. Therefore, inverse gamma distribution(s) used, parameters distribution first updated samples sigma2 sigma2betaW generated using updated parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"type Random Number Generator (RNG) initial seed used JAGS taken options argument. initial values supplied (.e RNG kind seed slot options NA), generated automatically JAGS.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/mcmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>    [1] -1.360771834 -0.952468938 -0.896128784 -0.896128784  0.180775646 #>    [6]  0.822325888 -0.060089996 -0.060089996 -1.444977550  0.229782368 #>   [11]  0.229782368 -1.035498393 -1.043130858 -1.043130858 -0.415835989 #>   [16] -0.415835989 -0.415835989 -0.325519712 -0.325519712 -0.266676147 #>   [21]  0.751673939  0.751673939  0.751673939 -1.924587411 -1.566249460 #>   [26] -1.219765938 -1.219765938 -0.874258609  0.196207562  0.196207562 #>   [31]  0.196207562  0.601616328  0.601616328  0.601616328 -1.594762446 #>   [36] -1.594762446 -1.294687130 -2.066468109 -2.888508201 -2.888508201 #>   [41] -1.298557660 -1.298557660  0.959250000  0.959250000  0.959250000 #>   [46]  0.959250000  0.959250000  0.617213188  0.617213188  0.008752388 #>   [51]  0.341185600  0.341185600  0.341185600  0.341185600  0.341185600 #>   [56]  0.341185600 -0.288321290 -0.288321290 -0.288321290 -0.288321290 #>   [61] -0.288321290 -0.288321290 -0.288321290  0.532211013  0.532211013 #>   [66] -0.707475996  0.307884206  0.307884206  0.049945359 -1.699203871 #>   [71] -1.699203871 -0.784611988 -0.784611988 -0.784611988 -0.019410883 #>   [76] -0.019410883 -0.019410883 -0.861670687 -0.861670687 -1.123428000 #>   [81]  0.629725335 -0.642909362 -0.771532737 -0.771532737 -0.771532737 #>   [86] -0.771532737 -0.771532737 -0.771532737 -0.905147417 -0.905147417 #>   [91] -0.444834115  0.698655030  0.698655030  0.698655030  0.698655030 #>   [96]  0.698655030  0.926178494  0.794486060 -0.794600456 -0.794600456 #>  [101] -0.794600456 -0.199934929 -0.107124039  0.706875107  0.706875107 #>  [106]  0.706875107  0.757380638  0.757380638 -0.838582054 -0.363330343 #>  [111]  0.474034354 -0.173405491 -0.173405491 -0.173405491 -1.510292311 #>  [116] -1.510292311 -1.019265906 -1.019265906 -1.019265906 -1.019265906 #>  [121] -1.814878158 -1.814878158 -2.821059762  0.062747202 -0.135939213 #>  [126]  0.453274023  0.767540245  0.767540245  0.767540245  0.767540245 #>  [131]  0.767540245  0.767540245  0.103295558  0.579619513  0.299715425 #>  [136] -0.035726257  1.039841490  1.039841490  1.039841490  0.770501321 #>  [141]  0.770501321  0.770501321 -0.571974808 -0.571974808 -0.775855670 #>  [146] -0.977027459 -0.977027459 -0.977027459 -0.977027459 -0.745194155 #>  [151] -0.745194155 -0.745194155  0.253891097 -1.256213705 -0.226731468 #>  [156] -0.226731468 -0.900189214 -0.900189214 -0.900189214 -0.851863849 #>  [161] -0.851863849 -0.317628888 -0.317628888 -0.144857467 -0.144857467 #>  [166]  0.004892254  0.004892254  1.603467018  1.683342539  1.050527882 #>  [171]  1.050527882 -0.648013943 -0.970500613 -0.585594246 -1.563541155 #>  [176] -1.563541155 -1.563541155 -1.563541155 -0.128154751 -0.128154751 #>  [181] -0.206206963 -0.206206963 -1.612959242 -2.570770012 -1.865588801 #>  [186] -1.865588801 -0.285683280 -0.285683280 -0.285683280 -0.285683280 #>  [191] -0.285683280  0.792578991  0.792578991  0.792578991 -1.035876144 #>  [196] -1.035876144 -1.035876144  0.633698548  0.633698548  0.907937547 #>  [201]  0.907937547  0.907937547  0.613106484  0.613106484  1.555652737 #>  [206]  1.555652737 -0.375652133 -0.375652133 -0.375652133 -0.375652133 #>  [211] -0.375652133 -0.375652133 -0.375652133 -0.375652133 -0.375652133 #>  [216] -1.089875028 -1.089875028 -1.089875028 -0.666629364 -0.296659987 #>  [221]  0.172788372  0.172788372  0.172788372  0.172788372 -0.900599749 #>  [226] -1.812369927 -0.262893151 -0.262893151 -0.262893151 -0.267057334 #>  [231] -0.267057334  0.326990509  0.326990509  0.326990509  0.326990509 #>  [236]  0.326990509  0.326990509  0.326990509  0.326990509 -0.654442554 #>  [241]  0.373519615 -1.496021849 -2.011525881 -2.011525881 -2.122442116 #>  [246] -0.397054171 -0.397054171  0.724059682  0.724059682  0.724059682 #>  [251]  0.532592515  0.825481248 -0.458097948 -0.458097948 -1.515364313 #>  [256] -1.515364313 -1.515364313  0.185058796  0.137122361  0.084274611 #>  [261] -0.975816869 -0.975816869  0.208175689  0.208175689  0.208175689 #>  [266]  0.208175689  0.208175689  0.208175689  0.208175689  0.422380514 #>  [271]  0.422380514  0.422380514  0.422380514  0.226816504  0.226816504 #>  [276] -0.959965949 -0.959965949 -0.959965949 -0.634466097 -1.035250366 #>  [281] -0.774489784 -1.820630509 -1.820630509 -1.820630509 -2.047829508 #>  [286] -2.047829508 -2.047829508 -2.047829508  0.010452192  0.010452192 #>  [291]  0.010452192  0.010452192 -0.697881122  0.086638960  0.086638960 #>  [296] -0.393052356 -0.393052356  0.276514750 -0.121787976 -0.121787976 #>  [301] -0.121787976 -0.452191124 -0.452191124 -0.452191124 -0.452191124 #>  [306] -0.447676532 -0.447676532  0.390245472  0.390245472  0.390245472 #>  [311]  0.390245472  0.390245472  0.798705595 -1.382537974 -1.464865946 #>  [316] -0.160779030 -0.160779030 -0.160779030 -0.160779030 -0.776565670 #>  [321] -0.776565670 -0.776565670 -0.464122739  0.571633628  0.571633628 #>  [326]  0.604963878  0.604963878  0.604963878  0.156858290  0.156858290 #>  [331]  0.268898649 -0.071680323 -1.409392427  0.186816182  0.321842150 #>  [336]  0.321842150  0.321842150  0.321842150  0.761300968  0.761300968 #>  [341] -0.110859826 -0.110859826 -0.110859826 -0.110859826 -0.016121695 #>  [346] -0.016121695 -0.016121695 -0.530746972 -0.049601538 -0.049601538 #>  [351] -0.049601538 -0.474930515 -0.474930515 -0.255422934 -0.099549963 #>  [356] -0.099549963 -0.099549963 -0.446115700 -0.446115700 -0.446115700 #>  [361]  0.240657202  0.240657202 -0.213032713  0.442514015  0.442514015 #>  [366] -0.409490291 -0.100196313 -0.100196313 -0.100196313 -0.100196313 #>  [371] -0.100196313 -0.100196313  0.341145120  0.341145120  0.416053937 #>  [376]  0.416053937 -0.720920370  0.743189164 -0.101407643 -0.258759439 #>  [381] -1.200476174 -1.200476174 -0.319993891 -0.725264002 -0.412431306 #>  [386] -1.839556778 -1.839556778 -1.839556778 -1.552868426 -1.608056517 #>  [391] -0.639365484  0.562128050  0.562128050  1.690956380  1.690956380 #>  [396]  1.677859041 -0.979970038 -0.979970038 -1.240994196 -1.240994196 #>  [401] -0.470142728 -0.470142728 -0.470142728 -0.470142728  0.064123622 #>  [406]  0.064123622  0.064123622  0.255930994  0.255930994  0.255930994 #>  [411]  0.811639652  0.811639652  0.616541121  0.616541121  1.152032815 #>  [416]  1.152032815 -1.177576855 -1.177576855 -0.677883678 -1.477943306 #>  [421] -0.802905115 -0.078562537 -0.078562537 -0.078562537 -0.731785825 #>  [426] -0.731785825 -0.731785825 -0.731785825  0.100721804  0.100721804 #>  [431]  0.152644168  0.152644168  0.483106394  0.193766650  0.193766650 #>  [436]  0.193766650  0.253050481  0.253050481  1.648083420  1.648083420 #>  [441]  0.335843652  0.335843652  1.603358929  1.603358929  1.603358929 #>  [446]  1.603358929  1.603358929  1.603358929  1.603358929 -0.183717020 #>  [451]  0.776744356  0.776744356  1.140137760 -0.727209980 -0.727209980 #>  [456] -0.727209980 -0.930634510  0.241576355  0.241576355  0.241576355 #>  [461]  0.548375614  1.097695902  1.097695902 -0.133187383  0.050280066 #>  [466]  0.495586482 -0.047033406 -0.047033406 -0.320097966 -0.320097966 #>  [471] -0.320097966 -0.320097966 -0.320097966 -0.570308243 -0.570308243 #>  [476] -1.320456038 -1.320456038 -1.320456038 -1.320456038 -1.320456038 #>  [481] -1.320456038 -1.320456038 -1.320456038 -0.770206776 -1.705773626 #>  [486] -3.173530372 -1.790900887 -1.668733907 -0.435529986 -0.522829296 #>  [491] -0.522829296 -0.522829296 -0.522829296  0.159091649  0.159091649 #>  [496]  0.159091649  0.159091649 -1.583371447 -0.735421294  0.630786463 #>  [501]  0.628487283  0.628487283  0.628487283  0.628487283 -0.314723885 #>  [506]  0.363490173  0.844976850  0.844976850  0.523192092  0.523192092 #>  [511]  0.523192092  0.911045319  0.911045319  0.911045319  0.568067692 #>  [516]  0.568067692  0.568067692  0.568067692  0.568067692 -0.825156211 #>  [521] -0.825156211 -0.825156211 -0.263214077 -0.828003014 -0.828003014 #>  [526]  0.494562601  0.494562601  0.494562601  0.494562601  0.494562601 #>  [531] -0.893348104 -0.893348104 -0.893348104 -1.651542490 -0.630951671 #>  [536] -0.630951671  0.403996003  0.403996003  1.093842788  1.093842788 #>  [541]  1.093842788  1.093842788  1.093842788  1.093842788  1.093842788 #>  [546]  1.457715973  1.457715973 -1.214177168  0.843188687  0.843188687 #>  [551]  1.245442017 -0.471473300  0.416212075  0.416212075  0.416212075 #>  [556] -0.247729462 -0.474857991  0.796358971  0.849702190  0.849702190 #>  [561]  0.632786344  1.634427298  1.209326322  1.209326322  0.916672945 #>  [566]  0.916672945  0.087057564  0.087057564  0.087057564  0.046477644 #>  [571] -0.456477574 -0.067149673  0.573919746  0.573919746  0.573919746 #>  [576]  0.573919746 -1.117070757 -1.117070757 -2.108516164 -2.108516164 #>  [581] -1.147282689 -1.147282689 -1.147282689 -1.147282689  0.341664539 #>  [586]  0.341664539  0.341664539 -0.301710544 -1.195504783 -0.871965962 #>  [591] -0.407652018 -0.022224798 -0.942945669 -0.942945669 -0.942945669 #>  [596] -0.942945669 -0.222402633 -0.222402633 -0.222402633 -2.110438035 #>  [601] -2.110438035 -2.110438035 -2.110438035 -1.448078232 -1.448078232 #>  [606] -0.585896780 -0.585896780 -0.219087175 -0.219087175 -0.920879391 #>  [611] -1.016122791 -1.016122791 -0.611578137 -0.987725421 -0.779537460 #>  [616] -0.445836033 -0.445836033 -0.445836033 -0.445836033 -0.411996432 #>  [621] -0.411996432 -0.411996432 -0.411996432 -0.411996432 -0.805118452 #>  [626] -0.805118452 -0.805118452 -1.624719065 -1.296765982 -0.779589210 #>  [631] -0.779589210 -0.779589210 -0.779589210 -0.779589210 -0.779589210 #>  [636] -0.779589210  0.564051356  0.564051356  0.564051356  0.564051356 #>  [641]  0.564051356  0.564051356  0.564051356 -0.831248158 -0.831248158 #>  [646] -1.268438594 -1.268438594 -1.072287997 -1.072287997 -1.072287997 #>  [651] -1.072287997 -0.642750362 -0.346140594 -0.346140594 -0.346140594 #>  [656] -0.996194515 -0.201839353 -0.368390802  1.506178852 -0.246197604 #>  [661] -0.246197604 -0.246197604 -0.246197604 -0.448883050 -0.448883050 #>  [666] -0.448883050 -0.448883050 -0.161730295 -0.590222169  0.424604277 #>  [671]  0.424604277  0.424604277  0.424604277  0.275050903 -0.097479066 #>  [676]  1.562304767  0.810008946  0.810008946  0.286465416  0.404525097 #>  [681]  0.594153405  0.625400030  0.625400030 -0.364136844 -0.364136844 #>  [686]  0.939356329 -0.815180703  0.104406939 -0.787859483 -0.787859483 #>  [691] -0.354483308 -0.354483308 -0.354483308  0.608393449 -0.932453066 #>  [696] -0.932453066 -0.462145488 -0.462145488 -0.462145488 -0.462145488 #>  [701] -0.853214699 -1.165345391 -1.165345391 -0.540020244 -0.540020244 #>  [706] -0.540020244  0.254930206 -0.366578770 -0.366578770 -0.366578770 #>  [711] -0.366578770  0.132553023  0.914522314  0.914522314  0.914522314 #>  [716]  1.005441702  1.005441702  1.005441702  0.157169166  0.157169166 #>  [721]  0.157169166  0.157169166  0.157169166  0.157169166 -1.017229142 #>  [726] -0.133944736 -0.133944736 -0.133944736 -0.133944736 -1.128391691 #>  [731] -1.128391691  0.388691485  0.388691485 -0.925754208 -1.744856860 #>  [736] -1.309616561 -1.309616561 -1.961372545  0.139789372  0.559680775 #>  [741] -0.511901804 -0.511901804 -0.511901804 -0.511901804  0.134656791 #>  [746] -0.127251200 -0.127251200 -0.127251200  0.725100394  1.208576119 #>  [751]  0.260861614  0.260861614  0.260861614 -1.338973326 -0.775268032 #>  [756] -0.775268032 -0.719042140 -0.719042140 -0.719042140 -0.322273318 #>  [761] -0.322273318 -0.322273318 -0.322273318 -0.322273318 -0.007125129 #>  [766] -0.007125129 -0.007125129 -0.007125129  0.391693349  0.329255705 #>  [771] -0.244367763 -0.244367763 -0.244367763  0.401736227 -0.848049931 #>  [776] -1.005819354 -1.005819354 -1.057178072  0.871171758  0.871171758 #>  [781]  0.871171758  0.871171758  0.135491418  0.135491418  0.135491418 #>  [786] -0.341894318 -0.341894318 -0.341894318 -0.341894318 -0.811139947 #>  [791] -0.569312138 -0.569312138 -0.569312138 -1.093720377 -0.832352580 #>  [796] -0.832352580 -0.832352580 -0.832352580 -0.832352580 -0.119437115 #>  [801] -0.119437115 -0.119437115 -0.119437115 -0.119437115 -0.119437115 #>  [806] -1.692168871 -0.273217205 -0.273217205 -0.273217205 -0.273217205 #>  [811] -0.295439534 -0.295439534 -0.295439534 -1.371349899 -0.197109441 #>  [816] -0.197109441  0.074985014 -0.438310393 -0.453011766 -0.453011766 #>  [821] -0.453011766 -0.453011766  0.272740232 -1.188234988 -0.766554568 #>  [826] -0.248449026 -0.248449026 -0.248449026 -0.510264332 -0.510264332 #>  [831] -0.510264332 -0.333866336 -0.333866336  0.082003757  0.082003757 #>  [836] -0.361972772 -0.361972772 -0.361972772 -0.361972772 -0.361972772 #>  [841] -0.361972772  0.816142657  0.816142657  0.816142657  0.816142657 #>  [846] -0.400466670 -0.400466670 -0.400466670 -0.400466670 -0.400466670 #>  [851] -0.212444928  0.526842455 -0.583848303 -0.142332638 -1.845826214 #>  [856] -1.370924688 -1.661723496 -1.661723496 -1.661723496 -1.164993606 #>  [861] -1.164993606 -1.164993606 -1.164993606  0.008657584  0.735984189 #>  [866]  0.372676265  0.372676265 -0.095838769 -0.095838769 -0.095838769 #>  [871] -0.095838769 -0.095838769 -0.095838769 -0.031071309 -0.031071309 #>  [876] -0.031071309 -0.031071309 -0.031071309  0.455856092  0.455856092 #>  [881]  0.455856092  0.455856092  0.455856092  0.455856092  0.455856092 #>  [886]  0.455856092  0.455856092  0.008556314  0.008556314 -0.143879502 #>  [891] -0.629582037  0.574583856  0.574583856  1.300146982  1.300146982 #>  [896]  1.300146982  1.296607201  1.760904294  1.760904294  0.834559747 #>  [901]  0.834559747  0.834559747 -0.093340022 -0.093340022 -0.225433915 #>  [906] -0.225433915 -0.225433915  0.604508545  0.480303655  0.480303655 #>  [911] -0.324826549 -0.305146384 -0.305146384 -0.305146384 -0.305146384 #>  [916] -0.305146384 -1.579850703 -0.091824527 -0.112253123 -0.112253123 #>  [921] -0.112253123 -0.805549508 -1.226224672 -1.826798600 -1.464909954 #>  [926] -1.020942191 -1.020942191 -1.020942191  0.435591387  0.349455309 #>  [931]  1.231301244  1.205330333  1.205330333 -0.492677492 -0.445140379 #>  [936] -0.253364094 -0.253364094 -0.253364094 -1.503063392 -1.503063392 #>  [941]  0.670361890  0.516251787  0.516251787  0.168264715  1.628075433 #>  [946]  0.223701893  0.827182357 -0.198100143 -1.462673555 -1.554183994 #>  [951]  0.051585140  0.051585140 -0.026800378 -0.026800378  0.225640257 #>  [956]  0.225640257  0.225640257 -0.234561131 -0.458416166 -0.458416166 #>  [961] -0.458416166 -0.458416166 -1.194364553 -1.194364553 -1.194364553 #>  [966] -0.846301791 -0.846301791 -0.846301791 -0.412150912 -0.518573730 #>  [971] -0.518573730 -0.078637410  0.127912402  0.127912402  0.127912402 #>  [976]  0.127912402  0.127912402  0.127912402  0.127912402  0.474768930 #>  [981]  0.474768930  0.658964547  0.401938976  0.401938976 -0.559316346 #>  [986] -0.333109233 -0.333109233 -1.167396828 -1.166417861 -0.899312701 #>  [991]  0.054477604  0.054477604  0.054477604  0.054477604 -0.116687860 #>  [996] -0.116687860 -0.262893733  0.503010219 -0.078998473  0.193948816 #>  #> $alpha1 #>    [1] 1.4750792 0.6189574 1.0016756 1.0016756 2.0949520 0.8802537 0.8003113 #>    [8] 0.8003113 0.7335951 0.9467657 0.9467657 1.2593358 0.9618364 0.9618364 #>   [15] 1.5962026 1.5962026 1.5962026 1.2324048 1.2324048 1.5538829 1.3074554 #>   [22] 1.3074554 1.3074554 0.9964551 1.6540632 1.5698495 1.5698495 1.4427658 #>   [29] 1.3076942 1.3076942 1.3076942 0.7796673 0.7796673 0.7796673 0.4427396 #>   [36] 0.4427396 0.8751653 1.4269076 0.8057458 0.8057458 1.0167073 1.0167073 #>   [43] 0.5346800 0.5346800 0.5346800 0.5346800 0.5346800 0.3783494 0.3783494 #>   [50] 0.3373736 0.8282411 0.8282411 0.8282411 0.8282411 0.8282411 0.8282411 #>   [57] 1.2597479 1.2597479 1.2597479 1.2597479 1.2597479 1.2597479 1.2597479 #>   [64] 1.0819531 1.0819531 0.9746179 0.5162712 0.5162712 1.5990776 1.1143209 #>   [71] 1.1143209 2.8830255 2.8830255 2.8830255 1.4687260 1.4687260 1.4687260 #>   [78] 0.6220491 0.6220491 0.8728598 0.8463012 0.6957919 1.2697589 1.2697589 #>   [85] 1.2697589 1.2697589 1.2697589 1.2697589 0.9770964 0.9770964 2.5614722 #>   [92] 0.8999273 0.8999273 0.8999273 0.8999273 0.8999273 1.0172055 0.5635155 #>   [99] 0.8641649 0.8641649 0.8641649 0.5193864 0.4808997 0.5029754 0.5029754 #>  [106] 0.5029754 0.8901725 0.8901725 1.5385026 0.7706852 2.0985684 1.2349104 #>  [113] 1.2349104 1.2349104 0.8301441 0.8301441 1.7566404 1.7566404 1.7566404 #>  [120] 1.7566404 0.3294619 0.3294619 2.1128304 2.4994387 0.4541448 1.9456264 #>  [127] 0.9525815 0.9525815 0.9525815 0.9525815 0.9525815 0.9525815 0.9720822 #>  [134] 1.7918005 1.1247676 1.0051494 1.2117557 1.2117557 1.2117557 1.9208506 #>  [141] 1.9208506 1.9208506 2.2582122 2.2582122 0.4319235 1.5405388 1.5405388 #>  [148] 1.5405388 1.5405388 1.3278079 1.3278079 1.3278079 2.6318909 2.4277569 #>  [155] 2.9071774 2.9071774 1.2472664 1.2472664 1.2472664 0.7938400 0.7938400 #>  [162] 1.6977049 1.6977049 0.6908455 0.6908455 0.3636207 0.3636207 0.9269549 #>  [169] 1.0199346 0.4602613 0.4602613 0.4580778 2.7755696 0.5201700 1.0608670 #>  [176] 1.0608670 1.0608670 1.0608670 1.3605855 1.3605855 0.9112659 0.9112659 #>  [183] 1.1576673 0.9391264 0.3066903 0.3066903 0.6915293 0.6915293 0.6915293 #>  [190] 0.6915293 0.6915293 0.7028913 0.7028913 0.7028913 0.6081231 0.6081231 #>  [197] 0.6081231 1.0549616 1.0549616 0.9600777 0.9600777 0.9600777 0.9191589 #>  [204] 0.9191589 1.3162785 1.3162785 1.6281098 1.6281098 1.6281098 1.6281098 #>  [211] 1.6281098 1.6281098 1.6281098 1.6281098 1.6281098 1.2727336 1.2727336 #>  [218] 1.2727336 1.3026638 0.3620998 0.7979508 0.7979508 0.7979508 0.7979508 #>  [225] 1.9341353 1.1595762 0.4164675 0.4164675 0.4164675 0.6178303 0.6178303 #>  [232] 1.8288147 1.8288147 1.8288147 1.8288147 1.8288147 1.8288147 1.8288147 #>  [239] 1.8288147 1.0164539 0.4886827 0.4912727 1.2679775 1.2679775 1.4891296 #>  [246] 0.5739630 0.5739630 1.2712014 1.2712014 1.2712014 0.8365356 2.0451862 #>  [253] 1.3708273 1.3708273 0.6711963 0.6711963 0.6711963 0.4675657 0.7457344 #>  [260] 1.8875827 0.6515020 0.6515020 0.9448579 0.9448579 0.9448579 0.9448579 #>  [267] 0.9448579 0.9448579 0.9448579 0.9141031 0.9141031 0.9141031 0.9141031 #>  [274] 0.8181078 0.8181078 0.7253118 0.7253118 0.7253118 0.1780510 1.1791408 #>  [281] 1.8826469 2.0661022 2.0661022 2.0661022 1.2330534 1.2330534 1.2330534 #>  [288] 1.2330534 1.2944066 1.2944066 1.2944066 1.2944066 0.7522972 0.5866820 #>  [295] 0.5866820 0.4316134 0.4316134 0.5631340 1.4393718 1.4393718 1.4393718 #>  [302] 0.7872130 0.7872130 0.7872130 0.7872130 0.7679175 0.7679175 1.5893232 #>  [309] 1.5893232 1.5893232 1.5893232 1.5893232 1.0358494 0.9806605 1.0462093 #>  [316] 1.5718937 1.5718937 1.5718937 1.5718937 0.8094319 0.8094319 0.8094319 #>  [323] 1.4654166 1.2274711 1.2274711 1.0471444 1.0471444 1.0471444 1.4770477 #>  [330] 1.4770477 0.6400308 0.7398507 1.1584829 1.8822254 1.3516701 1.3516701 #>  [337] 1.3516701 1.3516701 2.5315764 2.5315764 1.2064638 1.2064638 1.2064638 #>  [344] 1.2064638 0.6479815 0.6479815 0.6479815 1.5378238 1.5947718 1.5947718 #>  [351] 1.5947718 1.3679694 1.3679694 1.2578708 1.3588663 1.3588663 1.3588663 #>  [358] 1.1333339 1.1333339 1.1333339 1.5699144 1.5699144 0.7025498 1.0336656 #>  [365] 1.0336656 1.8077205 0.9554309 0.9554309 0.9554309 0.9554309 0.9554309 #>  [372] 0.9554309 1.7126909 1.7126909 0.6238215 0.6238215 0.9254606 2.0763496 #>  [379] 0.6106876 1.5231114 1.4569153 1.4569153 2.4720121 0.8940011 1.2226425 #>  [386] 1.8871664 1.8871664 1.8871664 0.3806761 0.6371253 0.7320428 0.4025846 #>  [393] 0.4025846 0.8152243 0.8152243 2.2647783 0.2456786 0.2456786 1.3887858 #>  [400] 1.3887858 1.1688117 1.1688117 1.1688117 1.1688117 0.8936612 0.8936612 #>  [407] 0.8936612 1.0207528 1.0207528 1.0207528 1.5802351 1.5802351 1.7965179 #>  [414] 1.7965179 1.8791026 1.8791026 1.2854431 1.2854431 1.2834283 0.5657828 #>  [421] 0.5859716 0.7816421 0.7816421 0.7816421 0.6939696 0.6939696 0.6939696 #>  [428] 0.6939696 1.1341445 1.1341445 0.8959833 0.8959833 2.1865190 3.9714376 #>  [435] 3.9714376 3.9714376 2.1867442 2.1867442 1.6588426 1.6588426 0.5680050 #>  [442] 0.5680050 0.8199260 0.8199260 0.8199260 0.8199260 0.8199260 0.8199260 #>  [449] 0.8199260 0.7156745 0.6316993 0.6316993 0.7873709 1.2171393 1.2171393 #>  [456] 1.2171393 1.4059716 0.5475478 0.5475478 0.5475478 1.7705856 1.3731369 #>  [463] 1.3731369 1.3332742 0.9614001 1.0799989 0.8138106 0.8138106 0.8725322 #>  [470] 0.8725322 0.8725322 0.8725322 0.8725322 0.9400419 0.9400419 1.0939174 #>  [477] 1.0939174 1.0939174 1.0939174 1.0939174 1.0939174 1.0939174 1.0939174 #>  [484] 0.5157012 0.4781285 1.1112729 0.3496903 2.5760419 2.0341119 0.4999260 #>  [491] 0.4999260 0.4999260 0.4999260 0.6161047 0.6161047 0.6161047 0.6161047 #>  [498] 1.9790607 0.2079169 1.5206819 1.2167324 1.2167324 1.2167324 1.2167324 #>  [505] 1.2959121 1.9310561 1.7493722 1.7493722 0.7241366 0.7241366 0.7241366 #>  [512] 1.2198944 1.2198944 1.2198944 0.8998499 0.8998499 0.8998499 0.8998499 #>  [519] 0.8998499 0.9425500 0.9425500 0.9425500 1.3341530 2.5163856 2.5163856 #>  [526] 0.6663542 0.6663542 0.6663542 0.6663542 0.6663542 1.0646621 1.0646621 #>  [533] 1.0646621 1.7875016 2.4213150 2.4213150 2.0846427 2.0846427 1.0361889 #>  [540] 1.0361889 1.0361889 1.0361889 1.0361889 1.0361889 1.0361889 0.8749465 #>  [547] 0.8749465 1.3570109 1.0164240 1.0164240 0.9720899 0.7823675 0.9720649 #>  [554] 0.9720649 0.9720649 0.5590194 0.8266218 0.8504624 1.1198983 1.1198983 #>  [561] 1.6328325 1.8481932 0.9018301 0.9018301 0.6187848 0.6187848 1.6340288 #>  [568] 1.6340288 1.6340288 0.8180849 0.6173812 1.2893184 2.3042649 2.3042649 #>  [575] 2.3042649 2.3042649 2.5086387 2.5086387 1.6494937 1.6494937 1.9928511 #>  [582] 1.9928511 1.9928511 1.9928511 1.6392538 1.6392538 1.6392538 0.8380751 #>  [589] 0.8510333 1.3065861 2.0748644 3.0358162 1.0494665 1.0494665 1.0494665 #>  [596] 1.0494665 0.7169480 0.7169480 0.7169480 1.2178614 1.2178614 1.2178614 #>  [603] 1.2178614 1.1804266 1.1804266 1.1773936 1.1773936 0.7478086 0.7478086 #>  [610] 1.4367915 2.8839776 2.8839776 0.4262948 2.5601497 1.9460381 2.0832381 #>  [617] 2.0832381 2.0832381 2.0832381 0.7245933 0.7245933 0.7245933 0.7245933 #>  [624] 0.7245933 2.3133397 2.3133397 2.3133397 2.4125845 0.5736896 0.8943507 #>  [631] 0.8943507 0.8943507 0.8943507 0.8943507 0.8943507 0.8943507 0.7269022 #>  [638] 0.7269022 0.7269022 0.7269022 0.7269022 0.7269022 0.7269022 1.3065507 #>  [645] 1.3065507 0.8418764 0.8418764 1.5854552 1.5854552 1.5854552 1.5854552 #>  [652] 0.8957639 2.0653740 2.0653740 2.0653740 0.6542789 0.6036711 1.9655329 #>  [659] 1.6131694 0.9295025 0.9295025 0.9295025 0.9295025 0.6401375 0.6401375 #>  [666] 0.6401375 0.6401375 1.0784879 1.6611734 0.9600054 0.9600054 0.9600054 #>  [673] 0.9600054 0.3114452 1.6064373 1.7976776 2.4209986 2.4209986 3.7612037 #>  [680] 1.5952922 1.8846399 1.1210197 1.1210197 1.4331690 1.4331690 1.1177092 #>  [687] 0.7402034 0.6015464 0.7358601 0.7358601 1.0081763 1.0081763 1.0081763 #>  [694] 0.8453682 0.7813113 0.7813113 1.3216321 1.3216321 1.3216321 1.3216321 #>  [701] 2.9265027 0.4777862 0.4777862 1.6629136 1.6629136 1.6629136 3.0337890 #>  [708] 1.4052068 1.4052068 1.4052068 1.4052068 1.2251830 1.1574348 1.1574348 #>  [715] 1.1574348 0.6962098 0.6962098 0.6962098 0.7633997 0.7633997 0.7633997 #>  [722] 0.7633997 0.7633997 0.7633997 1.3614783 1.0303941 1.0303941 1.0303941 #>  [729] 1.0303941 1.3537561 1.3537561 1.1213087 1.1213087 1.5290397 1.7725902 #>  [736] 2.1845588 2.1845588 1.0870751 0.3615300 0.3503918 1.1973997 1.1973997 #>  [743] 1.1973997 1.1973997 0.6432236 0.5946854 0.5946854 0.5946854 1.1329492 #>  [750] 0.8090207 0.3238592 0.3238592 0.3238592 1.2061160 2.3077632 2.3077632 #>  [757] 0.8093498 0.8093498 0.8093498 0.8418299 0.8418299 0.8418299 0.8418299 #>  [764] 0.8418299 0.9114623 0.9114623 0.9114623 0.9114623 0.4550360 0.2513750 #>  [771] 0.3923465 0.3923465 0.3923465 1.6857630 0.9357495 2.0458551 2.0458551 #>  [778] 1.5442036 1.0977653 1.0977653 1.0977653 1.0977653 1.0893399 1.0893399 #>  [785] 1.0893399 0.5271179 0.5271179 0.5271179 0.5271179 1.0890561 1.5311002 #>  [792] 1.5311002 1.5311002 0.7675845 0.7057522 0.7057522 0.7057522 0.7057522 #>  [799] 0.7057522 1.1578293 1.1578293 1.1578293 1.1578293 1.1578293 1.1578293 #>  [806] 1.4950517 1.7900194 1.7900194 1.7900194 1.7900194 1.4450164 1.4450164 #>  [813] 1.4450164 0.8871791 0.3559716 0.3559716 1.5590592 1.7143228 1.0595790 #>  [820] 1.0595790 1.0595790 1.0595790 1.1324365 0.8793623 0.8089722 0.5199665 #>  [827] 0.5199665 0.5199665 1.6554088 1.6554088 1.6554088 2.3278583 2.3278583 #>  [834] 1.8904543 1.8904543 0.8849684 0.8849684 0.8849684 0.8849684 0.8849684 #>  [841] 0.8849684 1.3578319 1.3578319 1.3578319 1.3578319 2.1665412 2.1665412 #>  [848] 2.1665412 2.1665412 2.1665412 0.7046615 0.8855653 0.5329842 3.0919993 #>  [855] 1.7653255 1.0129461 1.1094573 1.1094573 1.1094573 0.9840926 0.9840926 #>  [862] 0.9840926 0.9840926 1.5358785 1.3811004 0.8779388 0.8779388 0.6800666 #>  [869] 0.6800666 0.6800666 0.6800666 0.6800666 0.6800666 1.7961764 1.7961764 #>  [876] 1.7961764 1.7961764 1.7961764 1.0297004 1.0297004 1.0297004 1.0297004 #>  [883] 1.0297004 1.0297004 1.0297004 1.0297004 1.0297004 0.4210301 0.4210301 #>  [890] 1.7876617 1.0176547 1.3469457 1.3469457 1.6611580 1.6611580 1.6611580 #>  [897] 1.7689635 2.0174539 2.0174539 0.5935830 0.5935830 0.5935830 0.9651182 #>  [904] 0.9651182 0.4954188 0.4954188 0.4954188 1.4090018 1.6350038 1.6350038 #>  [911] 0.4912705 1.0909482 1.0909482 1.0909482 1.0909482 1.0909482 2.0076852 #>  [918] 1.0058553 2.6618040 2.6618040 2.6618040 3.5018811 1.0360269 1.5977997 #>  [925] 1.0780575 0.8858628 0.8858628 0.8858628 0.5706113 1.3531284 0.7444972 #>  [932] 0.9365251 0.9365251 1.7607078 1.4094030 1.1031505 1.1031505 1.1031505 #>  [939] 0.4558631 0.4558631 0.8393236 1.0274098 1.0274098 1.7214128 0.9974613 #>  [946] 0.3729144 0.8970443 0.7215743 0.7583168 0.9723481 1.0331527 1.0331527 #>  [953] 1.2641121 1.2641121 1.4208547 1.4208547 1.4208547 0.9251036 0.5580332 #>  [960] 0.5580332 0.5580332 0.5580332 1.6005587 1.6005587 1.6005587 0.7916694 #>  [967] 0.7916694 0.7916694 0.4057507 1.6703389 1.6703389 0.9056517 1.3250526 #>  [974] 1.3250526 1.3250526 1.3250526 1.3250526 1.3250526 1.3250526 1.8791401 #>  [981] 1.8791401 0.6167979 0.7428526 0.7428526 0.5032659 1.8300508 1.8300508 #>  [988] 1.5825782 1.1519864 1.2828467 0.7858244 0.7858244 0.7858244 0.7858244 #>  [995] 1.1129055 1.1129055 1.9519654 0.7447867 2.4060396 2.1870168 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 2100 #>  #> Slot \"burnin\": #> [1] 100 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> [1,] 43.97979 44.41466 44.43972 44.11392 44.62213 45.16043 45.16812 45.21349 #> [2,] 43.15657 42.91989 43.51310 44.68803 44.56862 44.87953 44.94821 45.51928 #> [3,] 63.68104 63.29789 63.85898 64.05148 63.52357 64.10696 64.75609 65.32082 #> [4,] 50.45590 49.98192 49.94248 50.23495 50.54648 50.68016 51.02047 50.21193 #>          [,9]    [,10]    [,11]    [,12]    [,13] #> [1,] 45.17819 44.50411 44.97736 44.98087 45.22721 #> [2,] 45.87216 45.26223 45.42696 45.75288 45.95267 #> [3,] 65.62907 65.52253 66.59065 66.42558 66.77227 #> [4,] 50.02701 49.17010 49.01135 49.45278 49.73688 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -2.507907 0.03496807 #> [2,] -2.507907 0.03496807 #> [3,] -2.507907 0.03496807 #> [4,] -2.507907 0.03496807 #>  #> $delta #>            [,1]        [,2]       [,3]       [,4]      [,5]        [,6] #> [1,]  0.4348687  0.02505645 -0.3258029  0.5082169 0.5382963 0.007687938 #> [2,] -0.2366798  0.59321185  1.1749236 -0.1194105 0.3109172 0.068670722 #> [3,] -0.3831418  0.56109098  0.1924961 -0.5279107 0.5833939 0.649129673 #> [4,] -0.4739807 -0.03943816  0.2924624  0.3115307 0.1336790 0.340314130 #>             [,7]        [,8]       [,9]      [,10]        [,11]     [,12] #> [1,]  0.04537578 -0.03529845 -0.6740836  0.4732525  0.003504127 0.2463430 #> [2,]  0.57107036  0.35288467 -0.6099253  0.1647277  0.325915901 0.1997869 #> [3,]  0.56472919  0.30824406 -0.1065357  1.0681196 -0.165072414 0.3466892 #> [4,] -0.80854374 -0.18491804 -0.8569132 -0.1587477  0.441429357 0.2841035 #>  #> $precW #> [1] 0.0007380298 0.0009402290 0.0006374998 0.0006963610 #>  #> $rho #> [1] 0.1193680 0.1129187 0.2440825 0.1499421 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = diag(2),   ref_dose = 2,   use_log_dose = FALSE,   sigma2W = c(a = 1, b = 2),   rho = c(a = 1.5, b = 2.5),   E0 = 2,   Emax = 50,   delta1 = 6,   mode = 9,   ref_dose_beta = my_data@doseGrid[my_data@nGrid] + 10 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>      [,1]     [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [2,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [3,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [4,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -4.354759 0.09035452 #> [2,] -4.354759 0.09035452 #> [3,] -4.354759 0.09035452 #> [4,] -3.273111 0.08172139 #>  #> $precW #> [1] 0.0004229406 0.0004149886 0.0004264222 0.0003413195 #>  #> $rho #> [1] -0.5116824 -0.5902350 -0.5709147 -0.5230612 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  ##obtain mcmc DLE samples given the data, LogisticIndepBeta (DLE model) and mcmc simulations options ## data must be of 'Data' class data<-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(25,300,25)) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'LogisticIndepBeta' class model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## options must be ''McmcOptions' class options<-McmcOptions(burnin=100,step=2,samples=200) set.seed(94) samples<-mcmc(data=data,model=model,options=options) # nolint start ##obtain mcmc efficacy samples given the data, 'Effloglog' model (efficacy model) and ## mcmc simulations options data must be of 'DataDual' class data<-DataDual(x=c(25,50,25,50,75,300,250,150),               y=c(0,0,0,0,0,1,1,0),               w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),               doseGrid=seq(25,300,25),placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'Effloglog' class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data)  ## options must be ''McmcOptions' class options<-McmcOptions(burnin=100,step=2,samples=200) set.seed(94) samples<-mcmc(data=data,model=Effmodel,options=options) # nolint end ## obtain mcmc efficacy samples given the data, 'EffFlexi' model (efficacy model) and ## mcmc simulations options ## data must be of 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'EffFlexi' class  effmodel <- EffFlexi(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1), sigma2betaW = c(a = 20, b = 50), rw1 = FALSE, data = data )  ## options must be ''McmcOptions' class options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data = data, model = effmodel, options = options)"},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking minimum sizes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"minSize(...)  # S4 method for CohortSize minSize(...)"},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMin","code":""},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"minSize(CohortSize): method combining cohort size rules taking minimum","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/minSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the minimum of the sample sizes of # the single rules mySize <- minSize(mySize1, mySize2)"},{"path":"https://roche.github.io/crmPack/main/reference/multiplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple plot function — multiplot","title":"Multiple plot function — multiplot","text":"ggplot objects can passed ..., plotlist (list ggplot objects). layout something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE), plot 1 go upper left, 2 go upper right, 3 go way across bottom.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/multiplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple plot function — multiplot","text":"","code":"multiplot(..., plotlist = NULL, rows = 1, layout = NULL)"},{"path":"https://roche.github.io/crmPack/main/reference/multiplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple plot function — multiplot","text":"... Objects passed plotlist list additional objects rows Number rows layout layout matrix specifying layout. present, rows ignored.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/multiplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple plot function — multiplot","text":"Used side effect plotting","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBarplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience function to make barplots of percentages — myBarplot","title":"Convenience function to make barplots of percentages — myBarplot","text":"Convenience function make barplots percentages","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBarplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience function to make barplots of percentages — myBarplot","text":"","code":"myBarplot(x, description, xaxisround = 0)"},{"path":"https://roche.github.io/crmPack/main/reference/myBarplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience function to make barplots of percentages — myBarplot","text":"x vector samples description xlab string xaxisround rounding xaxis labels (default: 0, .e. integers used)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBarplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience function to make barplots of percentages — myBarplot","text":"ggplot2 object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBarplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convenience function to make barplots of percentages — myBarplot","text":"","code":"crmPack:::myBarplot(rpois(n=100, lambda=2),                      \"test\")"},{"path":"https://roche.github.io/crmPack/main/reference/myBayesLogit.html","id":null,"dir":"Reference","previous_headings":"","what":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"MCMC sampling Bayesian logistic regression model","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBayesLogit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"","code":"myBayesLogit(y, X, m0, P0, options)"},{"path":"https://roche.github.io/crmPack/main/reference/myBayesLogit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"y 0/1 vector responses X design matrix m0 prior mean vector P0 precision matrix options McmcOptions object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/myBayesLogit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"matrix samples (samples x parameters)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/names-Samples-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The Names of the Sampled Parameters — names,Samples-method","title":"The Names of the Sampled Parameters — names,Samples-method","text":"method returns names parameters sampled.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/names-Samples-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"# S4 method for Samples names(x)"},{"path":"https://roche.github.io/crmPack/main/reference/names-Samples-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Names of the Sampled Parameters — names,Samples-method","text":"x (Samples) object samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/names-Samples-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"my_samples <- Samples(   data = list(alpha = 1:5, beta = 15:19),   options = McmcOptions(burnin = 2, step = 2, samples = 5) )  names(my_samples) #> [1] \"alpha\" \"beta\""},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding the Next Best Dose — nextBest","title":"Finding the Next Best Dose — nextBest","text":"function computes recommended next best dose based corresponding rule nextBest, posterior samples model underlying data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding the Next Best Dose — nextBest","text":"","code":"nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for NextBestMTD,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRM,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRM,numeric,Samples,GeneralModel,DataParts nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestNCRMLoss,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestThreePlusThree,missing,missing,missing,Data nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for NextBestDualEndpoint,numeric,Samples,DualEndpoint,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestMinDist,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestInfTheory,numeric,Samples,GeneralModel,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestTD,numeric,missing,LogisticIndepBeta,Data nextBest(nextBest, doselimit = Inf, model, data, in_sim = FALSE, ...)  # S4 method for NextBestTDsamples,numeric,Samples,LogisticIndepBeta,Data nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for NextBestMaxGain,numeric,missing,ModelTox,DataDual nextBest(   nextBest,   doselimit = Inf,   model,   data,   model_eff,   in_sim = FALSE,   ... )  # S4 method for NextBestMaxGainSamples,numeric,Samples,ModelTox,DataDual nextBest(   nextBest,   doselimit = Inf,   samples,   model,   data,   model_eff,   samples_eff,   in_sim = FALSE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding the Next Best Dose — nextBest","text":"nextBest (NextBest) rule next best dose. doselimit (number) maximum allowed next dose. infinity (default), essentially dose limit applied course dose recommendation calculation. samples (Samples) posterior samples model parameters given data. model (ModelTox) DLT model. data (Data) data used generate samples. ... additional arguments without method dispatch. in_sim (flag) method used simulations? Default FALSE. flag TRUE target dose estimates (trial end--trial) outside dose grid range, information message printed method. model_eff (Effloglog EffFlexi) efficacy model. samples_eff (Samples) posterior samples model_eff parameters given data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding the Next Best Dose — nextBest","text":"list next best dose recommendation  (element named value) grid defined data, plot depicting recommendation (element named plot). case multiple plots also element named singlePlots included. singlePlots list single plots. additional list elements describing outcome rule can contained .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Finding the Next Best Dose — nextBest","text":"nextBest(   nextBest = NextBestMTD,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based MTD rule. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method. additional element probs output's list contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = DataParts ): find next best dose based NCRM method two parts trial used. nextBest(   nextBest = NextBestNCRMLoss,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method loss function. nextBest(   nextBest = NextBestThreePlusThree,   doselimit = missing,   samples = missing,   model = missing,   data = Data ): find next best dose based 3+3 method. nextBest(   nextBest = NextBestDualEndpoint,   doselimit = numeric,   samples = Samples,   model = DualEndpoint,   data = Data ): find next best dose based dual endpoint model. additional list element probs contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestMinDist,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives dose dose limit estimated DLT probability closest target dose. nextBest(   nextBest = NextBestInfTheory,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives appropriate dose within information theoretic framework. nextBest(   nextBest = NextBestTD,   doselimit = numeric,   samples = missing,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object without DLT samples. nextBest(   nextBest = NextBestTDsamples,   doselimit = numeric,   samples = Samples,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object involving DLT samples. nextBest(   nextBest = NextBestMaxGain,   doselimit = numeric,   samples = missing,   model = ModelTox,   data = DataDual ): find next best dose based pseudo DLT model ModelTox Effloglog efficacy model without samples. nextBest(   nextBest = NextBestMaxGainSamples,   doselimit = numeric,   samples = Samples,   model = ModelTox,   data = DataDual ): find next best dose based DLT efficacy responses DLT efficacy samples.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/nextBest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding the Next Best Dose — nextBest","text":"","code":"# Example of usage for `NextBestMTD` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestMTD' class. mtd_next_best <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = mtd_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Example of usage for `NextBestNCRM` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.002    0.000 #>  [2,]  0.5  0.008    0.002 #>  [3,]  1.5  0.042    0.002 #>  [4,]  3.0  0.062    0.024 #>  [5,]  6.0  0.104    0.048 #>  [6,] 10.0  0.160    0.106 #>  [7,] 12.0  0.188    0.116 #>  [8,] 14.0  0.212    0.140 #>  [9,] 16.0  0.236    0.160 #> [10,] 18.0  0.276    0.192 #> [11,] 20.0  0.294    0.210 #> [12,] 22.0  0.330    0.224 #> [13,] 24.0  0.336    0.256 #> [14,] 26.0  0.368    0.282 #> [15,] 28.0  0.396    0.292 #> [16,] 30.0  0.396    0.328 #> [17,] 32.0  0.344    0.404 #> [18,] 34.0  0.360    0.416 #> [19,] 36.0  0.322    0.478 #> [20,] 38.0  0.334    0.492 #> [21,] 40.0  0.326    0.524 #> [22,] 42.0  0.302    0.566 #> [23,] 44.0  0.302    0.578 #> [24,] 46.0  0.258    0.636 #> [25,] 48.0  0.256    0.644 #> [26,] 50.0  0.252    0.666 #> [27,] 52.0  0.252    0.674 #> [28,] 54.0  0.236    0.700 #> [29,] 56.0  0.228    0.716 #> [30,] 58.0  0.232    0.734 #> [31,] 60.0  0.210    0.756 #> [32,] 62.0  0.184    0.782 #> [33,] 64.0  0.170    0.798 #> [34,] 66.0  0.170    0.800 #> [35,] 68.0  0.168    0.802 #> [36,] 70.0  0.148    0.822 #> [37,] 72.0  0.134    0.836 #> [38,] 74.0  0.140    0.838 #> [39,] 76.0  0.126    0.852 #> [40,] 78.0  0.118    0.860 #> [41,] 80.0  0.120    0.860  # Example of usage for `NextBestNCRM-DataParts` NextBest class.  # Create the data. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation #> $value #> [1] 3 #>  #> $plot #> NULL #>   # Example of usage for `NextBestNCRMLoss` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class `NextBestNCRMLoss`. nrcm_loss_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.999,   losses = c(1, 0, 1, 2) )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_loss_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation$value #> [1] 16  # Look at the probabilities. dose_recommendation$probs #>     dose underdosing target excessive unacceptable        mean    std_dev #> 0.1  0.1       1.000  0.000     0.000        0.000 0.007030103 0.01527898 #> 0.5  0.5       1.000  0.000     0.000        0.000 0.018545404 0.02884978 #> 1.5  1.5       0.982  0.018     0.000        0.000 0.038744137 0.04792212 #> 3    3.0       0.948  0.048     0.004        0.000 0.063569818 0.06655022 #> 6    6.0       0.832  0.154     0.014        0.000 0.106501124 0.09102184 #> 10  10.0       0.698  0.238     0.060        0.004 0.157155543 0.11196908 #> 12  12.0       0.610  0.294     0.092        0.004 0.180609129 0.11969704 #> 14  14.0       0.554  0.330     0.112        0.004 0.203026775 0.12621387 #> 16  16.0       0.464  0.386     0.146        0.004 0.224492528 0.13179689 #> 18  18.0       0.392  0.390     0.206        0.012 0.245064837 0.13664254 #> 20  20.0       0.344  0.390     0.244        0.022 0.264788581 0.14089317 #> 22  22.0       0.320  0.360     0.284        0.036 0.283701395 0.14465356 #> 24  24.0       0.276  0.368     0.316        0.040 0.301837053 0.14800204 #> 26  26.0       0.236  0.360     0.360        0.044 0.319227279 0.15099812 #> 28  28.0       0.194  0.328     0.432        0.046 0.335902655 0.15368794 #> 30  30.0       0.154  0.354     0.436        0.056 0.351893029 0.15610815 #> 32  32.0       0.146  0.332     0.446        0.076 0.367227656 0.15828863 #> 34  34.0       0.136  0.330     0.442        0.092 0.381935195 0.16025440 #> 36  36.0       0.122  0.322     0.436        0.120 0.396043638 0.16202689 #> 38  38.0       0.100  0.278     0.500        0.122 0.409580229 0.16362479 #> 40  40.0       0.088  0.270     0.490        0.152 0.422571374 0.16506460 #> 42  42.0       0.078  0.232     0.510        0.180 0.435042574 0.16636106 #> 44  44.0       0.064  0.240     0.496        0.200 0.447018376 0.16752733 #> 46  46.0       0.058  0.218     0.502        0.222 0.458522342 0.16857522 #> 48  48.0       0.056  0.186     0.512        0.246 0.469577028 0.16951532 #> 50  50.0       0.056  0.168     0.500        0.276 0.480203986 0.17035714 #> 52  52.0       0.054  0.150     0.502        0.294 0.490423771 0.17110920 #> 54  54.0       0.054  0.132     0.516        0.298 0.500255959 0.17177917 #> 56  56.0       0.050  0.128     0.502        0.320 0.509719172 0.17237389 #> 58  58.0       0.050  0.116     0.510        0.324 0.518831103 0.17289955 #> 60  60.0       0.048  0.106     0.476        0.370 0.527608553 0.17336171 #> 62  62.0       0.046  0.104     0.436        0.414 0.536067460 0.17376540 #> 64  64.0       0.046  0.088     0.446        0.420 0.544222939 0.17411517 #> 66  66.0       0.036  0.096     0.442        0.426 0.552089312 0.17441516 #> 68  68.0       0.028  0.102     0.440        0.430 0.559680152 0.17466916 #> 70  70.0       0.026  0.102     0.422        0.450 0.567008311 0.17488062 #> 72  72.0       0.026  0.100     0.418        0.456 0.574085963 0.17505271 #> 74  74.0       0.022  0.090     0.408        0.480 0.580924632 0.17518838 #> 76  76.0       0.020  0.092     0.388        0.500 0.587535230 0.17529031 #> 78  78.0       0.020  0.086     0.384        0.510 0.593928088 0.17536101 #> 80  80.0       0.020  0.086     0.364        0.530 0.600112988 0.17540281 #>     posterior_loss #> 0.1          1.000 #> 0.5          1.000 #> 1.5          0.982 #> 3            0.952 #> 6            0.846 #> 10           0.766 #> 12           0.710 #> 14           0.674 #> 16           0.618 #> 18           0.622 #> 20           0.632 #> 22           0.676 #> 24           0.672 #> 26           0.684 #> 28           0.718 #> 30           0.702 #> 32           0.744 #> 34           0.762 #> 36           0.798 #> 38           0.844 #> 40           0.882 #> 42           0.948 #> 44           0.960 #> 46           1.004 #> 48           1.060 #> 50           1.108 #> 52           1.144 #> 54           1.166 #> 56           1.192 #> 58           1.208 #> 60           1.264 #> 62           1.310 #> 64           1.332 #> 66           1.330 #> 68           1.328 #> 70           1.348 #> 72           1.356 #> 74           1.390 #> 76           1.408 #> 78           1.424 #> 80           1.444  # Define another rule (loss function of 3 elements). nrcm_loss_next_best_losses_3 <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.30,   losses = c(1, 0, 2) )  # Calculate the next best dose. dose_recommendation_losses_3 <- nextBest(   nextBest = nrcm_loss_next_best_losses_3,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation_losses_3$value #> [1] 16  # Look at the probabilities. dose_recommendation_losses_3$probs #>     dose underdosing target overdose        mean    std_dev posterior_loss #> 0.1  0.1       1.000  0.000    0.000 0.007030103 0.01527898          1.000 #> 0.5  0.5       1.000  0.000    0.000 0.018545404 0.02884978          1.000 #> 1.5  1.5       0.982  0.018    0.000 0.038744137 0.04792212          0.982 #> 3    3.0       0.948  0.048    0.004 0.063569818 0.06655022          0.956 #> 6    6.0       0.832  0.154    0.014 0.106501124 0.09102184          0.860 #> 10  10.0       0.698  0.238    0.064 0.157155543 0.11196908          0.826 #> 12  12.0       0.610  0.294    0.096 0.180609129 0.11969704          0.802 #> 14  14.0       0.554  0.330    0.116 0.203026775 0.12621387          0.786 #> 16  16.0       0.464  0.386    0.150 0.224492528 0.13179689          0.764 #> 18  18.0       0.392  0.390    0.218 0.245064837 0.13664254          0.828 #> 20  20.0       0.344  0.390    0.266 0.264788581 0.14089317          0.876 #> 22  22.0       0.320  0.360    0.320 0.283701395 0.14465356          0.960 #> 24  24.0       0.276  0.368    0.356 0.301837053 0.14800204          0.988 #> 26  26.0       0.236  0.360    0.404 0.319227279 0.15099812          1.044 #> 28  28.0       0.194  0.328    0.478 0.335902655 0.15368794          1.150 #> 30  30.0       0.154  0.354    0.492 0.351893029 0.15610815          1.138 #> 32  32.0       0.146  0.332    0.522 0.367227656 0.15828863          1.190 #> 34  34.0       0.136  0.330    0.534 0.381935195 0.16025440          1.204 #> 36  36.0       0.122  0.322    0.556 0.396043638 0.16202689          1.234 #> 38  38.0       0.100  0.278    0.622 0.409580229 0.16362479          1.344 #> 40  40.0       0.088  0.270    0.642 0.422571374 0.16506460          1.372 #> 42  42.0       0.078  0.232    0.690 0.435042574 0.16636106          1.458 #> 44  44.0       0.064  0.240    0.696 0.447018376 0.16752733          1.456 #> 46  46.0       0.058  0.218    0.724 0.458522342 0.16857522          1.506 #> 48  48.0       0.056  0.186    0.758 0.469577028 0.16951532          1.572 #> 50  50.0       0.056  0.168    0.776 0.480203986 0.17035714          1.608 #> 52  52.0       0.054  0.150    0.796 0.490423771 0.17110920          1.646 #> 54  54.0       0.054  0.132    0.814 0.500255959 0.17177917          1.682 #> 56  56.0       0.050  0.128    0.822 0.509719172 0.17237389          1.694 #> 58  58.0       0.050  0.116    0.834 0.518831103 0.17289955          1.718 #> 60  60.0       0.048  0.106    0.846 0.527608553 0.17336171          1.740 #> 62  62.0       0.046  0.104    0.850 0.536067460 0.17376540          1.746 #> 64  64.0       0.046  0.088    0.866 0.544222939 0.17411517          1.778 #> 66  66.0       0.036  0.096    0.868 0.552089312 0.17441516          1.772 #> 68  68.0       0.028  0.102    0.870 0.559680152 0.17466916          1.768 #> 70  70.0       0.026  0.102    0.872 0.567008311 0.17488062          1.770 #> 72  72.0       0.026  0.100    0.874 0.574085963 0.17505271          1.774 #> 74  74.0       0.022  0.090    0.888 0.580924632 0.17518838          1.798 #> 76  76.0       0.020  0.092    0.888 0.587535230 0.17529031          1.796 #> 78  78.0       0.020  0.086    0.894 0.593928088 0.17536101          1.808 #> 80  80.0       0.020  0.086    0.894 0.600112988 0.17540281          1.808  # Example of usage for `NextBestThreePlusThree` NextBest class.  # Create the data. my_data <- Data(   x = c(5, 5, 5, 10, 10, 10),   y = c(0, 0, 0, 0, 1, 0),   ID = 1:6,   cohort = c(0, 0, 0, 1, 1, 1),   doseGrid = c(0.1, 0.5, 1.5, 3, 5, seq(from = 10, to = 80, by = 2)) )  # The rule to select the next best dose will be based on the 3+3 method. my_next_best <- NextBestThreePlusThree()  # Calculate the next best dose. dose_recommendation <- nextBest(my_next_best, data = my_data)  # Example of usage for `NextBestDualEndpoint` NextBest class.  # Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(1L, 2L, 3L, 4L, 5L, 6L, 6L, 6L, 7L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L),   w = c(     0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6, 0.52, 0.54,     0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose. In this case, # target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety). de_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = de_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.010    0.002 #>  [2,]  0.5  0.008    0.002 #>  [3,]  1.5  0.022    0.002 #>  [4,]  3.0  0.030    0.004 #>  [5,]  6.0  0.118    0.018 #>  [6,] 10.0  0.122    0.036 #>  [7,] 12.0  0.096    0.070 #>  [8,] 14.0  0.050    0.136 #>  [9,] 16.0  0.030    0.162 #> [10,] 18.0  0.030    0.258 #> [11,] 20.0  0.008    0.388 #> [12,] 22.0  0.036    0.528 #> [13,] 24.0  0.042    0.714 #> [14,] 26.0  0.024    0.790 #> [15,] 28.0  0.006    0.834 #> [16,] 30.0  0.016    0.912 #> [17,] 32.0  0.026    0.920 #> [18,] 34.0  0.010    0.940 #> [19,] 36.0  0.006    0.964 #> [20,] 38.0  0.000    0.998 #> [21,] 40.0  0.000    0.998 #> [22,] 42.0  0.000    0.998 #> [23,] 44.0  0.004    1.000 #> [24,] 46.0  0.002    1.000 #> [25,] 48.0  0.000    1.000 #> [26,] 50.0  0.000    1.000 #> [27,] 52.0  0.000    1.000 #> [28,] 54.0  0.004    1.000 #> [29,] 56.0  0.006    1.000 #> [30,] 58.0  0.012    1.000 #> [31,] 60.0  0.012    1.000 #> [32,] 62.0  0.018    1.000 #> [33,] 64.0  0.012    1.000 #> [34,] 66.0  0.030    1.000 #> [35,] 68.0  0.026    1.000 #> [36,] 70.0  0.018    1.000 #> [37,] 72.0  0.022    1.000 #> [38,] 74.0  0.024    1.000 #> [39,] 76.0  0.032    1.000 #> [40,] 78.0  0.042    1.000 #> [41,] 80.0  0.046    1.000  # Joint plot. print(dose_recommendation$plot)   # Show customization of single plot. variant1 <- dose_recommendation$singlePlots$plot1 + xlim(0, 20) print(variant1) #> Warning: Removed 31 rows containing missing values (`geom_bar()`). #> Warning: Removed 1 rows containing missing values (`geom_vline()`).   # Example of usage for `NextBestTD` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. td_next_best <- NextBestTD(prob_target_drt = 0.35, prob_target_eot = 0.3)  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = td_next_best,   doselimit = max(my_data@doseGrid),   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 50 dose_recommendation$plot   # Example of usage for `NextBestTDsamples` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Set-up some MCMC parameters and generate samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 800) my_samples <- mcmc(my_data, my_model, my_options)  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. # 'derive' is specified such that the 30% posterior quantile of the TD35 and # TD30 samples will be used as TD35 and TD30 estimates. tds_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = tds_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 25 dose_recommendation$plot   # Example of usage for `NextBestMaxGain` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   ID = 1:8,   cohort = 1:8,   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g. 'Effloglog'. my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and at the # end of trial are defined as 0.35 and 0.3, respectively. mg_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = mg_next_best,   doselimit = 300,   model = my_model_dlt,   model_eff = my_model_eff,   data = my_data )  dose_recommendation$next_dose #> [1] 75 dose_recommendation$plot   # Example of usage for `NextBestMaxGainSamples` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = 1:8,   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g 'Effloglog'. my_model_effll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples_dlt <- mcmc(my_data, my_model_dlt, my_options) my_samples_effll <- mcmc(my_data, my_model_effll, my_options)  # Target probabilities of the occurrence of a DLT during trial and at the end of # trial are defined as 0.35 and 0.3, respectively. # Use 30% posterior quantile of the TD35 and TD30 samples as estimates of TD35 # and TD30. # Use 50% posterior quantile of the Gstar (the dose which gives the maxim gain value) # samples as Gstar estimate. mgs_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effll,   samples_eff = my_samples_effll )  dose_recommendation$next_dose #> [1] 50 dose_recommendation$plot   # Now using the 'EffFlexi' class efficacy model:  my_model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_samples_effflexi <- mcmc(my_data, my_model_effflexi, my_options)  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effflexi,   samples_eff = my_samples_effflexi )  dose_recommendation$next_dose #> [1] 50 dose_recommendation$plot"},{"path":"https://roche.github.io/crmPack/main/reference/ngrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Doses in Grid — ngrid","title":"Number of Doses in Grid — ngrid","text":"function gets number doses grid. User can choose whether placebo dose () counted .","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ngrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Doses in Grid — ngrid","text":"","code":"ngrid(object, ignore_placebo = TRUE, ...)  # S4 method for Data ngrid(object, ignore_placebo = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/ngrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Doses in Grid — ngrid","text":"object (Data) object dose grid. ignore_placebo (flag) placebo dose () counted? ... arguments passed class-specific methods.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ngrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Doses in Grid — ngrid","text":"integer number doses grid.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/ngrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Doses in Grid — ngrid","text":"","code":"my_data <- Data(   x = c(10, 50, 90, 100, 0.001, 20, 30, 30),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(1L, 2L, 3L, 4L, 5L, 5L, 6L, 6L),   doseGrid = c(0.001, seq(from = 10, to = 100, by = 10)),   placebo = TRUE ) ngrid(my_data) #> [1] 10 ngrid(my_data, ignore_placebo = FALSE) #> [1] 11"},{"path":"https://roche.github.io/crmPack/main/reference/noOverlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Check overlap of two character vectors — noOverlap","title":"Check overlap of two character vectors — noOverlap","text":"Check overlap two character vectors","code":""},{"path":"https://roche.github.io/crmPack/main/reference/noOverlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check overlap of two character vectors — noOverlap","text":"","code":"noOverlap(a, b)"},{"path":"https://roche.github.io/crmPack/main/reference/noOverlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check overlap of two character vectors — noOverlap","text":"first character vector b second character vector","code":""},{"path":"https://roche.github.io/crmPack/main/reference/noOverlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check overlap of two character vectors — noOverlap","text":"returns TRUE overlap two character vectors, otherwise FALSE","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — or-Stopping-Stopping","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"method combining two atomic stopping rules","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"# S4 method for Stopping,Stopping |(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"## Example of combining two atomic stopping rules with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping <- myStopping1 | myStopping2"},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-StoppingAny.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"method combining stopping list atomic","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-StoppingAny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"# S4 method for StoppingAny,Stopping |(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-StoppingAny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"e1 StoppingAny object e2 Stopping object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-StoppingAny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"modified StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-Stopping-StoppingAny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 & myStopping2 ) | myStopping3"},{"path":"https://roche.github.io/crmPack/main/reference/or-StoppingAny-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"method combining atomic stopping list","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-StoppingAny-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"# S4 method for Stopping,StoppingAny |(e1, e2)"},{"path":"https://roche.github.io/crmPack/main/reference/or-StoppingAny-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"e1 Stopping object e2 StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-StoppingAny-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"modified StoppingAny object","code":""},{"path":"https://roche.github.io/crmPack/main/reference/or-StoppingAny-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5)  myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <-  myStopping3 | (myStopping1 & myStopping2 )"},{"path":"https://roche.github.io/crmPack/main/reference/pinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the distribution function of Inverse gamma distribution — pinvGamma","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"Compute distribution function Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/main/reference/pinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"","code":"pinvGamma(q, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/pinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"q vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). logical; FALSE (default) TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://roche.github.io/crmPack/main/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"Plot fitted dose-tox based given pseudo DLE model data without samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"# S4 method for Data,ModelTox plot(   x,   y,   xlab = \"Dose level\",   ylab = \"Probability of DLE\",   showLegend = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"x data Data class object y model ModelTox class object xlab x axis label ylab y axis label showLegend legend shown? (default) ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"returns ggplot object dose-DLE model plot","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"##plot the dose-DLE curve given a pseudo DLE model using data without samples ##data must be of 'Data' class  ##define the data  data<-Data(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(25,300,25)) #> Used default patient IDs! #> Used best guess cohort indices! ##model must be from 'ModelTox' class e.g 'LogisticIndepBeta' class model ##define the model (see LogisticIndepBeta example) model <-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## plot the dose-DLE curve ## 'x' is the data and 'y' is the model in plot plot(x=data,y=model)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the Data Class — plot,Data,missing-method","title":"Plot Method for the Data Class — plot,Data,missing-method","text":"method creates plot Data object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the Data Class — plot,Data,missing-method","text":"","code":"# S4 method for Data,missing plot(x, y, blind = FALSE, legend = TRUE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the Data Class — plot,Data,missing-method","text":"x (Data) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. legend (flag) whether legend added. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the Data Class — plot,Data,missing-method","text":"ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Data-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the Data Class — plot,Data,missing-method","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.001, 0.1, 0.1, 0.5, 0.001, 3, 3, 0.001, 10, 10, 10),   y = c(0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0),   cohort = c(1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 4),   doseGrid = c(0.001, 0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   placeb = TRUE ) #> Used default patient IDs!  # Plot the data. plot(my_data)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDA-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDA Class — plot,DataDA,missing-method","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"method creates plot DataDA object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDA-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# S4 method for DataDA,missing plot(x, y, blind = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDA-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"x (DataDA) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDA-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDA-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# Create some data of class 'DataDA'. my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"Plot fitted dose-efficacy based given pseudo efficacy model data without samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# S4 method for DataDual,ModelEff plot(   x,   y,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"x data DataDual class object y model ModelEff class object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"returns ggplot object dose-efficacy model plot","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# nolint start  ##plot the dose-efficacy curve given a pseudo efficacy model using data without samples ##data must be of 'DataDual' class ##define the data data<-DataDual(x=c(25,50,50,75,100,100,225,300),y=c(0,0,0,0,1,1,1,1),                w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                doseGrid=seq(25,300,25),placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##model must be from 'ModelEff' class e.g 'Effloglog' class model ##define the model (see Effloglog example) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ## plot the dose-efficacy curve ## 'x' is the data and 'y' is the model in plot plot(x=data,y=Effmodel)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDual Class — plot,DataDual,missing-method","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"method creates plot DataDual object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# S4 method for DataDual,missing plot(x, y, blind = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"x (DataDual) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"ggplot2 object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DataDual-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"plot method can applied DualSimulations objects order summarize graphically. addition standard plot types, sigma2W Plot boxplot final biomarker variance estimates simulated trials rho Plot boxplot final correlation estimates simulated trials","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# S4 method for DualSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2W\", \"rho\"), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"x DualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) myStopping <- myStopping4 | StoppingMinPatients(40)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = CohortSizeConst(3),                      startingDose = 3)  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function (dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))   dose <- dose/scal   e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100) }  trueTox <- function(dose) {   pnorm((dose-60)/10) }  # Draw the TRUE profiles par(mfrow=c(1, 2)) curve(trueTox(x), from=0, to=80) curve(trueBiomarker(x), from=0, to=80)  # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study ##Also for illustration purpose, we will use 5 burn-ins to generate 20 samples # this should be increased of course mySims <- simulate(design,                    trueTox=trueTox,                    trueBiomarker=trueBiomarker,                    sigma2W=0.01,                    rho=0,                    nsim=1,                    parallel=FALSE,                    seed=3,                    startingDose=6,                    mcmcOptions =                      McmcOptions(burnin=5,                                  step=1,                                  samples=20))  # Plot the results of the simulation print(plot(mySims))   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"plot method can applied DualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,SimulationsSummary,missing-method plus: meanBiomarkerFit Plot showing average fitted dose-biomarker curve across trials, together 95% credible intervals, comparison assumed truth (specified trueBiomarker argument summary,DualSimulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# S4 method for DualSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\",     \"meanBiomarkerFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"x DualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) # only 10 patients here for illustration! myStopping <- myStopping4 | StoppingMinPatients(10)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = CohortSizeConst(3),                      startingDose = 3)  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function (dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))   dose <- dose/scal   e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100) }  trueTox <- function(dose) {   pnorm((dose-60)/10) }  # Draw the TRUE profiles par(mfrow=c(1, 2)) curve(trueTox(x), from=0, to=80) curve(trueBiomarker(x), from=0, to=80)  # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study ##For illustration purpose we will use 5 burn-ins to generate 20 samples # this should be increased of course mySims <- simulate(design,                    trueTox=trueTox,                    trueBiomarker=trueBiomarker,                    sigma2W=0.01,                    rho=0,                    nsim=1,                    parallel=FALSE,                    seed=3,                    startingDose=6,                    mcmcOptions =                      McmcOptions(burnin=5,                                  step=1,                                  samples=20))  # Plot the summary of the Simulations plot(summary(mySims,              trueTox = trueTox,              trueBiomarker = trueBiomarker))   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,GeneralSimulations,missing-method","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# S4 method for GeneralSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\"), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"x GeneralSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"plot method can applied GeneralSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If only DLE responses are considered in the simulations  ##Specified your simulations when no DLE samples are used ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3)  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients=12) ##Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                    data=data,startingDose=25)  ##Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ##For illustration purpose only 1 simulation is produced (nsim=1). ##The simulations mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=1,                   seed=819,                   parallel=FALSE)   ##plot the simulations print(plot(mySim))     ##If DLE samples are involved ##The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ##specify the design design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25) ##options for MCMC ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # # ##plot the simulations # print(plot(mySim)) #  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"plot method can applied GeneralSimulationsSummary objects order summarize graphically. Possible types plots moment :","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"","code":"# S4 method for GeneralSimulationsSummary,missing plot(x, y, type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\"), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"x GeneralSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"nObs Distribution number patients simulated trials doseSelected Distribution final selected doses trials. Note can include zero entries, meaning trial stopped doses dose grid appeared toxic. propDLTs Distribution proportion patients DLTs trials nAboveTarget Distribution number patients treated doses target toxicity interval (specified truth target arguments summary,GeneralSimulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"plot method can applied PseudoDualFlexiSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses sigma2betaW variance random walk model can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# S4 method for PseudoDualFlexiSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\", \"sigma2betaW\"), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"x PseudoDualFlexiSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This plot method can be applied to PseudoDualFlexiSimulations\nobjects in order to summarize them graphically. Possible types of\nplots at the moment are: \ntrajectory\nSummary of the\ntrajectory of the simulated trials\n dosesTried\nAverage proportions of\nthe doses tested in patients\n sigma2\nThe variance of the efficacy responses\n\nsigma2betaW\nThe variance of the random walk model\n\n\nYou can specify one or both of these in the\ntype argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If DLE and efficacy responses are considered in the simulations data <- DataDual(doseGrid=seq(25,300,25)) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model must be of 'EffFlexi' class  Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)  ##The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36)   ##Specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff<- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,                0.9333009  ,1.0687031,  1.1793942 , 1.2726408 ,                1.3529598 , 1.4233411 , 1.4858613 , 1.5420182) ##The true gain curve can also be seen myTruthGain <- function(dose) {return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}   ##options for MCMC options<-McmcOptions(burnin=10,step=1,samples=20) ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). mySim<-simulate(object=design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueSigma2=0.025,                 trueSigma2betaW=1,                 mcmcOptions=options,                 nsim=1,                 seed=819,                 parallel=FALSE) #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA ##plot this simulated results print(plot(mySim)) #> Note: method with signature ‘PseudoSimulations#missing’ chosen for function ‘plot’, #>  target signature ‘PseudoDualSimulations#missing’. #>  \"GeneralSimulations#missing\" would also be valid #> Warning: Removed 1 rows containing non-finite values (`stat_boxplot()`).   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,PseudoDualSimulations,missing-method","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# S4 method for PseudoDualSimulations,missing plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\"), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"x PseudoDualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"plot method can applied PseudoDualSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses can specify one type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If DLE and efficacy responses are considered in the simulations ##Specified your simulations when no samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),                     nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  ##Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) ##Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## Then specified the simulations and generate the trial ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <-simulate(object=design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=1,                  seed=819,                  parallel=FALSE)  ##plot the simulation results print(plot(mySim)) #> Note: method with signature ‘PseudoSimulations#missing’ chosen for function ‘plot’, #>  target signature ‘PseudoDualSimulations#missing’. #>  \"GeneralSimulations#missing\" would also be valid  ##If DLE and efficacy samples are involved ##The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ##The design of 'DualResponsesSamplesDesign' class design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##options for MCMC options<-McmcOptions(burnin=10,step=1,samples=20) ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). mySim<-simulate(object=design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueNu=1/0.025,                 nsim=1,                 mcmcOptions=options,                 seed=819,                 parallel=FALSE) ##plot the simulation results print(plot(mySim))   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"plot method can applied PseudoDualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,PseudoSimulationsSummary,missing-method plus: can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# S4 method for PseudoDualSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\",     \"meanEffFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"x PseudoDualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# nolint start  ##obtain the plot of the summary for the simulation results ##If DLE and efficacy responses are considered in the simulations ##Specified your simulations when no samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300), nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 10 subjects are treated (for illustration) myStopping <- StoppingMinPatients(nPatients=10) ##Now specified the design with all the above information and starting with a dose of 25  ##Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) ##Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## Then specified the simulations and generate the trial ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <-simulate(object=design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=1,                  ## this would need to be increased in the real                  ## application:                  mcmcOptions=McmcOptions(burnin=10, step=1, samples=50),                  seed=819,                  parallel=FALSE)  ##Then produce a summary of your simulations MYSUM <- summary(mySim,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff)  ##Then plot the summary of the simulations print(plot(MYSUM))     ##If DLE and efficacy samples are involved ##Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details ##specified the next best mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ##specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##options for MCMC ##for illustration purpose we use 10 burn-in and generate 50 samples options<-McmcOptions(burnin=10,step=2,samples=50) ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). # mySim<-simulate(design, #                 args=NULL, #                 trueDLE=myTruthDLE, #                 trueEff=myTruthEff, #                 trueNu=1/0.025, #                 nsim=1, #                 mcmcOptions=options, #                 seed=819, #                 parallel=FALSE) # # ##Then produce a summary of your simulations # MYSUM <- summary(mySim, #                  trueDLE=myTruthDLE, #                  trueEff=myTruthEff) # # ##Then plot the summary of the simulations # print(plot(MYSUM))    ##OR if the 'EffFlexi' class is used ## for the efficacy model  Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)  ##Specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff<- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,                0.9333009  ,1.0687031,  1.1793942 , 1.2726408 ,                1.3529598 , 1.4233411 , 1.4858613 , 1.5420182) ##The true gain curve can also be seen myTruthGain <- function(dose) {return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}  ##The simulations # ##For illustration purpose only 1 simulation is produced (nsim=1). # mySim<-simulate(object=design, #                 args=NULL, #                 trueDLE=myTruthDLE, #                 trueEff=myTruthEff, #                 trueSigma2=0.025, #                 trueSigma2betaW=1, #                 nsim=1, #                 mcmcOptions=options, #                 seed=819, #                 parallel=FALSE) # ##Then produce a summary of your simulations # MYSUM <- summary(mySim, #                  trueDLE=myTruthDLE, #                  trueEff=myTruthEff) # # ##Then plot the summary of the simulations # print(plot(MYSUM))  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# S4 method for PseudoSimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"x PseudoSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"plot method can applied PseudoSimulationsSummary objects order summarize graphically. can used DLE responses involved simulations. also applied results without samples generated simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If only DLE responses are considered in the simulations ##Specified your simulations when no DLE samples are used ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3)  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients=12) ##Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                   data=data,startingDose=25)  ##Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ##For illustration purpose only 1 simulation is produced (nsim=1). ##The simulations mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=1,                   seed=819,                   parallel=FALSE)  ##Then produce a summary of your simulations MYSUM <- summary(mySim,                  truth=myTruth) ##plot the summary of the simulations print(plot(MYSUM))   ##If DLE samples are involved ##The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ##specify the design design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25) ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # ##Then produce a summary of your simulations # MYSUM <- summary(mySim, #                  truth=myTruth) # ##plot the summary of the simulations # print(plot(MYSUM))  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DALogisticLogNormal-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DALogisticLogNormal-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"","code":"# S4 method for Samples,DALogisticLogNormal plot(x, y, data, hazard = FALSE, ..., showLegend = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DALogisticLogNormal-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"x Samples object y DALogisticLogNormal object data DataDA object hazard see fitPEM explanation ... used showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DALogisticLogNormal-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DualEndpoint-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"dual endpoint model, also dose-biomarker fit shown plot","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DualEndpoint-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# S4 method for Samples,DualEndpoint plot(x, y, data, extrapolate = TRUE, showLegend = FALSE, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DualEndpoint-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"x Samples object y DualEndpoint object data DataDual object extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default) ... additional arguments parent method plot,Samples,GeneralModel-method","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DualEndpoint-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"returns ggplot object dose-toxicity dose-biomarker model fits","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-DualEndpoint-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# nolint start  # Create some data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses #grid.arrange(plot(x = samples, y = model, data = data))  plot(x = samples, y = model, data = data) #> Warning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in #> ggplot2 3.3.4. #> ℹ Please use \"none\" instead. #> ℹ The deprecated feature was likely used in the crmPack package. #>   Please report the issue at <https://github.com/roche/crmPack/issues>.   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-GeneralModel-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-GeneralModel-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# S4 method for Samples,GeneralModel plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-GeneralModel-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"x Samples object y GeneralModel object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-GeneralModel-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-GeneralModel-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# nolint start  # Create some data data <- Data(x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y = c(0, 0, 0, 0, 0, 0, 1, 0),              cohort = c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid = c(0.1, 0.5, 1.5, 3, 6,                           seq(from = 10, to = 80, by=2))) #> Used default patient IDs!  # Initialize a model  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 56)  # Get posterior for all model parameters options <- McmcOptions(burnin = 100,                        step = 2,                        samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses plot(x = samples, y = model, data = data)                 # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"Plot fitted dose-efficacy curve using model ModelEff class samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"","code":"# S4 method for Samples,ModelEff plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"x Samples object y ModelEff model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"returns ggplot object dose-efficacy model fit","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class\nwith samples — plot,Samples,ModelEff-method","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-efficacy curve with samples using the model from 'ModelEff' ##class e.g. 'Effloglog' class model ##define the model (see Effloglog example) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ## define the samples obtained using the 'Effloglog' model (see details in 'Samples' example) ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ## samples must be of 'Samples' class samples <- mcmc(data=data,model=Effmodel,options=options) ## plot the fitted dose-efficacy curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelEff' class plot(x=samples,y=Effmodel,data=data)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"Plot fitted dose-DLE curve using ModelTox class model samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"# S4 method for Samples,ModelTox plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"x Samples object y ModelTox model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"returns ggplot object dose-DLE model fit","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-Samples-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE curve with samples using the model from 'ModelTox'  ##class e.g. 'LogisticIndepBeta' class model ##define the model (see LogisticIndepBeta example) model <-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the samples obtained using the 'LogisticIndepGBeta' model   ##Define options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ## (see details in 'Samples' example) samples must be of 'Samples' class samples <- mcmc(data=data,model=model,options=options) ## plot the fitted dose-DLE curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelTox' class plot(x=samples,y=model,data=data)"},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# S4 method for SimulationsSummary,missing plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\"),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"x SimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gridExtra{gTree} object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"plot method can applied SimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,GeneralSimulationsSummary,missing-method plus: meanFit Plot showing average fitted dose-toxicity curve across trials, together 95% credible intervals, comparison assumed truth (specified truth argument summary,Simulations-method) can specify subset type argument.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot-SimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3)  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(burnin=10,                        step=1,                        samples=100) time <- system.time(mySims <- simulate(design,                                        args=NULL,                                        truth=myTruth,                                        nsim=1,                                        seed=819,                                        mcmcOptions=options,                                        parallel=FALSE))[3]  # Plot the Summary of the Simulations plot(summary(mySims,truth=myTruth))   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plot.gtable.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots gtable objects — plot.gtable","title":"Plots gtable objects — plot.gtable","text":"Plots gtable objects","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plot.gtable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots gtable objects — plot.gtable","text":"","code":"# S3 method for gtable plot(x, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plot.gtable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots gtable objects — plot.gtable","text":"x gtable object ... additional parameters grid.draw","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"Plot DLE efficacy curve side side given DLE pseudo model, DLE sample, efficacy pseudo model given efficacy sample Plot dose-DLE dose-efficacy curve side side given DLE pseudo model given pseudo efficacy model without DLE efficacy samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples plotDualResponses(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   extrapolate = TRUE,   showLegend = FALSE,   ... )  # S4 method for ModelTox,missing,ModelEff,missing plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"DLEmodel pseudo DLE model ModelTox class object DLEsamples DLE samples Samples class object Effmodel pseudo efficacy model ModelEff class object Effsamples Efficacy samples Samples class object data data input DataDual class object ... additional arguments parent method plot,Samples,GeneralModel-method extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"returns ggplot object dose-toxicity dose-efficacy model fits","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): function still documented plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Plot DLE efficacy curve side side given DLE model efficacy model without samples","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotDualResponses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model,\na DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices! ##Specify the options for MCMC options <- McmcOptions(burnin=100,step=2,samples=1000)   DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data=data,model=Effmodel,options=options) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. ##For each curve the 95% credibility interval of the two samples are alos given plotDualResponses(DLEmodel=DLEmodel,DLEsamples=DLEsamples,          Effmodel=Effmodel,Effsamples=Effsamples,          data=data)  # nolint end # nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots without DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. plotDualResponses(DLEmodel=DLEmodel,                   Effmodel=Effmodel,                   data=data)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, DLE sample, given efficacy pseudo model efficacy sample Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, given efficacy pseudo model","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,Samples,ModelEff,Samples plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for ModelTox,missing,ModelEff,missing plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"DLEmodel dose-DLE model ModelTox class object DLEsamples DLE sample Samples class object Effmodel dose-efficacy model ModelEff class object Effsamples efficacy sample Samples class object data data input DataDual class object ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"returns ggplot object plot","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"plotGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): Standard method plotGain(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Standard method","code":""},{"path":"https://roche.github.io/crmPack/main/reference/plotGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model,\na DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data,const=0) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x=data@x,y=data@y,doseGrid=data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  ##Define the options for MCMC options <- McmcOptions(burnin=100,step=2,samples=1000)   DLEsamples <- mcmc(data=data1,model=DLEmodel,options=options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data=data,model=Effmodel,options=options) ##plot the three curves of mean values of the DLEsamples, Effsamples and ##gain value samples (obtained within this plotGain function) at all dose levels plotGain(DLEmodel=DLEmodel,DLEsamples=DLEsamples,          Effmodel=Effmodel,Effsamples=Effsamples,          data=data)  # nolint end # nolint start ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##plot the three curves of using modal estimates of model parameters at all dose levels plotGain(DLEmodel=DLEmodel,          Effmodel=Effmodel,          data=data)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/positive_number.html","id":null,"dir":"Reference","previous_headings":"","what":"positive_number — positive_number","title":"positive_number — positive_number","text":"positive_number class class store NULL, non NA, finite strictly positive numerical value. mainly used store reference dose value model classes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/printVignette.html","id":null,"dir":"Reference","previous_headings":"","what":"Taken from utils package (print.vignette) — printVignette","title":"Taken from utils package (print.vignette) — printVignette","text":"Taken utils package (print.vignette)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/printVignette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Taken from utils package (print.vignette) — printVignette","text":"","code":"printVignette(x, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"function computes probability occurrence DLE specified dose level, based model parameters (samples).","code":""},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"prob(dose, model, samples, ...)  # S4 method for numeric,LogisticNormal,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormal,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormalSub,Samples prob(dose, model, samples)  # S4 method for numeric,ProbitLogNormal,Samples prob(dose, model, samples)  # S4 method for numeric,ProbitLogNormalRel,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticKadane,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticKadaneBetaGamma,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticNormalMixture,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticNormalFixedMixture,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticLogNormalMixture,Samples prob(dose, model, samples)  # S4 method for numeric,DualEndpoint,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticIndepBeta,Samples prob(dose, model, samples)  # S4 method for numeric,LogisticIndepBeta,missing prob(dose, model)  # S4 method for numeric,OneParLogNormalPrior,Samples prob(dose, model, samples)  # S4 method for numeric,OneParExpPrior,Samples prob(dose, model, samples)"},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (GeneralModel ModelTox) model single agent dose escalation pseudo DLE (dose-limiting events)/toxicity model. samples (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. ... model specific parameters samples used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"proportion numeric vector toxicity probabilities. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() function computes probability toxicity given doses, using samples model parameter(s). work multivariate model parameters, assume model specific prob() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob(dose = numeric, model = LogisticNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormalSub, samples = Samples): prob(dose = numeric, model = ProbitLogNormal, samples = Samples): prob(dose = numeric, model = ProbitLogNormalRel, samples = Samples): prob(dose = numeric, model = LogisticKadane, samples = Samples): prob(dose = numeric, model = LogisticKadaneBetaGamma, samples = Samples): prob(dose = numeric, model = LogisticNormalMixture, samples = Samples): prob(dose = numeric, model = LogisticNormalFixedMixture, samples = Samples): prob(dose = numeric, model = LogisticLogNormalMixture, samples = Samples): prob(dose = numeric, model = DualEndpoint, samples = Samples): prob(dose = numeric, model = LogisticIndepBeta, samples = Samples): compute toxicity probabilities occurrence DLE specified dose level, based samples LogisticIndepBeta model parameters. prob(dose = numeric, model = LogisticIndepBeta, samples = missing): compute toxicity probabilities occurrence DLE specified dose level, based LogisticIndepBeta model parameters. model parameters (except dose) present model object. prob(dose = numeric, model = OneParLogNormalPrior, samples = Samples): prob(dose = numeric, model = OneParExpPrior, samples = Samples):","code":""},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() dose() functions inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for Prob(DLT | dose = 50). prob(dose = 50, model = my_model, samples = my_samples) #>  [1] 0.2999346 0.4184049 0.4184049 0.2963670 0.2690001 0.7312229 0.7312229 #>  [8] 0.7312229 0.7312229 0.7312229 0.7312229 0.5797670 0.5797670 0.5797670 #> [15] 0.3857958 0.3857958 0.3857958 0.5564022 0.5564022 0.5564022  # Create data from the 'DataDual' class. data_dual <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data_dual )  # Get samples from posterior. dlt_sample <- mcmc(data = data_dual, model = dlt_model, options = my_options)  # Posterior for Prob(DLT | dose = 100). prob(dose = 100, model = dlt_model, samples = dlt_sample) #>  [1] 0.3331095 0.3331095 0.3331095 0.3331095 0.3780942 0.3780942 0.4100337 #>  [8] 0.4100337 0.4100337 0.4100337 0.4070378 0.4070378 0.4070378 0.4070378 #> [15] 0.4070378 0.4070378 0.4070378 0.5868325 0.6399562 0.1724915 prob(dose = c(50, 150), model = dlt_model) #> [1] 0.1981823 0.4601234"},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Prob Function for a Given Model Type — probFunction","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"function returns prob() function computes toxicity probabilities given dose level, based model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"probFunction(model, ...)  # S4 method for GeneralModel probFunction(model, ...)  # S4 method for ModelTox probFunction(model, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"model (GeneralModel ModelTox) model. ... model specific parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"prob() function computes toxicity probabilities.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"probFunction(GeneralModel): probFunction(ModelTox):","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/reference/probFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  prob_fun <- probFunction(my_model, alpha0 = 2, alpha1 = 3) prob_fun(30) #> [1] 0.6147973"},{"path":"https://roche.github.io/crmPack/main/reference/probit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for probit function — probit","title":"Shorthand for probit function — probit","text":"Shorthand probit function","code":""},{"path":"https://roche.github.io/crmPack/main/reference/probit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for probit function — probit","text":"","code":"probit(x)"},{"path":"https://roche.github.io/crmPack/main/reference/probit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for probit function — probit","text":"x function argument","code":""},{"path":"https://roche.github.io/crmPack/main/reference/probit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for probit function — probit","text":"probit(x)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/qinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the quantile function of Inverse gamma distribution — qinvGamma","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"Compute quantile function Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/main/reference/qinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"","code":"qinvGamma(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://roche.github.io/crmPack/main/reference/qinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"p vector probabilities shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). logical; FALSE (default) TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/rinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"The random generation of the Inverse gamma distribution — rinvGamma","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"random generation Inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/main/reference/rinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"","code":"rinvGamma(n, a, b)"},{"path":"https://roche.github.io/crmPack/main/reference/rinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"n number observations shape parameter inverse gamma distribution b scale parameter inverse gamma distribution","code":""},{"path":"https://roche.github.io/crmPack/main/reference/safeInteger.html","id":null,"dir":"Reference","previous_headings":"","what":"Safe conversion to integer vector — safeInteger","title":"Safe conversion to integer vector — safeInteger","text":"Safe conversion integer vector","code":""},{"path":"https://roche.github.io/crmPack/main/reference/safeInteger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safe conversion to integer vector — safeInteger","text":"","code":"safeInteger(x)"},{"path":"https://roche.github.io/crmPack/main/reference/safeInteger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safe conversion to integer vector — safeInteger","text":"x numeric vector","code":""},{"path":"https://roche.github.io/crmPack/main/reference/safeInteger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safe conversion to integer vector — safeInteger","text":"integer vector","code":""},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Determining if this Sample Should be Saved — saveSample","title":"Determining if this Sample Should be Saved — saveSample","text":"method determines sample given iteration saved. sample saved : burn-period matches step.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"saveSample(object, iteration, ...)  # S4 method for McmcOptions saveSample(object, iteration, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determining if this Sample Should be Saved — saveSample","text":"object (McmcOptions) object based answer determined. iteration (count) current iteration index. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determining if this Sample Should be Saved — saveSample","text":"TRUE sample saved.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determining if this Sample Should be Saved — saveSample","text":"saveSample(McmcOptions): determine sample saved.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/saveSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 saveSample(my_options, iteration = 5) #> [1] FALSE"},{"path":"https://roche.github.io/crmPack/main/reference/setSeed.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to set and save the RNG seed — setSeed","title":"Helper function to set and save the RNG seed — setSeed","text":"basically copied simulate.lm","code":""},{"path":"https://roche.github.io/crmPack/main/reference/setSeed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to set and save the RNG seed — setSeed","text":"","code":"setSeed(seed = NULL)"},{"path":"https://roche.github.io/crmPack/main/reference/setSeed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to set and save the RNG seed — setSeed","text":"seed object specifying random number generator initialized (“seeded”). Either NULL (default) integer used call set.seed simulating response vectors. set, value saved seed slot returned object. default, NULL change random generator state.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/setSeed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to set and save the RNG seed — setSeed","text":"RNGstate returned, order call function input reproduce obtained simulation results","code":""},{"path":"https://roche.github.io/crmPack/main/reference/setSeed.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Helper function to set and save the RNG seed — setSeed","text":"Daniel Sabanes Bove sabanesd@roche.com","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-DualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"Show summary dual-endpoint simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-DualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# S4 method for DualSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/main/reference/show-DualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"object DualSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-DualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-DualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 30))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) # small number of patients just for illustration here myStopping <- myStopping4 | StoppingMinPatients(10)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = CohortSizeConst(3),                      startingDose = 3)  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function (dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))   dose <- dose/scal   e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100) }  trueTox <- function(dose) {   pnorm((dose-60)/10) }  # Draw the TRUE profiles par(mfrow=c(1, 2)) curve(trueTox(x), from=0, to=80) curve(trueBiomarker(x), from=0, to=80)   # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # Also for illustration purpose, we will use 5 burn-ins to generate 20 samples # this should be increased of course mySims <- simulate(design,                    trueTox=trueTox,                    trueBiomarker=trueBiomarker,                    sigma2W=0.01,                    rho=0,                    nsim=1,                    parallel=FALSE,                    seed=3,                    startingDose=6,                    mcmcOptions =                      McmcOptions(burnin=5,                                  step=1,                                  samples=20))  # Show the summary of the Simulations show(summary(mySims,              trueTox = trueTox,              trueBiomarker = trueBiomarker)) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was NA, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 1 (1, 1)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 1  #> Observed toxicity rate at dose most often selected: 0 % #> Fitted toxicity rate at dose most often selected : mean 6 % (6 %, 6 %)  #> Fitted biomarker level at dose most often selected : mean 0.2 (0.2, 0.2)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/show-GeneralSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-GeneralSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"","code":"# S4 method for GeneralSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/main/reference/show-GeneralSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"object GeneralSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-GeneralSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoDualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"Show summary Pseudo Dual simulations summary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# S4 method for PseudoDualSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoDualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"object PseudoDualSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoDualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# nolint start  ##If DLE and efficacy responses are considered in the simulations ##Specified your simulations when no samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),                     nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  ##Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) ##Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## Then specified the simulations and generate the trial ##For illustration purpose only 2 simulation is produced (nsim=2). mySim <-simulate(object=design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=2,                  seed=819,                  parallel=FALSE) ##Then produce a summary of your simulations MYSUM <- summary(mySim,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff) ##Then show the summary in data frame for your simulations show(MYSUM) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)      ##If DLE and efficacy samples are involved ##The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } ) ##The design of 'DualResponsesSamplesDesign' class design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##options for MCMC ##for illustration purpose, we will use 50 burn-ins to generate 200 samples options<-McmcOptions(burnin=50,step=2,samples=200) ##The simulations for illustration purpose we only simulate 2 trials (nsim=2) mySim<-simulate(design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueNu=1/0.025,                 nsim=2,                 mcmcOptions=options,                 seed=819,                 parallel=FALSE)   ##Then produce a summary of your simulations MYSUM <- summary(mySim,                  trueDLE=myTruthDLE,                 trueEff=myTruthEff) ##Then show the summary in data frame for your simulations show(MYSUM) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2045 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# S4 method for PseudoSimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"object PseudoSimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-PseudoSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If only DLE responses are considered in the simulations ##Specified your simulations when no DLE samples are used data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3)  ##Then the starting data, an empty data set emptydata<-Data(doseGrid=seq(25,300,25)) ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36)   ##Specified the design(for details please refer to the 'TDDesign' example) design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                    data=data,startingDose=25)  # Specify the truth of the DLE responses. myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=1,                   seed=819,                   parallel=FALSE) ##Then produce a summary of your simulations MYSUM <- summary(mySim,                  truth=myTruth) ##show the summary of the simulated results in a data frame show(MYSUM) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>     ##If DLE samples are involved ##The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ##The design design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25) ##Options for MCMC ##For illustration purpose, we will use 50 burn-ins to generate 200 samples and ##only simulate for 2 trials (nsim=2) options<-McmcOptions(burnin=50,step=2,samples=200) ##The simualtions mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=2,                   seed=819,                   mcmcOptions=options,                   parallel=FALSE) ##Then produce a summary of your simulations MYSUM <- summary(mySim,          truth=myTruth) ##show the summary of the simulated results in a data frame show(MYSUM) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/show-SimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,SimulationsSummary-method","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-SimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# S4 method for SimulationsSummary show(object)"},{"path":"https://roche.github.io/crmPack/main/reference/show-SimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"object SimulationsSummary object want print","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-SimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://roche.github.io/crmPack/main/reference/show-SimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3)  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course options <- McmcOptions(burnin=100,                        step=2,                        samples=1000) time <- system.time(mySims <- simulate(design,                                        args=NULL,                                        truth=myTruth,                                        nsim=1,                                        seed=819,                                        mcmcOptions=options,                                        parallel=FALSE))[3]  # Show the Summary of the Simulations show(summary(mySims,truth=myTruth)) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 16 (16, 16)  #> Number of patients treated above target tox interval : mean 9 (9, 9)  #> Proportions of DLTs in the trials : mean 38 % (38 %, 38 %)  #> Mean toxicity risks for the patients on active : mean 41 % (41 %, 41 %)  #> Doses selected as MTD : mean 15 (15, 15)  #> True toxicity at doses selected : mean 3 % (3 %, 3 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 15  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 27 % (27 %, 27 %)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DADesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"Simulate outcomes time--DLT augmented CRM design (DADesign)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DADesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# S4 method for DADesign simulate(   object,   nsim = 1L,   seed = NULL,   truthTox,   truthSurv,   trueTmax = NULL,   args = NULL,   firstSeparate = FALSE,   deescalate = TRUE,   mcmcOptions = McmcOptions(),   DA = TRUE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DADesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object DADesign object want simulate data nsim number simulations (default: 1) seed see setSeed truthTox function takes input dose (vector) returns true probability (vector) toxicity time DLT occurs. Additional arguments can supplied args. truthSurv CDF takes input time (vector) returns true cumulative probability (vector) DLT occur conditioning patient DLTs. trueTmax add documentation args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. deescalate deescalation DLT occurs cohorts lower dose level. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used. DA document rename parameter make meaningful parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine (maximum 5) ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DADesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object class Simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DADesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(doseGrid=c(0.1, 0.5,1, 1.5, 3, 6,                                seq(from=10, to=80, by=2)),Tmax=60) # Initialize the mDA-CRM model npiece_=10 Tmax_=60  lambda_prior<-function(k){   npiece_/(Tmax_*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2) # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0,20),                                    increments=c(1,0.33)) # Choose the rule for selecting the next dose nextMaxDose <- maxDose(myIncrements,data=emptydata)  myNextBest <- NextBestNCRM(target=c(0.2,0.35),                            overdose=c(0.35,1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping2 <- StoppingMinPatients(nPatients=50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow=SafetyWindowConst(c(6,2),7,7)  # Initialize the design design <- DADesign(model=model,                    increments=myIncrements,                    nextBest=myNextBest,                    stopping=myStopping,                    cohortSize=mySize,                    data=emptydata,                    safetyWindow=mysafetywindow,                    startingDose=3)  ## set up truth curves myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from=0, to=100, ylim=c(0, 1))   onset <- 15 exp_cond.cdf<-function(x){   1-(pexp(x,1/onset,lower.tail=FALSE)-pexp(28,1/onset,lower.tail=FALSE))/pexp(28,1/onset) }  #set up simulation settings options <- McmcOptions(burnin=100,                        step=1,                        samples=2000)  mySims <- simulate(design,                    args=NULL,                    truthTox=myTruth,                    truthSurv=exp_cond.cdf,#piece_exp_cond.cdf,                    trueTmax=80,                    nsim=2,                    seed=819,                    mcmcOptions=options,                    firstSeparate=TRUE,                    deescalate=FALSE,                    parallel=TRUE,                    nCores=2)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-Design-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a CRM design — simulate,Design-method","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"Simulate outcomes CRM design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-Design-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# S4 method for Design simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-Design-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object Design object want simulate data nsim number simulations (default: 1) seed see setSeed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-Design-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object class Simulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-Design-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3)  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(burnin=100,                        step=1,                        samples=2000) time <- system.time(mySims <- simulate(design,                                        args=NULL,                                        truth=myTruth,                                        nsim=1,                                        seed=819,                                        mcmcOptions=options,                                        parallel=FALSE))[3]  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"Simulate outcomes dual-endpoint design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# S4 method for DualDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueTox,   trueBiomarker,   args = NULL,   sigma2W,   rho = 0,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object DualDesign object want simulate data nsim number simulations (default: 1) seed see setSeed trueTox function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). Additional arguments can supplied args. args data frame arguments trueTox trueBiomarker function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. sigma2W variance biomarker measurements rho correlation toxicity biomarker measurements (default: 0) firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object class DualSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         use_log_dose=TRUE,                         ref_dose=2,                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) myStopping <- myStopping4 | StoppingMinPatients(10)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = mySize,                      startingDose = 3)  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function (dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))   dose <- dose/scal   e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100) }  trueTox <- function(dose) {   pnorm((dose-60)/10) }  # Draw the TRUE profiles par(mfrow=c(1, 2)) curve(trueTox(x), from=0, to=80) curve(trueBiomarker(x), from=0, to=80)   # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course, similarly for the McmcOptions - # they also need to be increased. mySims <- simulate(design,                    trueTox=trueTox,                    trueBiomarker=trueBiomarker,                    sigma2W=0.01,                    rho=0,                    nsim=1,                    parallel=FALSE,                    seed=3,                    startingDose=6,                    mcmcOptions =                      McmcOptions(burnin=100,                                  step=1,                                  samples=300))  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object. addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"","code":"# S4 method for DualResponsesDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"object DualResponsesDesign object want simulate data nsim number simulations (default :1) seed see setSeed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu precision, inverse variance efficacy responses args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"object class PseudoDualSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesDesign where DLEmodel used are of\nModelTox class object and efficacy model used are of ModelEff\nclass object. In addition, no DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesDesign-method","text":"","code":"# nolint start  ##Simulate dose-escalation procedure based on DLE and efficacy responses where no DLE ## and efficacy samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),                     nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  ##Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) ##Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ##The true gain curve can also be seen myTruthGain <- function(dose) {return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}   ## Then specified the simulations and generate the trial ##For illustration purpose only 1 simulation is produced (nsim=1). options<-McmcOptions(burnin=100,step=2,samples=200) mySim <-simulate(object=design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=1,                  seed=819,                  parallel=FALSE)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesSamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesSamplesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object (special case EffFlexi class model object). addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"","code":"# S4 method for DualResponsesSamplesDesign simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu = NULL,   trueSigma2 = NULL,   trueSigma2betaW = NULL,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesSamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"object DualResponsesSamplesDesign object want simulate data nsim number simulations (default :1) seed see setSeed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu (codeEffFlexi) precision, inverse variance efficacy responses trueSigma2 (codeEffFlexi) true variance efficacy responses must single positive scalar. trueSigma2betaW (codeEffFlexi) true variance random walk model used smoothing. must single positive scalar. args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesSamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"object class PseudoDualSimulations PseudoDualFlexiSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses.\nThis is a method based on the DualResponsesSamplesDesign where DLEmodel\nused are of\nModelTox class object and efficacy model used are of\nModelEff\nclass object (special case is EffFlexi class model object).\nIn addition, DLE and efficacy samples are involved or generated in the simulation\nprocess — simulate,DualResponsesSamplesDesign-method","text":"","code":"# nolint start  ##Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used data <- DataDual(doseGrid=seq(25,300,25),placebo=FALSE) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),                     nu=c(a=1,b=0.025),data=data)   ##The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 10 subjects are treated (only for illustration such a low ##sample size) myStopping <- StoppingMinPatients(nPatients=10) ##Now specified the design with all the above information and starting with ##a dose of 25   ##Specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##specified the true DLE and efficacy curve myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ##The true gain curve can also be seen myTruthGain <- function(dose) {return((myTruthEff(dose))/(1+(myTruthDLE(dose)/(1-myTruthDLE(dose)))))}  ##simulate the trial for 10 times involving samples ##for illustration purpose we use 10 burn-ins to generate 50 samples options<-McmcOptions(burnin=10,step=1,samples=50) ##For illustration purpose only 1 simulations are produced (nsim=1). mySim<-simulate(design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=1,                  mcmcOptions=options,                  seed=819,                  parallel=FALSE)    ##Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used ## when the efficacy model is of 'EffFlexi' class Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)   ##Specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff<- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,                0.9333009  ,1.0687031,  1.1793942 , 1.2726408 ,                1.3529598 , 1.4233411 , 1.4858613 , 1.5420182) ##The true gain curve can also be seen d1 <- data@doseGrid myTruthGain <- (myTruthEff)/(1+(myTruthDLE(d1)/(1-myTruthDLE(d1))))   mySim<-simulate(object=design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueSigma2=0.025,                 trueSigma2betaW=1,                 mcmcOptions=options,                 nsim=1,                 seed=819,                 parallel=FALSE) #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-RuleDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"Simulate outcomes rule-based design","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-RuleDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# S4 method for RuleDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-RuleDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object RuleDesign object want simulate data nsim number simulations (default: 1) seed see setSeed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-RuleDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object class GeneralSimulations","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-RuleDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(nextBest = NextBestThreePlusThree(),                        cohortSize = CohortSizeConst(size=3L),                        data = emptydata,                        startingDose = 5)  model <- LogisticLogNormal(mean = c(-0.85, 1),                            cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),                            ref_dose = 50)    ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Perform the simulation ##For illustration purpose only 10 simulation is produced (nsim=10).  threeSims <- simulate(myDesign,                       nsim=10,                       seed=35,                       truth=myTruth,                       parallel=FALSE)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDDesign model used ModelTox class object samples involved.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# S4 method for TDDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object TDDesign object want simulate data nsim number simulations (default :1) seed see setSeed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDDesign where model used are of\nModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# nolint start  ##Simulate dose-escalation procedure based only on DLE responses and no DLE samples are used  ##The design comprises a model, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3) doseRecommendation<-nextBest(tdNextBest,                              doselimit=max(data@doseGrid),                              model=model,                              data=data) #> [1] \"TD 35 = 24.9999999999785 not within dose grid\" #> [1] \"TD 30 = 14.3714101936777 not within dose grid\" ##Then the starting data, an empty data set emptydata<-Data(doseGrid=seq(25,300,25)) ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36)   ##Specified the design(for details please refer to the 'TDDesign' example) design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                    data=data,startingDose=25)  ##Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ##then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from=0, to=300,ylim=c(0,1))    ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(object=design,                   args=NULL,                   truth=myTruth,                   nsim=1,                   seed=819,                   parallel=FALSE)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDsamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDsamplesDesign model used ModelTox class object DLE samples also used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDsamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# S4 method for TDsamplesDesign simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDsamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object TDsamplesDesign object want simulate data nsim number simulations (default :1) seed see setSeed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDsamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://roche.github.io/crmPack/main/reference/simulate-TDsamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses.\nThis is a method based on the TDsamplesDesign where model used are of\nModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# nolint start  ##Simulate dose-escalation procedure based only on DLE responses with DLE samples involved  ##The design comprises a model, the escalation rule, starting data, ##a cohort size and a starting dose ##Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36)  ##Specified the design(for details please refer to the 'TDsamplesDesign' example) design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25)  ##Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ##then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from=0, to=300,ylim=c(0,1))   ## Then specified the simulations and generate the trial ##options for MCMC options<-McmcOptions(burnin=100,step=2,samples=200) ##The simulations ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <-  simulate(object=design,                    args=NULL,                    truth=myTruth,                    nsim=1,                    seed=819,                    mcmcOptions=options,                    parallel=FALSE)  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":null,"dir":"Reference","previous_headings":"","what":"Size of an Object — size","title":"Size of an Object — size","text":"method computes size given object. can instance size MCMC sample, size cohort. See help specific method details.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Size of an Object — size","text":"","code":"size(object, ...)  # S4 method for McmcOptions size(object, ...)  # S4 method for CohortSizeRange size(object, dose, data)  # S4 method for CohortSizeDLT size(object, dose, data)  # S4 method for CohortSizeMax size(object, dose, data)  # S4 method for CohortSizeMin size(object, dose, data)  # S4 method for CohortSizeConst size(object, dose, ...)  # S4 method for CohortSizeParts size(object, dose, data)  # S4 method for Samples size(object, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Size of an Object — size","text":"object (McmcOptions Samples CohortSize) object size computed. ... used. dose next dose. data data input, object class Data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Size of an Object — size","text":"size given object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Size of an Object — size","text":"size(McmcOptions): compute number MCMC samples based McmcOptions object. size(CohortSizeRange): Determines size next cohort based range next dose falls . size(CohortSizeDLT): Determines size next cohort based number DLTs far. size(CohortSizeMax): Determines size next cohort based maximum multiple cohort size rules. size(CohortSizeMin): Determines size next cohort based minimum multiple cohort size rules. size(CohortSizeConst): Constant cohort size. size(CohortSizeParts): Determines size next cohort based parts. size(Samples): get number MCMC samples Samples object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Size of an Object — size","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for the cohort size: #   - having cohort of size 1 for doses <10 #   - and having cohort of size 3 for doses >=10 mySize <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for the cohort size: #   - having cohort of size 1 if no DLTs were yet observed #   - and having cohort of size 3 if at least 1 DLT was already observed mySize <- CohortSizeDLT(dlt_intervals = c(0, 1),                         cohort_size = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 10),                            cohort_size = c(1, 3))  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3))  # Combining the two rules for cohort size by taking the maximum of the sample sizes # of the single rules mySize <- maxSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30),                            cohort_size = c(1, 3))  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3))  # Combining the two rules for cohort size by taking the minimum of the sample sizes # of the single rules mySize <- minSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 1  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Rule for having cohorts with constant cohort size of 3 mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value) #> [1] 3  # nolint end # nolint start  # create an object of class 'DataParts' data <- DataParts(x=c(0.1,0.5,1.5),                   y=c(0,0,0),                   doseGrid=c(0.1,0.5,1.5,3,6,                              seq(from=10,to=80,by=2)),                   part=c(1L,1L,1L),                   nextPart=1L,                   part1Ladder=c(0.1,0.5,1.5,3,6,10)) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  myIncrements <- IncrementsRelativeParts(dlt_start=0,                                         clean_start=1) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples,                                model=model,                                data=data)  # Rule for the cohort size: mySize <- CohortSizeParts(sizes=c(1,3))  # Determine the cohort size for the next cohort size(mySize, dose=doseRecommendation$value, data = data) #> [1] 1  # nolint end # Set up the MCMC option in order to have a burn-in of 100 iterations and # then take every other iteration up to a collection of 200 samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 200)  my_samples <- Samples(   data = list(alpha = rnorm(200), beta = rnorm(200)),   options = my_options )  size(my_samples) #> [1] 200"},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop the trial? — stopTrial","title":"Stop the trial? — stopTrial","text":"function returns whether stop trial. Stopping rule based precision MTD estimation. trial stopped, MTD can estimated sufficient precision. criteria based robust coefficient variation (CV) calculated posterior distribution. robust CV defined mad(MTD) / median(MTD), mad median absolute deviation. Stopping based based lowest non placebo dose. trial stopped lowest non placebo dose meets Hard Safety Rule, .e. deemed overly toxic. Stopping based observed data lowest dose level using Bin-Beta model based DLT probability.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop the trial? — stopTrial","text":"","code":"stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingList,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingAll,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingAny,ANY,ANY,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingCohortsNearDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingPatientsNearDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMinCohorts,ANY,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMinPatients,ANY,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTargetProb,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMTDdistribution,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMTDCV,numeric,Samples,GeneralModel,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingLowestDoseHSRBeta,numeric,Samples,ANY,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTargetBiomarker,numeric,Samples,DualEndpoint,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingSpecificDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingHighestDose,numeric,ANY,ANY,Data stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTDCIRatio,ANY,Samples,ModelTox,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingTDCIRatio,ANY,missing,ModelTox,ANY stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for StoppingMaxGainCIRatio,ANY,Samples,ModelTox,DataDual stopTrial(   stopping,   dose,   samples,   model,   data,   TDderive,   Effmodel,   Effsamples,   Gstarderive,   ... )  # S4 method for StoppingMaxGainCIRatio,ANY,missing,ModelTox,DataDual stopTrial(stopping, dose, model, data, Effmodel, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop the trial? — stopTrial","text":"stopping rule, object class Stopping dose recommended next best dose samples Samples object model model input, object class GeneralModel data data input, object class Data ... additional arguments TDderive function derives input, vector posterior samples called TDsamples dose probability occurrence DLE equals either targetDuringTrial targetEndOfTrial, final next best TDtargetDuringTrial (dose probability occurrence DLE equals targetDuringTrial)TDtargetEndOfTrial estimate. Effmodel efficacy model ModelEff class object Effsamples efficacy samples Samples class object Gstarderive function derives input, vector posterior Gstar (dose gives maximum gain value) samples called Gstarsamples, final next best Gstar estimate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop the trial? — stopTrial","text":"logical value: TRUE trial can stopped, FALSE otherwise. attribute message gives reason decision.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Stop the trial? — stopTrial","text":"stopTrial(   stopping = StoppingList,   dose = ,   samples = ,   model = ,   data = ): Stop based multiple stopping rules stopTrial(   stopping = StoppingAll,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment multiple stopping rules stopTrial(   stopping = StoppingAny,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment stopping rule stopTrial(   stopping = StoppingCohortsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number cohorts near next best dose stopTrial(   stopping = StoppingPatientsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number patients near next best dose stopTrial(   stopping = StoppingMinCohorts,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number cohorts stopTrial(   stopping = StoppingMinPatients,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number patients stopTrial(   stopping = StoppingTargetProb,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based probability target tox interval stopTrial(   stopping = StoppingMTDdistribution,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based MTD distribution stopTrial(   stopping = StoppingTargetBiomarker,   dose = numeric,   samples = Samples,   model = DualEndpoint,   data = ): Stop based probability targeting biomarker stopTrial(   stopping = StoppingSpecificDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stopping rule met specific dose planned dose grid just default next best dose. stopTrial(   stopping = StoppingHighestDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop highest dose reached stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples given stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples involved stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses DLE efficacy samples also used. stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses without DLE efficacy samples involved.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/stopTrial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop the trial? — stopTrial","text":"","code":"## Example of combining stopping rules with '&' and/or '|' operators  myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  myStopping <- (myStopping1 & myStopping2) | myStopping3     # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that the study # would be stopped if 'any' of the single stopping rules is TRUE. mystopping <- StoppingList(stop_list=c(myStopping1,myStopping2,myStopping3),                            summary=any)  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 32 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>   # nolint end # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAll' myStopping <- (myStopping1 | myStopping2) & myStopping3  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 36 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>   # nolint end # nolint start  # Create some data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAny' myStopping <- (myStopping1 | myStopping2) | myStopping3  # Evaluate if to stop the Trial stopTrial(stopping=myStopping, dose=doseRecommendation$value,           samples=samples, model=model, data=data) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 37 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"message\")[[3]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>   # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 3 # cohorts were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingCohortsNearDose(nCohorts = 3,                                       percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 cohorts lie within 0.2% of the next best dose 20. This is below the required 3 cohorts\"  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 9 # patients were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingPatientsNearDose(nPatients = 9,                                        percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0.2% of the next best dose 20. This is below the required 9 patients\"  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 6 # cohorts were already dosed myStopping <- StoppingMinCohorts(nCohorts = 6)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 6\"  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if at least 20 # patients were already dosed myStopping <- StoppingMinPatients(nPatients = 20)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\"  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] myStopping <- StoppingTargetProb(target=c(0.2, 0.35),                                  prob=0.5)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 32 % for dose 20 and thus below the required 50 %\"  # nolint end # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),              y=c(0, 0, 0, 0, 0, 0, 1, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.9 probability that MTD > 0.5*next_best_dose. Here MTD is defined as the dose for # which prob(DLE)=0.33 myStopping <- StoppingMTDdistribution(target = 0.33,                                       thresh = 0.5,                                       prob = 0.9)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability of MTD above 50 % of current dose 20 is 91 % and thus above the required 90 %\"  # nolint end # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100, step = 2, samples = 2000, rng_kind = \"Mersenne-Twister\", rng_seed = 94 ) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33)) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rule such that the study would be stopped if the # the MTD can be estimated with sufficient precision, i.e. if robust coefficient # of variation is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)  # Evaluate if to stop the trial. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = my_samples,   model = my_model,   data = my_data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"CV of MTD is 70 % and thus above the required precision threshold of 40 %\"  # Create the data. data <- Data(   x = c(0.1, 0.1, 0.1),   y = c(0, 0, 1),   cohort = c(1, 1, 1),   doseGrid = c(     0.1, 0.5, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   ID = 1:3 )  # Initialize the CRM model used to model the data. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  next_max_dose <- maxDose(my_increments, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(my_next_best,   doselimit = next_max_dose,   samples = samples, model = model, data = data )  # Define the stopping rule such that the study would be stopped if first dose # is toxic based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Evaluate if the trial will be stopped. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability that the lowest active dose of 0.1 being toxic based on posterior Beta distribution using a Beta(1,1) prior is 65% and thus below the required 90% threshold.\" # nolint start  # Create the data data <- DataDual(   x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50),   y=c(0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1),   w=c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21),   doseGrid=c(0.1, 0.5, 1.5, 3, 6,              seq(from=10, to=80, by=2))) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=500) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # In this case target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety) myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples,                                model=model,                                data=data)  # Define the stopping rule such that the study would be stopped if if there is at # least 0.5 posterior probability that the biomarker (efficacy) is within the # biomarker target range of [0.9, 1.0] (relative to the maximum for the biomarker). myStopping <- StoppingTargetBiomarker(target = c(0.9, 1),                                       prob = 0.5)  # Evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target biomarker is 12 % for dose 6 and thus below the required 50 %\"  # nolint end  # Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_nb_ncrm <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. my_dose_recommendation <- nextBest(   nextBest = my_nb_ncrm,   doselimit = 100,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rules. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 ) max_patients <- StoppingMinPatients(nPatients = 20) patients_near_dose <- StoppingPatientsNearDose(nPatients = 3, percentage = 0)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that # the study would be stopped if 'any' of the single stopping rules is TRUE. my_stopping <- highest_dose_safe | max_patients | patients_near_dose  # Evaluate if to stop the Trial stopTrial(   stopping = my_stopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 0 % for dose 80 and thus below the required 80 %\" #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 17 and thus below the prespecified minimum number 20\" #>  #> attr(,\"message\")[[3]] #> [1] \"1 patients lie within 0% of the next best dose 6. This is below the required 3 patients\" #>  # nolint start  # Create the data data <- Data(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40,                  80, 80, 80),              y=c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),              cohort=c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8),              doseGrid=                c(0.1, 0.5, 1.5, 3, 6,                  seq(from=10, to=80, by=2))) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] stopTarget <- StoppingTargetProb(target=c(0.2, 0.35),                                  prob=0.5)  ## now use the StoppingHighestDose rule: stopHigh <-   StoppingHighestDose() &   StoppingPatientsNearDose(nPatients=3, percentage=0) &   StoppingTargetProb(target=c(0, 0.2),                      prob=0.5)  ## and combine everything: myStopping <- stopTarget | stopHigh  # Then evaluate if to stop the trial stopTrial(stopping=myStopping,           dose=doseRecommendation$value,           samples=samples,           model=model,           data=data) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 49 % for dose 62 and thus below the required 50 %\" #>  #> attr(,\"message\")[[2]] #> attr(,\"message\")[[2]][[1]] #> [1] \"Next best dose is 62 and thus not the highest dose\" #>  #> attr(,\"message\")[[2]][[2]] #> [1] \"0 patients lie within 0% of the next best dose 62. This is below the required 3 patients\" #>  #> attr(,\"message\")[[2]][[3]] #> [1] \"Probability for target toxicity is 31 % for dose 62 and thus below the required 50 %\" #>  #>   # nolint end # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses with samples ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!  ##model can be specified of 'Model' or 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##define MCMC options ##for illustration purpose we use 10 burn-in and generate 50 samples options<-McmcOptions(burnin=10,step=2,samples=50) ##samples of 'Samples' class samples<-mcmc(data,model,options) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35, prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  RecommendDose<-nextBest(tdNextBest,doselimit=max(data@doseGrid),samples=samples,                         model=model,data=data) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,dose=RecommendDose$next_dose_drt,           samples=samples,model=model,data=data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Recommended next best dose is NA\"  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses ## we need a data object with doses >= 1: data<-Data(x=c(25,50,50,75,150,200,225,300),            y=c(0,0,0,0,1,1,1,1),            doseGrid=seq(from=25,to=300,by=25)) #> Used default patient IDs! #> Used best guess cohort indices!  ##model must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest<-NextBestTD(prob_target_drt=0.35,prob_target_eot=0.3)   RecommendDose<-nextBest(tdNextBest,doselimit=max(data@doseGrid),model=model,data=data) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,dose=RecommendDose$next_dose_drt,           model=model,data=data) #> [1] FALSE #> attr(,\"messgae\") #> [1] \"95% CI is ( 15.2619 , 173.8695 ), Ratio = 11.3924 is  greater than target_ratio = 5\"  # nolint end # nolint start ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data) ##for illustration purpose we use 10 burn-in and generate 50 samples options<-McmcOptions(burnin=10,step=2,samples=50) ##DLE and efficacy samples must be of 'Samples' class DLEsamples<-mcmc(data,DLEmodel,options) Effsamples<-mcmc(data,Effmodel,options)  ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  RecommendDose<-nextBest(mynextbest,doselimit=max(data@doseGrid),samples=DLEsamples,model=DLEmodel,                         data=data,model_eff=Effmodel,samples_eff=Effsamples) #> [1] \"Estimated TD 35 = 14.8679719869239 not within dose grid\" #> [1] \"Estimated TD 30 = 9.60973788445752 not within dose grid\" #> [1] \"Estimated max gain dose = 300 not within dose grid\" ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(stopping=myStopping,           dose=RecommendDose$next_dose,           samples=DLEsamples,           model=DLEmodel,           data=data,           TDderive=function(TDsamples){             quantile(TDsamples,prob=0.3)},           Effmodel=Effmodel,           Effsamples=Effsamples,           Gstarderive=function(Gstarsamples){             quantile(Gstarsamples,prob=0.5)}) #> [1] TRUE #> attr(,\"message\") #> [1] \"Recommended next best dose is NA\"  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <-DataDual(x=c(25,50,25,50,75,300,250,150),                 y=c(0,0,0,0,0,1,1,0),                 w=c(0.31,0.42,0.59,0.45,0.6,0.7,0.6,0.52),                 doseGrid=seq(25,300,25),                 placebo=FALSE) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data)  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),nu=c(a=1,b=0.025),data=data)   ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest<-NextBestMaxGain(prob_target_drt=0.35, prob_target_eot=0.3)  RecommendDose<-nextBest(mynextbest,doselimit=max(data@doseGrid),model=DLEmodel,                         model_eff=Effmodel,data=data)  ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial   stopTrial(stopping=myStopping,dose=RecommendDose$next_dose,model=DLEmodel,           data=data, Effmodel=Effmodel) #> [1] FALSE #> attr(,\"message\") #> [1] \"Gstar estimate is 94.942 with 95% CI ( 16.771 , 537.4745 ) and its ratio = 32.0479\"                  #> [2] \"TDtargetEndOfTrial estimate is  81.4924 with 95% CI ( 24.3435 , 272.804 ) and its ratio= 11.2064\"    #> [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 11.2064 which is  greater than target_ratio = 5\"  # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/summary-DualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"Summarize dual-endpoint design simulations, relative given true dose-toxicity dose-biomarker curves","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-DualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# S4 method for DualSimulations summary(object, trueTox, trueBiomarker, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/summary-DualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object DualSimulations object want summarize trueTox function takes input dose (vector) returns true probability (vector) toxicity. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied trueTox trueBiomarker","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-DualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object class DualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-DualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the dual-endpoint design simulations, relative to given true\ndose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(mean = c(0, 1),                         cov = matrix(c(1, 0, 0, 1), nrow=2),                         sigma2betaW = 0.01,                         sigma2W = c(a=0.1, b=0.1),                         rho = c(a=1, b=1),                         rw1 = TRUE)  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(target=c(0.9, 1),                                    overdose=c(0.35, 1),                                    max_overdose_prob=0.25)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(target=c(0.9, 1),                                        prob=0.5) # StoppingMinPatients will usually take a higher sample size, # just for illustration here myStopping <- myStopping4 | StoppingMinPatients(6)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- DualDesign(model = model,                      data = emptydata,                      nextBest = myNextBest,                      stopping = myStopping,                      increments = myIncrements,                      cohortSize = CohortSizeConst(3),                      startingDose = 3)  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function (dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2)/((delta1 + delta2)^(delta1 + delta2))   dose <- dose/scal   e0 + eMax/maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(dose, e0=0.2, eMax=0.6, delta1=5, delta2=5 * 0.5 / 0.5, scal=100) }  trueTox <- function(dose) {   pnorm((dose-60)/10) }  # Draw the TRUE profiles par(mfrow=c(1, 2)) curve(trueTox(x), from=0, to=80) curve(trueBiomarker(x), from=0, to=80)   # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # Also for illustration purpose, we will use 5 burn-ins to generate 20 samples # this should be increased of course! mySims <- simulate(design,                    trueTox=trueTox,                    trueBiomarker=trueBiomarker,                    sigma2W=0.01,                    rho=0,                    nsim=1,                    parallel=FALSE,                    seed=3,                    startingDose=6,                    mcmcOptions =                      McmcOptions(burnin=5,                                  step=1,                                  samples=20))  # Summarize the Results of the Simulations summary(mySims,         trueTox = trueTox,         trueBiomarker = trueBiomarker) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 51.6, 56.1  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 3 (3, 3)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 0 (0, 0)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean NA % (NA %, NA %)  #> Fitted biomarker level at dose most often selected : mean NA (NA, NA)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/summary-GeneralSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-GeneralSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"","code":"# S4 method for GeneralSimulations summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/summary-GeneralSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object GeneralSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-GeneralSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object class GeneralSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualFlexiSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"Summary Pseudo Dual responses simulations given pseudo DLE model Flexible efficacy model.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# S4 method for PseudoDualFlexiSimulations summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualFlexiSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object PseudoDualFlexiSimulations object want summarize trueDLE function takes input dose (vector) returns true probability DLE (vector) trueEff vector takes input true mean efficacy values dose levels (order) targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualFlexiSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# nolint start  ##If DLE and efficacy responses are considered in the simulations and the 'EffFlexi' class is used ## we need a data object with doses >= 1: data <- DataDual(doseGrid=seq(25,300,25)) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ## for the efficacy model Effmodel<- EffFlexi(eff=c(1.223, 2.513),eff_dose=c(25,300),                     sigma2W=c(a=0.1,b=0.1),sigma2betaW=c(a=20,b=50),rw1 = FALSE,data=data)   ## specified the next best mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 10 subjects are treated: ## very low sample size is just for illustration here myStopping <- StoppingMinPatients(nPatients=10)  ##Specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff<- c(-0.5478867, 0.1645417,  0.5248031,  0.7604467,                0.9333009  ,1.0687031,  1.1793942 , 1.2726408 ,                1.3529598 , 1.4233411 , 1.4858613 , 1.5420182)   ##specify the options for MCMC #For illustration purpose, we use 10 burn-in and generate 100 samples options<-McmcOptions(burnin=10,step=1,samples=100) ##The simulation ##For illustration purpose only 1 simulation is produced (nsim=1). mySim<-simulate(object=design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueSigma2=0.025,                 trueSigma2betaW=1,                 nsim=1,                 seed=819,                 parallel=FALSE,                 mcmcOptions=options) #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA #> Warning: argument is not numeric or logical: returning NA ##summarize the simulation results summary(mySim,         trueDLE=myTruthDLE,         trueEff=myTruthEff) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 0 (0, 0)  #> Number of patients treated above the target p(DLE) used during a trial : mean 0 (0, 0)  #> Proportions of observed DLT in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients : mean 0 % (0 %, 0 %)  #> Doses selected as TDEOT : mean 0 (0, 0)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    6.222   6.222   6.222   6.222   6.222   6.222   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 125  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      250     250     250     250     250     250   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.192   2.192   2.192   2.192   2.192   2.192   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"Summary Pseudo Dual responses simulations, relative given pseudo DLE efficacy model (except EffFlexi class model)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# S4 method for PseudoDualSimulations summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object PseudoDualSimulations object want summarize trueDLE function takes input dose (vector) returns true probability (vector) DLE trueEff function takes input dose (vector) returns mean efficacy value(s) (vector). targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoDualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model\n(except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# nolint start  ##obtain the plot for the simulation results ##If DLE and efficacy responses are considered in the simulations ##Specified your simulations when no samples are used data <- DataDual(doseGrid=seq(25,300,25)) ##First for the DLE model ##The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(binDLE=c(1.05,1.8),                               DLEweights=c(3,3),                               DLEdose=c(25,300),                               data=data)  ##The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel<-Effloglog(eff=c(1.223,2.513),eff_dose=c(25,300),                     nu=c(a=1,b=0.025),data=data)  ##The escalation rule using the 'NextBestMaxGain' class mynextbest<-NextBestMaxGain(prob_target_drt=0.35,                             prob_target_eot=0.3)   ##The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements<-IncrementsRelative(intervals=c(25,300),                                  increments=c(2,2)) ##cohort size of 3 mySize<-CohortSizeConst(size=3) ##Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients=36) ##Now specified the design with all the above information and starting with a dose of 25  ##Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(nextBest=mynextbest,                               model=DLEmodel,                               Effmodel=Effmodel,                               stopping=myStopping,                               increments=myIncrements,                               cohortSize=mySize,                               data=data,startingDose=25) ##Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## Then specified the simulations and generate the trial for 2 times mySim <-simulate(object=design,                  args=NULL,                  trueDLE=myTruthDLE,                  trueEff=myTruthEff,                  trueNu=1/0.025,                  nsim=2,                  seed=819,                  parallel=FALSE)  ##Then produce a summary of your simulations summary(mySim,         trueDLE=myTruthDLE,         trueEff=myTruthEff) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)  ##If DLE and efficacy samples are involved ##Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details ##specified the next best mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } ) ##specified the design design <- DualResponsesSamplesDesign(nextBest=mynextbest,                                      cohortSize=mySize,                                      startingDose=25,                                      model=DLEmodel,                                      Effmodel=Effmodel,                                      data=data,                                      stopping=myStopping,                                      increments=myIncrements) ##options for MCMC ##For illustration purpose, we will use 50 burn-ins to generate 200 samples options<-McmcOptions(burnin=50,step=2,samples=200) ##The simulations ##For illustration purpose only 2 simulation is produced (nsim=2). mySim<-simulate(design,                 args=NULL,                 trueDLE=myTruthDLE,                 trueEff=myTruthEff,                 trueNu=1/0.025,                 nsim=2,                 mcmcOptions=options,                 seed=819,                 parallel=FALSE)  ##Then produce a summary of your simulations summary(mySim,         trueDLE=myTruthDLE,         trueEff=myTruthEff) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2045 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"# S4 method for PseudoSimulations summary(object, truth, targetEndOfTrial = 0.3, targetDuringTrial = 0.35, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object PseudoSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity targetEndOfTrial target probability DLE wanted achieve end trial targetDuringTrial target probability DLE wanted achieve trial ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object class PseudoSimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-PseudoSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"# nolint start  ##If only DLE responses are considered in the simulations ##Specified your simulations when no DLE samples are used ## data set with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid=seq(25,300,25))  ##The design only incorporate DLE responses and DLE samples are involved ##Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model<-LogisticIndepBeta(binDLE=c(1.05,1.8),DLEweights=c(3,3),DLEdose=c(25,300),data=data) ##Then the escalation rule tdNextBest <- NextBestTD(prob_target_drt=0.35,                          prob_target_eot=0.3)  ##Then the starting data, an empty data set emptydata<-Data(doseGrid=seq(25,300,25)) ## The cohort size, size of 3 subjects mySize <-CohortSizeConst(size=3) ##Deifne the increments for the dose-escalation process ##The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ##The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ##This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements<-IncrementsRelative(intervals=c(min(data@doseGrid),max(data@doseGrid)),                                  increments=c(2,2)) ##Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients=36)   ##Specified the design(for details please refer to the 'TDDesign' example) design <- TDDesign(model=model,                    nextBest=tdNextBest,                    stopping=myStopping,                    increments=myIncrements,                    cohortSize=mySize,                    data=data,startingDose=25)  ##Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ##(Please refer to desgin-method 'simulate TDDesign' examples for details) ##For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=1,                   seed=819,                   parallel=FALSE) ##Then produce a summary of your simulations summary(mySim,         truth=myTruth) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>   ##If DLE samples are involved ##specify the next best tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ##The design design <- TDsamplesDesign(model=model,                           nextBest=tdNextBest,                           stopping=myStopping,                           increments=myIncrements,                           cohortSize=mySize,                           data=data,startingDose=25) ##options for MCMC ##For illustration purpose, we will use 50 burn-ins to generate 200 samples options<-McmcOptions(burnin=50,step=2,samples=200) ##The simulations ## For illustration purpose we will only generate 2 trials (nsim=2) mySim <- simulate(design,                   args=NULL,                   truth=myTruth,                   nsim=2,                   seed=819,                   mcmcOptions=options,                   parallel=FALSE) ##Then produce a summary of your simulations summary(mySim,         truth=myTruth) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/summary-Simulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"Summarize model-based design simulations, relative given truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-Simulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# S4 method for Simulations summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://roche.github.io/crmPack/main/reference/summary-Simulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object Simulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-Simulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object class SimulationsSummary","code":""},{"path":"https://roche.github.io/crmPack/main/reference/summary-Simulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(mean=c(-0.85, 1),                            cov=                              matrix(c(1, -0.5, -0.5, 1),                                     nrow=2),                            ref_dose=56)  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(intervals=c(0, 30),                            cohort_size=c(1, 3)) mySize2 <- CohortSizeDLT(dlt_intervals=c(0, 1),                          cohort_size=c(1, 3)) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts=3) myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),                                   prob=0.5) myStopping3 <- StoppingMinPatients(nPatients=20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33))  # Initialize the design design <- Design(model=model,                  nextBest=myNextBest,                  stopping=myStopping,                  increments=myIncrements,                  cohortSize=mySize,                  data=emptydata,                  startingDose=3)  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(burnin=100,                        step=2,                        samples=1000) time <- system.time(mySims <- simulate(design,                                        args=NULL,                                        truth=myTruth,                                        nsim=1,                                        seed=819,                                        mcmcOptions=options,                                        parallel=FALSE))[3]  # Summarize the Results of the Simulations summary(mySims,truth=myTruth) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 19 (19, 19)  #> Number of patients treated above target tox interval : mean 9 (9, 9)  #> Proportions of DLTs in the trials : mean 32 % (32 %, 32 %)  #> Mean toxicity risks for the patients on active : mean 35 % (35 %, 35 %)  #> Doses selected as MTD : mean 20 (20, 20)  #> True toxicity at doses selected : mean 22 % (22 %, 22 %)  #> Proportion of trials selecting target MTD: 100 % #> Dose most often selected as MTD: 20  #> Observed toxicity rate at dose most often selected: 25 % #> Fitted toxicity rate at dose most often selected : mean 28 % (28 %, 28 %)   # nolint end"},{"path":"https://roche.github.io/crmPack/main/reference/update-Data-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating Data Objects — update,Data-method","title":"Updating Data Objects — update,Data-method","text":"method updates existing Data object new data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-Data-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating Data Objects — update,Data-method","text":"","code":"# S4 method for Data update(   object,   x,   y,   ID = length(object@ID) + seq_along(y),   new_cohort = TRUE,   check = TRUE,   ... )"},{"path":"https://roche.github.io/crmPack/main/reference/update-Data-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating Data Objects — update,Data-method","text":"object (Data) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ID (integer) patient IDs. can also supply numeric vectors, converted integer internally. new_cohort (flag) TRUE (default) new data assigned new cohort. check (flag) whether validation updated object conducted. Current implementation update method allows updating Data class object adding single dose level x . However, might use cases new cohort added contains placebo active dose. Hence, update need performed iteratively calling update method twice. example, first call user can add placebo, second call, active dose. Since cohort placebo allowed, update method normally throw error attempting add placebo first call. allow updates, check parameter set FALSE first call. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-Data-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating Data Objects — update,Data-method","text":"new, updated Data object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-Data-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating Data Objects — update,Data-method","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0L, 1L, 1L)) my_data1 #> An object of class \"Data\" #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDA Objects — update,DataDA-method","title":"Updating DataDA Objects — update,DataDA-method","text":"method updates existing DataDA object new data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# S4 method for DataDA update(object, u, t0, trialtime, y, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDA Objects — update,DataDA-method","text":"object (DataDA) object want update. u (numeric) new DLT free survival times patients, .e. existing patients object well new patients. t0 (numeric) time patient starts DLT observation window. parameter covers patients, .e. existing patients object well new patients. trialtime (number) current time trial, .e. followup time. y (numeric) new DLTs patients, .e. existing patients object well new patients. ... arguments passed Data update method update-Data. used new patients added cohort. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDA Objects — update,DataDA-method","text":"new, updated DataDA object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Updating DataDA Objects — update,DataDA-method","text":"function capable adding new patients also updates existing ones respect y, t0, u slots.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDA-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# Create an object of class 'DataDA'. my_data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data. my_data1 <- update(   object = my_data,   y = c(my_data@y, 0), # The 'y' will be updated according to 'u'.   u = c(my_data@u, 20),   t0 = c(my_data@t0, 95),   x = 20,   trialtime = 120 # This is the global timeline for a trial. ) my_data1 #> An object of class \"DataDA\" #> Slot \"u\": #> [1] 42 30 15  5 20 25 30 35 20 #>  #> Slot \"t0\": #> [1]  0 15 30 40 55 70 75 85 95 #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 #>  #> Slot \"y\": #> [1] 0 0 1 1 0 0 1 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1]  1  2  3  4  5  6  6  6 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 9 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 7 #>  #> Slot \"nObs\": #> [1] 9 #>"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDual-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDual Objects — update,DataDual-method","title":"Updating DataDual Objects — update,DataDual-method","text":"method updates existing DataDual object new data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDual-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# S4 method for DataDual update(object, w, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDual-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDual Objects — update,DataDual-method","text":"object (DataDual) object want update. w (numeric) continuous vector biomarker values patients update. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDual-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDual Objects — update,DataDual-method","text":"new, updated DataDual object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataDual-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0, 1, 1), w = c(0.4, 1.2, 2.2)) my_data1 #> An object of class \"DataDual\" #> Slot \"w\": #>  [1] -0.16751154  0.70445775 -0.69464530 -0.13104399  1.15884973 -0.82885674 #>  [7] -0.01927325  0.40794502  0.40000000  1.20000000  2.20000000 #>  #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataParts-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataParts Objects — update,DataParts-method","title":"Updating DataParts Objects — update,DataParts-method","text":"method updates existing DataParts object new data.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataParts-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# S4 method for DataParts update(object, x, y, ..., check = TRUE)"},{"path":"https://roche.github.io/crmPack/main/reference/update-DataParts-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataParts Objects — update,DataParts-method","text":"object (DataParts) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataParts-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataParts Objects — update,DataParts-method","text":"new, updated DataParts object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-DataParts-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# Create an object of class 'DataParts'. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. # Note that since we reached the last level from 'part1Ladder' # then the 'nextPart' is switched from '1' to '2'. my_data1 <- update(my_data, x = 10, y = 0L) my_data1 #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 1 #>  #> Slot \"nextPart\": #> [1] 2 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 #>  #> Slot \"nObs\": #> [1] 4 #>"},{"path":"https://roche.github.io/crmPack/main/reference/update-ModelPseudo-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"Update method ModelPseudo model class. method update model class slots (estimates, parameters, variables etc.), new data (e.g. new observations responses) available. method mostly used obtain new modal estimates pseudo model parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-ModelPseudo-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# S4 method for ModelPseudo update(object, data, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/update-ModelPseudo-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"object (ModelPseudo) model update. data (Data) currently available data. ... used.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-ModelPseudo-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"new ModelPseudo class object.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/update-ModelPseudo-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update method for the ModelPseudo model class. This is a method to update\nthe model class slots (estimates, parameters, variables and etc.), when the\nnew data (e.g. new observations of responses) are available. This method is\nmostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# Update the 'LogisticIndepBeta' model with new data. empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model_lib <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # Then, we have some new observations data. data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data@doseGrid )  # Update the model to get new estimates. new_model_lib <- update(object = my_model_lib, data = data)  # Update the 'Effloglog' model with new data. empty_data_dual <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data_dual,   const = 0 )  # Data with new observations data. my_data_dual <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data_dual@doseGrid )  # Update the model to get new estimates. new_model_eff <- update(object = my_model_eff, data = my_data_dual)"},{"path":"https://roche.github.io/crmPack/main/reference/v_cohort_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"functions used internally validate format input CohortSize inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_cohort_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"","code":"v_cohort_size_range(object)  v_cohort_size_dlt(object)  v_cohort_size_const(object)  v_cohort_size_parts(object)  v_cohort_size_max(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_cohort_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"object (CohortSize) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_cohort_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_cohort_size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"v_cohort_size_range(): validates CohortSizeRange object contains valid intervals  cohort_size slots. v_cohort_size_dlt(): validates CohortSizeDLT object contains valid dlt_intervals  cohort_size slots. v_cohort_size_const(): validates CohortSizeConst object contains valid size slot. v_cohort_size_parts(): validates CohortSizeParts object contains valid sizes slot. v_cohort_size_max(): validates CohortSizeMax object contains valid cohort_size_list slot.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_data_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"functions used internally validate format input GeneralData inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_data_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"","code":"v_general_data(object)  h_doses_unique_per_cohort(dose, cohort)  v_data(object)  v_data_dual(object)  v_data_parts(object)  v_data_mixture(object)  v_data_da(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_data_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"object (GeneralData) object validate. dose (numeric) dose values. cohort (integer) cohort indices parallel doses.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_data_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"character vector validation failure messages, TRUE case validation passes. TRUE dose unique per cohort, otherwise FALSE.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_data_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"v_general_data(): validates GeneralData object contains unique ID, non-negative cohort indices ID cohort vectors length nObs. h_doses_unique_per_cohort(): helper function verifies whether dose values unique every different cohort. v_data(): validates Data object contains valid elements respect types, dependency length. v_data_dual(): validates DataDual object contains valid biomarker vector respect type length. v_data_parts(): validates DataParts object contains valid elements respect types, dependency length. v_data_mixture(): validates DataMixture object contains valid elements respect types, dependency length. v_data_da(): validates DataDA object contains valid elements respect types, dependency length.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_increments.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Increments Objects — v_increments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"functions used internally validate format input Increments inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_increments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"","code":"v_increments_relative(object)  v_increments_relative_parts(object)  v_increments_relative_dlt(object)  v_increments_num_dose_levels(object)  v_increments_hsr_beta(object)  v_increments_min(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_increments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"object (Increments) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_increments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_increments.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"v_increments_relative(): validates IncrementsRelative object contains valid intervals increments parameters. v_increments_relative_parts(): validates IncrementsRelativeParts object contains valid dlt_start clean_start parameters. v_increments_relative_dlt(): validates IncrementsRelativeDLT object contains valid dlt_intervals increments parameters. v_increments_num_dose_levels(): validates IncrementsNumDoseLevels object contains valid max_levels basis_level option. v_increments_hsr_beta(): validates IncrementsHSRBeta object contains valid probability target, threshold shape parameters. v_increments_min(): validates IncrementsMin object contains list Increments objects.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_mcmcoptions_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"functions used internally validate format input McmcOptions inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_mcmcoptions_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"","code":"v_mcmc_options(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_mcmcoptions_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"object (McmcOptions) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_mcmcoptions_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_mcmcoptions_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"v_mcmc_options(): validates McmcOptions object contains valid integer scalars iterations, burnin step well proper parameters Random Number Generator.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"functions used internally validate format input GeneralModel ModelPseudo inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"","code":"v_general_model(object)  v_model_logistic_kadane(object)  v_model_logistic_kadane_beta_gamma(object)  v_model_logistic_normal_mix(object)  v_model_logistic_normal_fixed_mix(object)  v_model_logistic_log_normal_mix(object)  v_model_dual_endpoint(object)  v_model_dual_endpoint_rw(object)  v_model_dual_endpoint_beta(object)  v_model_dual_endpoint_emax(object)  v_model_logistic_indep_beta(object)  v_model_eff_log_log(object)  v_model_eff_flexi(object)  v_model_da_logistic_log_normal(object)  v_model_tite_logistic_log_normal(object)  v_model_one_par_exp_normal_prior(object)  v_model_one_par_exp_prior(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_model_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"object (GeneralModel) (ModelPseudo)  object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"v_general_model(): validates names arguments init function included datanames datanames_prior slots. v_model_logistic_kadane(): validates logistic Kadane model parameters valid. v_model_logistic_kadane_beta_gamma(): validates logistic Kadane model parameters beta gamma prior valid. v_model_logistic_normal_mix(): validates weightpar valid. v_model_logistic_normal_fixed_mix(): validates component list valid ModelParamsNormal objects well weights correct. v_model_logistic_log_normal_mix(): validates share_weight represents probability. v_model_dual_endpoint(): validates DualEndpoint class slots valid. v_model_dual_endpoint_rw(): validates DualEndpointRW class slots valid. v_model_dual_endpoint_beta(): validates DualEndpointBeta class slots valid. v_model_dual_endpoint_emax(): validates DualEndpointEmax class slots valid. v_model_logistic_indep_beta(): validates LogisticIndepBeta class slots valid. v_model_eff_log_log(): validates Effloglog class slots valid. v_model_eff_flexi(): validates EffFlexi class slots valid. v_model_da_logistic_log_normal(): validates DALogisticLogNormal class slots valid. v_model_tite_logistic_log_normal(): validates TITELogisticLogNormal class slots valid. v_model_one_par_exp_normal_prior(): validates OneParLogNormalPrior class slots valid. v_model_one_par_exp_prior(): validates OneParExpPrior class slots valid.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"functions used internally validate format object model parameters inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"","code":"v_model_params_normal(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_model_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"object (ModelParamsNormal) bivariate normal parameters object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_model_params.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"v_model_params_normal(): helper function validates bivariate normal parameters.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_next_best.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"functions used internally validate format input NextBest inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_next_best.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"","code":"v_next_best_mtd(object)  v_next_best_ncrm(object)  v_next_best_ncrm_loss(object)  v_next_best_dual_endpoint(object)  v_next_best_min_dist(object)  v_next_best_inf_theory(object)  v_next_best_td(object)  v_next_best_td_samples(object)  v_next_best_max_gain_samples(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_next_best.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"object (NextBest) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_next_best.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_next_best.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"v_next_best_mtd(): validates NextBestMTD object contains valid target probability derive function. v_next_best_ncrm(): validates NextBestNCRM object contains valid target probability, overdose max_overdose_prob probability ranges. v_next_best_ncrm_loss(): validates NextBestNCRMLoss object contains valid objects. v_next_best_dual_endpoint(): validates NextBestDualEndpoint object contains valid probability objects. v_next_best_min_dist(): validates NextBestMinDist object contains valid target object. v_next_best_inf_theory(): validates NextBestInfTheory object contains valid target asymmetry objects. v_next_best_td(): validates NextBestTD object contains valid prob_target_drt prob_target_eot probabilities. v_next_best_td_samples(): validates NextBestTDsamples object contains valid derive function. v_next_best_max_gain_samples(): validates NextBestMaxGainSamples object contains valid derive mg_derive functions.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_safety_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"functions used internally validate format input SafetyWindow inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_safety_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"","code":"v_safety_window_size(object)  v_safety_window_const(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_safety_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"object (SafetyWindow) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_safety_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_safety_window.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"v_safety_window_size(): validates SafetyWindowSize object contains valid slots. v_safety_window_const(): validates SafetyWindowConst object contains valid slots.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"functions used internally validate format input Stopping inherited classes therefore exported.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"","code":"v_stopping_cohorts_near_dose(object)  v_stopping_patients_near_dose(object)  v_stopping_min_cohorts(object)  v_stopping_min_patients(object)  v_stopping_target_prob(object)  v_stopping_mtd_distribution(object)  v_stopping_mtd_cv(object)  v_stopping_target_biomarker(object)  v_stopping_list(object)  v_stopping_all(object)  v_stopping_tdci_ratio(object)"},{"path":"https://roche.github.io/crmPack/main/reference/v_stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"object (Stopping) object validate.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/v_stopping.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"v_stopping_cohorts_near_dose(): validates StoppingCohortsNearDose object contains valid nCohorts percentage parameters. v_stopping_patients_near_dose(): validates StoppingPatientsNearDose object contains valid nPatients percentage parameters. v_stopping_min_cohorts(): validates StoppingMinCohorts object contains valid nCohorts parameter. v_stopping_min_patients(): validates StoppingMinPatients object contains valid nPatients parameter. v_stopping_target_prob(): validates StoppingTargetProb object contains valid target prob parameters. v_stopping_mtd_distribution(): validates StoppingMTDdistribution object contains valid target, thresh prob parameters. v_stopping_mtd_cv(): validates StoppingMTDCV object contains valid probability target percentage threshold. v_stopping_target_biomarker(): validates StoppingTargetBiomarker object contains valid target, is_relative probslots. v_stopping_list(): validates StoppingList object contains valid stop_list, summary slots. v_stopping_all(): validates StoppingAll object contains valid stop_list slot. v_stopping_tdci_ratio(): validates StoppingTDCIRatio object contains valid target_ratio  prob_target slots.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the safety window length of the next cohort — windowLength","title":"Determine the safety window length of the next cohort — windowLength","text":"function determines safety window length next cohort.","code":""},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"windowLength(safetyWindow, size, ...)  # S4 method for SafetyWindowSize windowLength(safetyWindow, size, data, ...)  # S4 method for SafetyWindowConst windowLength(safetyWindow, size, ...)"},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the safety window length of the next cohort — windowLength","text":"safetyWindow rule, object class SafetyWindow size next cohort size ... additional arguments data data input, object class DataDA","code":""},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength list safety window parameters (gap, follow, follow_min)","code":""},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength(SafetyWindowSize): Determine safety window length based cohort size windowLength(SafetyWindowConst): Constant safety window length","code":""},{"path":"https://roche.github.io/crmPack/main/reference/windowLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"# nolint start  # Create the data data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=c(0,15,30,40,55,70,75,85),                Tmax=60) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior<-function(k){   npiece_/(data@Tmax*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose=doseRecommendation$value, data = data)  # Rule for the safety window length: #   -having patientGap as (0,7,3,3,...) for cohort size <4 #   -and having patientGap as (0,9,5,5,...) for cohort size >=4 myWindowLength <- SafetyWindowSize(gap = list(c(7,3),c(9,5)),                                    size = c(1,4),                                    follow = 7,                                    follow_min = 14)  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size=sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end # nolint start  # Create the data data <- DataDA(x=c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),                y=c(0, 0, 1, 1, 0, 0, 1, 0),                doseGrid=                  c(0.1, 0.5, 1.5, 3, 6,                    seq(from=10, to=80, by=2)),                u=c(42,30,15,5,20,25,30,60),                t0=c(0,15,30,40,55,70,75,85),                Tmax=60) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior<-function(k){   npiece_/(data@Tmax*(npiece_-k+0.5)) }  model<-DALogisticLogNormal(mean=c(-0.85,1),                            cov=matrix(c(1,-0.5,-0.5,1),nrow=2),                            ref_dose=56,                            npiece=npiece_,                            l=as.numeric(t(apply(as.matrix(c(1:npiece_),1,npiece_),2,lambda_prior))),                            c_par=2)  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin=100,                        step=2,                        samples=200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(intervals=c(0, 20),                                    increments=c(1, 0.33)) nextMaxDose <- maxDose(myIncrements,                        data=data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(target=c(0.2, 0.35),                            overdose=c(0.35, 1),                            max_overdose_prob=0.25)  # Calculate the next best dose doseRecommendation <- nextBest(myNextBest,                                doselimit=nextMaxDose,                                samples=samples, model=model, data=data)  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size=3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose=doseRecommendation$value, data = data)  # Rule for having safety window length with constant safety window parameters myWindowLength <- SafetyWindowConst(gap = c(7,3),                                     follow = 7,                                     follow_min = 14)  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size=sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end"},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-1090009133","dir":"Changelog","previous_headings":"","what":"Version 1.0.9000.9133","title":"Version 1.0.9000.9133","text":"Added new function ngrid returns number doses dose grid. Modified efficacy-EffFlexi method: allowed vectorized dose; NA now returned doses outside dose grid range (warning thrown). Added new custom checkmate function check_range. Added method names objects class Samples. Added method size objects class Samples. Added new custom checkmate function check_length. Added unique flag assert_probabilities checkmate custom functions. Created new vignette describes use certain functions features crmPack major refactoring. Removed MASS Imports Rcpp, RcppArmadillo Suggests used old development version. doselimit argument nextBest method now specified Inf instead numeric(0). Added new helper functions nextBest methods, particularly plotting finding dose closest grid. Added new NextBestNCRMLoss class corresponding nextBest method. Warning message printed anymore nextBest methods doselimit specified. Set prototype target = 0.3 NextBestMinDist class. Added new customized checkmate functions probability values checking. Renamed argument derive function mtdSamples mtd_samples NextBestMTD class. Allowed from_prior flag - argument modelspecs function GeneralModel class. Created new ProbitLogNormalRel model class support (standardized) dose. Changed ProbitLogNormal supports log (standardized) dose . Added logger feature. user interface consists four functions: enable_logging, disable_logging, is_logging_enabled, log_trace. Re-factored sampleSize function returns 0 burnin > iterations. vector t0 slot DataDA class must sorted ascending order. Replaced warning message cohort ID provided user constructor Data. Introduced validation updated object update methods Data-like classes. Added check flag possibly omit validation updated object. Set package use testthat. Added lifecycle package. Include rolling CRM design, previously available separate GitHub branch. Additional authors change maintainer.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2019-06-13 Reference JSS publication.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-029","dir":"Changelog","previous_headings":"","what":"Version 0.2.9","title":"Version 0.2.9","text":"CRAN release: 2018-12-21 default use 5 cores available cores machine. Note value can also changed user. Change maintainer","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-8","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.8","text":"PLcohortSize now defaults 0 placebo patients upon Design class initialization (instead 1 - note effect erroneous simulations, due option set Data class) “examine” function also stops stopping rules fulfilled already case DLTs occurring. case beforehand lead infinite looping (thanks John Kirkpatrick reporting bug) Removed RW2 warnings “DualEndpointRW” - seems work nicely now (thanks Charles Warne reporting!) Removed WinBUGS since used anyway (paper describe )","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"new-features-0-2-8","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.8","text":"“examine” function now counts number times dose recommended contiguously break e.g. default 100 times (can specified new option “examine”) avoid infinite loops issues corresponding warning condition met New “Increments” class “IncrementsNumDoseLevels” works directly number dose levels dose grid can incremented current next cohort (thanks John Kirkpatrick suggestion). can example used order force design skip dose level escalating. Included JSS manuscript new vignette. now possible specify many cores used parallel computations used.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-027","dir":"Changelog","previous_headings":"","what":"Version 0.2.7","title":"Version 0.2.7","text":"CRAN release: 2018-03-13","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-7","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.7","text":"LogisticNormal now works - prec found .","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-026","dir":"Changelog","previous_headings":"","what":"Version 0.2.6","title":"Version 0.2.6","text":"CRAN release: 2018-02-15","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-6","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.6","text":"Replaced BayesLogit dependency JAGS code, since BayesLogit taken CRAN. Speed one example pass CRAN check.","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"new-features-0-2-5","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.5","text":"matching doses dose grid now includes tolerance 1e-10, order make user-friendly (thanks YJ Choi Giuseppe investigating)","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-5","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.5","text":"minor fix alpha1 description LogisticLogNormal-class minor fix scale_colour_manual import ggplot2 reported R-Core","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"new-features-0-2-4","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.4","text":"case multiple nextBest plots now also returned original plots list singlePlots, allow customization, jointly plotting . ProbitLogNormal: Now also model allows reference dose log transformation (standardized) dose. can specified options refDose useLogDose. DualEndpoint: additional options ProbitLogNormal now available DualEndpoint models. consequence, parameter “refDose” class DualEndpointBeta needed renamed “refDoseBeta”, parameter “refDose” class DualEndpointEmax renamed “refDoseEmax”.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-4","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.4","text":"documentation: DualEndpoint description fixed problem formula","code":""},{"path":[]},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"new-features-0-2-3","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.3","text":"New increment class “IncrementMin” added allows combine multiple increment rules MIN operation","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-021","dir":"Changelog","previous_headings":"","what":"Version 0.2.1","title":"Version 0.2.1","text":"CRAN release: 2017-05-03","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.1","text":"Option targetThresh NextBestDualEndpoint allows tune target probability onwards used derive next best dose (fixed 0.05) Added ProbitLogNormal model NextBestDualEndpoint class, additional option “scale” now allows also specify absolute biomarker target ranges. corresponding method evaluation, safety samples now longer included evaluation biomarker target probability, now description consistent computations. NextBestNCRM NextBestDualEndpoint now return matrix target overdosing probabilities additional list element “probs” result “nextBest” applied. Note StoppingTargetBiomarker evaluation, toxicity longer part biomarker target probability.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"bugfixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.1","text":"Added back example vignette, can opened crmPackExample() Clarified DualEndpointRW model samples prior obtained due impropriety RW prior (added model class description). DualEndpointRW models, now possible non-equidistant grid points, obtain sensible results. (still needs thoroughly tested though.) DualEndpointBeta model, now possible negative E0 Emax parameters. Cohort size 0 placebo now possible - e.g. start patients later move larger cohorts also including placebo subjects. simulating firstSeparate=TRUE placebo, now first (sentinel) cohort includes one active one placebo patients, next patients use cohort size active placebo arms, respectively. Barplots work now also one observed value simulations NextBestDualEndpoint now takes account active doses optimizing biomarker outcome next best dose among admissible doses, thus avoiding early stopping placebo dose level. DataMixture objects used, mcmc now correctly sets fromPrior FALSE shared data object contains data.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-020","dir":"Changelog","previous_headings":"","what":"Version 0.2.0","title":"Version 0.2.0","text":"CRAN release: 2016-07-16 Added arguments probmin probmax MinimalInformative order control probability threshold minimum maximum dose minimally informative prior Values 95% CI corresponding ratio upper lower limit CI displayed results using ‘nextBest’ six- number summary tables including values lowest, 25th percentile, 50th percentile median, mean, 75th precentile highest final (stopping) estimates dose levels corresponds target probability DLE used end trial, TDEOT ratios upper lower 95% credibility intervals (CI) TDEOT dose levels corresponds target probability DLE used trial dose levels corresponds maximum gain value, Gstar ratios upper lower 95% CI final estimates Gstar optimal doses, either TDEOT (DLE response ) minimum TDEOT Gstar (DLE efficacy response) ratios optimal dose across simulations also displayed using ‘summary’ simulations.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-018","dir":"Changelog","previous_headings":"","what":"Version 0.1.8","title":"Version 0.1.8","text":"CRAN release: 2016-02-17 value 95% CI final estimates displayed results using ‘stopTrial’ Bugfixes dual endpoint designs: Improved graphical display plots nextBest dose Improved methodology compute Gstar Warnings removed using nextBest simulations Stopping rules can now also freely combined using /operators dual endpoint design stopping rules using MCMC samples.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-016","dir":"Changelog","previous_headings":"","what":"Version 0.1.6","title":"Version 0.1.6","text":"CRAN release: 2015-12-22 New model class “LogisticLogNormalMixture” added, use new data class “DataMixture”. New stopping rule “StoppingHighestDose” added. “examine” method longer stops two consecutive cohorts start dose. important e.g. two-parts study designs, part 1 can end dose part 2 starts. contents “datanames” slot new models longer restricted specific set, previously enforced validation function GeneralModel AllModels classes. Sampling prior can now enabled/disabled user mcmc function, necessary models might prior even though nObs == 0. Bugfix: results MinimalInformative function reproducible beforehand. Now seed parameter can supplied, ensures reproducibility. Bugfix: Compatibility help file links new ggplot2 package version.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-015","dir":"Changelog","previous_headings":"","what":"Version 0.1.5","title":"Version 0.1.5","text":"CRAN release: 2015-11-12 Bugfix: newer versions grid plotting simulation objects longer work. fixed.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-012","dir":"Changelog","previous_headings":"","what":"Version 0.1.2","title":"Version 0.1.2","text":"publication) prior quantiles specified approximated logistic (log) normal priors.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-011","dir":"Changelog","previous_headings":"","what":"Version 0.1.1","title":"Version 0.1.1","text":"Bugfix: Previously, happen NextBestNCRM rule, higher doses lead decreasing probability overdosing, doses numerically probability 1 DLT. bugfix, clarified rules documentation fixed rule method, right limit overdose interval vector inclusive.","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-010","dir":"Changelog","previous_headings":"","what":"Version 0.1.0","title":"Version 0.1.0","text":"Added examine function generate table hypothetical trial courses model-based rule-based DLT-endpoint designs Made results mcmc() (works usual set.seed earlier user code) simulate() (previously already promised) reproducible. See help file mcmc details. Additional improvements reduce confusing warning messages / notes mcmc() higher-level functions. Made simulate parallel=TRUE work r.roche.com (Linux server), using parallelization method laptops (Windows) Passing empty (zero length) vector doselimit parameter nextBest function now considered requesting dose recommendation without strict dose limit, corresponding warning printed. Introduced GeneralModel class, class Model single agent dose escalation derives. Another branch ComboLogistic model multiple agent combinations (future version). Similarly introduced GeneralData class, class Data single agent derives, separately subclass DataCombo (future version).","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-0023","dir":"Changelog","previous_headings":"","what":"Version 0.0.23","title":"Version 0.0.23","text":"Fixed bug mcmc function led error “data elements must many rows sample size ” slightly changed JAGS way handling burnin / thinning (user impact). Reduced number MCMC samples dual-endpoint example vignette able plot vignette","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-0022","dir":"Changelog","previous_headings":"","what":"Version 0.0.22","title":"Version 0.0.22","text":"simulate function fixed (specification arguments) Dual-endpoint model-based design added. 3+3 design simulation now possible, see ?ThreePlusThreeDesign Welcome message attaching crmPack, .e. library(“crmPack”) run crmPackUpgrade() function easy upgrade crmPack latest version Rule-based designs now can specified class RuleDesign, model-based designs stay class Design. even special class DualDesign class, dual-endpoint model-based designs. Corresponding classes GeneralSimulations, Simulations DualSimulations capture output trial simulations rule-based, model-based dual-endpoint designs. class Simulations-summary renamed SimulationsSummary, similarly classes GeneralSimulationsSummary DualSimulationsSummary. Stopping CohortSize rules based intervals (IncrementsRelative, IncrementsRelativeDLT, CohortSizeRange, CohortSizeDLT) now use different intervals definition. Now “intervals” slots contain left bounds intervals. , last element needed infinity. See vignette examples. StoppingMaxPatients class removed, redundant class StoppingMinPatients. Please just use StoppingMinPatients class instead. Initialization methods replaced dedicated initialization functions. Please now use Class(…) functions instead new(“Class”, …) calls obtain correct objects. change also reflected vignette. extract function extracting parameter samples Samples objects removed (due name conflict ggmcmc dependency packages). Please now use instead “get” method Samples objects (see vignette example) obtain data ggmcmc format. crmPack now needs package httr (’s now “Imports” field). Packages Rcpp RcppArmadillo moved “Depends” “Suggests” packages. Currently using . showLegend argument model fit plotting functions, order show legend .","code":""},{"path":"https://roche.github.io/crmPack/main/news/index.html","id":"version-0021","dir":"Changelog","previous_headings":"","what":"Version 0.0.21","title":"Version 0.0.21","text":"NEWS version","code":""}]
