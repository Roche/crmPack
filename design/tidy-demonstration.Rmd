---
title: "Using tidy methods"
author: "John Kirkpatrick"
date: "10/21/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
devtools::load_all()
```

## Introduction
Here is a first draft implementation of borrom-like methods for `crmPack, as suggested in [issue 323](https://github.com/Roche/crmPack/issues/323).

### Principles
The principles I have used in tidying `crmPack` objects are as follows:

* All slots that are not functions are converted to tibbles or a list of tibbles.
* If the slot is scalar, the slot is converted to a 1x1 tibble.  This will ease downstream operations such as `row-bind`ing.
* If the object being tidied contains multiple slots of (potentially) different lengths, the results is a list of tibbles.  The list may be nested to multiple levels.  (See, for example, `ModelParamsNormal`.)
* The column names of the tidied tibble correspond to the slot names of the parent object.
* If an object contains a vector or matrix of values that correspond to an "obvious" set of parameters, columns take on the names of those parameters and the tibble is augmented by a column named `Parameter`.  This most often happens in the mean vector and covariance matrix of `ModelParamsNormal`.
* When the value of a slot has not been set, a zero-row tibble is returned.
* `tbl_<className>` is prepended to the class of the tidy tibble.

### Exceptions
*  Where a vector slot (or series of vector slots) define a range, then the naming convention described above is not followed.  Instead, columns named `min` and `max` define the extent of the range and a column named `Range` labels the range.  Not all instances of this paradigm have been implemented.

### Please also read
Please also read [Issue 407](https://github.com/Roche/crmPack/issues/407) regarding inconsistent slot names.

### Simple examples

`CohortSizeConst` is a trivial example.

```{r}
x <- CohortSizeConst(size = 3) %>% tidy()
x
class(x)
```

`NextBestNCRM` demonstrates how ranges are represented.
```{r}
x <- NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
) %>% tidy()
x
class(x)
```

Various subclasses of `GeneralModel` demonstrate how `tidy()` handles both slots of different classes and nesting.  Here is `LogisticLogNormal` as an example.

```{r}
LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
) %>% tidy()
```

### To do
* Implement `min`/`max` paradigm for all ranges.
* Implement `glimpse` and `augment` methods.  I see this as a relatively low priority task.
* Further test - and most likely improve - the handing of classes that support nesting, such as `StoppingAll` and `StoppingAny` when more than two levels of nesting are used.
* Update README and various vignettes once these changes are merged with main.

## Comprehensive listing of all tidy methods
### CohortSize
```{r}
names(getClass("CohortSize")@subclasses)

CohortSizeConst(3) %>% tidy()
CohortSizeDLT(dlt_intervals = 0:2, cohort_size = 2:0) %>% tidy()
CohortSizeParts(sizes = c(1, 3)) %>% tidy()

mySize1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))
mySize2 <- CohortSizeDLT(dlt_intervals = c(0, 1), cohort_size = c(1, 3))
mySize <- CohortSizeMax(cohort_size_list = list(mySize1, mySize2))
mySize %>% tidy()


mySize <- CohortSizeMin(cohort_size_list = list(mySize1, mySize2))
mySize %>% tidy()
CohortSizeParts(sizes = c(1, 3)) %>% tidy()
```

### Data
```{r}
names(getClass("Data")@subclasses)

Data(
  doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),
  x = c(1, 3, 5, 10, 15),
  y = c(0, 0, 0, 0, 1)
) %>%
  tidy()

tidyDataDA <- DataDA(
  u = c(42, 30, 15, 5, 20, 25, 30, 60),
  t0 = c(0, 15, 30, 40, 55, 70, 75, 85),
  Tmax = 60,
  x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
  y = c(0, 0, 1, 1, 0, 0, 1, 0),
  doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))
) %>%
  tidy()

tidyDataDA
tidyDataDA$doseGrid[1]

tidyDataDual <- DataDual(
  x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
  y = c(0, 0, 0, 0, 0, 0, 1, 0),
  w = rnorm(8),
  doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))
) %>%
  tidy()

tidyDataDual
tidyDataDual$doseGrid[1]


tidyDataMixture <- DataMixture(
  xshare = c(rep(10, 4), rep(20, 4), rep(40, 4)),
  yshare = c(rep(0L, 4), rep(0L, 4), rep(0L, 4)),
  ID = 1:3,
  cohort = c(1, 1, 2),
  x = c(5, 5, 10),
  y = c(0, 0, 0),
  doseGrid = c(5, 10, 20, 40, 80)
) %>%
  tidy()

tidyDataMixture
tidyDataMixture$doseGrid[1]
tidyDataMixture$share[1]

tidyDataParts <- DataParts(
  x = c(0.1, 0.5, 1.5),
  y = c(0, 0, 0),
  doseGrid = c(
    0.1, 0.5, 1.5, 3, 6,
    seq(from = 10, to = 80, by = 2)
  ),
  part = c(1L, 1L, 1L),
  nextPart = 1L,
  part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10)
) %>%
  tidy()

tidyDataParts
tidyDataParts$doseGrid[1]
```

### Design
```{r}
names(getClass("Design")@subclasses)

emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

model <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov =
    matrix(c(1, -0.5, -0.5, 1),
      nrow = 2
    ),
  ref_dose = 56
)

myNextBest <- NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
)

mySize1 <- CohortSizeRange(
  intervals = c(0, 30),
  cohort_size = c(1, 3)
)
mySize2 <- CohortSizeDLT(
  dlt_intervals = c(0, 1),
  cohort_size = c(1, 3)
)
mySize <- maxSize(mySize1, mySize2)

myStopping1 <- StoppingMinCohorts(nCohorts = 3)
myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)
myStopping3 <- StoppingMinPatients(nPatients = 20)
# myStopping <- StoppingAny(stop_list=list(StoppingAll(stop_list=list(myStopping1, myStopping2)), myStopping3))
myStopping <- (myStopping1 & myStopping2) | myStopping3

myIncrements <- IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33))

# Initialize the design
Design(
  model = model,
  nextBest = myNextBest,
  stopping = myStopping,
  increments = myIncrements,
  cohortSize = mySize,
  data = emptydata,
  startingDose = 3
) %>% tidy()

DADesign(
  model = model,
  nextBest = myNextBest,
  stopping = myStopping,
  increments = myIncrements,
  cohortSize = mySize,
  data = DataDA(
    u = c(42, 30, 15, 5, 20, 25, 30, 60),
    t0 = c(0, 15, 30, 40, 55, 70, 75, 85),
    Tmax = 60,
    x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
    y = c(0, 0, 1, 1, 0, 0, 1, 0),
    doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))
  ),
  startingDose = 3,
  safetyWindow = SafetyWindowConst(gap = 5, follow = 10, follow_min = 20)
) %>% tidy()
```

> This is incorrect: safetyWindow is missing.  Need a subclass method

```{r}
DualDesign(
  model = DualEndpointRW(
    mean = c(0, 1),
    cov = matrix(c(1, 0, 0, 1), nrow = 2),
    sigma2W = c(a = 0.1, b = 0.1),
    rho = c(a = 1, b = 1),
    sigma2betaW = 0.01,
    rw1 = TRUE
  ),
  nextBest = myNextBest,
  stopping = myStopping,
  increments = myIncrements,
  cohortSize = mySize,
  data = DataDual(
    x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
    y = c(0, 0, 0, 0, 0, 0, 1, 0),
    w = rnorm(8),
    doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))
  ),
  startingDose = 3
) %>% tidy()
```

## Increments
```{r}
names(getClass("Increments")@subclasses)

# IncrementsNumDoseLevels(max_levels = 2) %>% tidy()
IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33)) %>% tidy()
IncrementsRelativeDLT(dlt_intervals = c(0, 20), increments = c(1, 0.33)) %>% tidy()
IncrementsRelativeParts(dlt_start = 0, clean_start = 1) %>% tidy()

myIncrements1 <- IncrementsRelativeDLT(dlt_intervals = c(0, 1, 3), increments = c(1, 0.33, 0.2))
myIncrements2 <- IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33))
IncrementsMin(increments_list = list(myIncrements1, myIncrements2)) %>% tidy()

# IncrementsNumDoseLevels(max_levels = 1) %>% tidy()
IncrementsRelative(intervals = c(0, 20), increments = c(1, 0.33)) %>% tidy()
```

## Models
```{r}
names(getClass("GeneralModel")@subclasses)

## [19] "FractionalCRM"

npiece <- 10
Tmax <- 60 # nolintr

lambda_prior <- function(k) {
  npiece / (Tmax * (npiece - k + 0.5))
}

DALogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 56,
  npiece = npiece,
  l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),
  c_par = 2
) %>% tidy()

DualEndpoint(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 1,
  use_log_dose = FALSE,
  sigma2W = 0.5,
  rho = -0.2
) %>% tidy()

DualEndpointBeta(
  mean = c(0, 1),
  cov = matrix(c(1, 0, 0, 1), nrow = 2),
  ref_dose = 10,
  use_log_dose = TRUE,
  sigma2W = c(a = 0.1, b = 0.1),
  rho = c(a = 1, b = 1),
  E0 = c(0, 100),
  Emax = c(0, 500),
  delta1 = c(0, 5),
  mode = c(1, 15),
  ref_dose_beta = 1000
) %>% tidy()

DualEndpointEmax(
  mean = c(0, 1),
  cov = matrix(c(1, 0, 0, 1), nrow = 2),
  sigma2W = c(a = 0.1, b = 0.1),
  rho = c(a = 1, b = 1),
  E0 = c(0, 100),
  Emax = c(0, 500),
  ED50 = c(10, 200),
  ref_dose_emax = 1000
) %>% tidy()

DualEndpointRW(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 1,
  use_log_dose = FALSE,
  sigma2W = 0.5,
  sigma2betaW = c(a = 1, b = 2),
  rw1 = TRUE,
  rho = -0.2
) %>% tidy()

FractionalCRM(
  skel_probs = c(0.1, 0.2, 0.3, 0.4),
  dose_grid = c(10, 30, 50, 100),
  sigma2 = 2
) %>% tidy()

LogisticKadane(theta = 0.33, xmin = 1, xmax = 200) %>% tidy()

LogisticKadaneBetaGamma(
  theta = 0.3,
  xmin = 0,
  xmax = 7,
  alpha = 1,
  beta = 19,
  shape = 0.5625,
  rate = 0.125
) %>% tidy()

LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
) %>% tidy()

LogisticLogNormalSub(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
) %>% tidy()

LogisticNormalFixedMixture(
  components = list(
    comp1 = ModelParamsNormal(
      mean = c(-0.85, 1),
      cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)
    ),
    comp2 = ModelParamsNormal(
      mean = c(1, 1.5),
      cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)
    )
  ),
  weights = c(0.3, 0.7),
  ref_dose = 50
) %>%
  tidy()

LogisticNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
) %>% tidy()

LogisticNormalMixture(
  comp1 = ModelParamsNormal(
    mean = c(-0.85, 1),
    cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)
  ),
  comp2 = ModelParamsNormal(
    mean = c(1, 1.5),
    cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)
  ),
  weightpar = c(a = 1, b = 1),
  ref_dose = 50
) %>%
  tidy()

# OneParExpNormalPrior(
#   skel_probs = seq(from = 0.1, to = 0.9, length = 5),
#   dose_grid = 1:5,
#   sigma2 = 2
# ) %>% tidy()

ModelLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
) %>% tidy()

ProbitLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)
) %>% tidy()

TITELogisticLogNormal(
  mean = c(0, 1),
  cov = diag(2),
  ref_dose = 1,
  weight_method = "linear"
) %>% tidy()
```

## Samples, Simulations & McmcOptions

```{r}
options <- McmcOptions(burnin = 1000, step = 2, samples = 2000)

model <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2), ref_dose = 56
)

data <- Data(
  x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),
  y = c(0, 0, 0, 0, 0, 0, 1, 0),
  ID = 1:8,
  cohort = c(0, 1, 2, 3, 4, 5, 5, 5),
  doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2))
)

names(getClass("Samples")@subclasses)
samples <- mcmc(data, model, options)

options %>% tidy()

samples %>% tidy()

stopping_efficacy1 <- StoppingMinCohorts(nCohorts = 3)
stopping_efficacy2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)
stopping_futility <- StoppingMinPatients(nPatients = 40)
trial_stopping <- (stopping_efficacy1 & stopping_efficacy2) | stopping_futility

cohort_size <- CohortSizeConst(size = 3)

next_best <- NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
)

increments <- IncrementsRelative(intervals = c(0, 50, 200), increments = c(2, 1.33, 0.67))

empty_data <- Data(doseGrid = seq(from = 25, to = 300, by = 25))

model <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 150
)

design <- Design(
  model = model,
  nextBest = next_best,
  stopping = trial_stopping,
  increments = increments,
  cohortSize = cohort_size,
  data = empty_data,
  startingDose = 50
)

truth <- function(dose) {
  probFunction(model, alpha0 = -2, alpha1 = 10)(dose)
}

names(getClass("Simulations")@subclasses)

simulations <- simulate(
  design,
  args = NULL,
  truth = truth,
  nsim = 5,
  mcmcOptions = options,
  parallel = FALSE
)

simulations %>% tidy()

emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

# Initialize the CRM model
model <- DualEndpointRW(
  mean = c(0, 1),
  cov = matrix(c(1, 0, 0, 1), nrow = 2),
  sigma2betaW = 0.01,
  sigma2W = c(a = 0.1, b = 0.1),
  use_log_dose = TRUE,
  ref_dose = 2,
  rho = c(a = 1, b = 1),
  rw1 = TRUE
)

# Choose the rule for selecting the next dose
myNextBest <- NextBestDualEndpoint(
  target = c(0.9, 1),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
)

# Choose the rule for the cohort-size
mySize1 <- CohortSizeRange(
  intervals = c(0, 30),
  cohort_size = c(1, 3)
)
mySize2 <- CohortSizeDLT(
  dlt_intervals = c(0, 1),
  cohort_size = c(1, 3)
)
mySize <- maxSize(mySize1, mySize2)

# Choose the rule for stopping
myStopping4 <- StoppingTargetBiomarker(
  target = c(0.9, 1),
  prob = 0.5
)
myStopping <- myStopping4 | StoppingMinPatients(10)

# Choose the rule for dose increments
myIncrements <- IncrementsRelative(
  intervals = c(0, 20),
  increments = c(1, 0.33)
)

# Initialize the design
design <- DualDesign(
  model = model,
  data = emptydata,
  nextBest = myNextBest,
  stopping = myStopping,
  increments = myIncrements,
  cohortSize = mySize,
  startingDose = 3
)

# define scenarios for the TRUE toxicity and efficacy profiles
betaMod <- function(dose, e0, eMax, delta1, delta2, scal) {
  maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))
  dose <- dose / scal
  e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2
}

trueBiomarker <- function(dose) {
  betaMod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100)
}

trueTox <- function(dose) {
  pnorm((dose - 60) / 10)
}



simulations <- simulate(design,
  trueTox = trueTox,
  trueBiomarker = trueBiomarker,
  sigma2W = 0.01,
  rho = 0,
  nsim = 5,
  parallel = FALSE,
  seed = 3,
  startingDose = 6,
  mcmcOptions =
    McmcOptions(
      burnin = 100,
      step = 1,
      samples = 300
    )
)

simulations %>% tidy()
```
