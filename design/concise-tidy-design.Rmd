---
title: "Using tidy methods"
author: "John Kirkpatrick"
date: "07Jun2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(broom)
devtools::load_all()
```

## Introduction
Here is a first draft implementation of broom-like methods for `crmPack, as suggested in [issue 323](https://github.com/Roche/crmPack/issues/323).

Whilst variants of "How do I convert an S4 object to a `data.frame`/`tibble`?" are commonly asked questions on StackOverflow [see, for example, [here](https://stackoverflow.com/questions/57317958/general-way-to-transform-s4-object-to-dataframe-r) and [here](https://stackoverflow.com/questions/14604269/how-to-create-a-dataframe-of-user-defined-s4-classes-in-r)], there appears to be no existing package to do this.  However, the approach generally suggested in answers to these questions is essentially the same as suggested here: 

*  Deal with the object slot by slot  
*  Convert each slot to a `tibble`  
*  Return the slot-specific `tibble`s in a `list` 

### Principles
The general principles I propose for tidying `crmPack` objects are as follows:

* All slots that are not functions are converted to `tibble`s or a list of `tibble`s.
* If the slot is scalar, the slot is converted to a 1x1 `tibble`.  This will ease downstream operations such as `row-bind`ing.
* If the object being tidied contains multiple slots of (potentially) different lengths, the results is a list of `tibble`s.  The list may be nested to multiple levels.  (See, for example, `LogisticLogNormal`.)
* The column names of the tidied `tibble` correspond to the slot names of the parent object.
  * Exception: where the slot has a plural contains a `vector` or `list`, the column name will be singular.  See, for example, `CohortSizeParts` below.
* If an object contains a vector or matrix of values that correspond to an "obvious" set of parameters, columns take on the names of those parameters and the `tibble` is augmented by a column named `Parameter`.  This most often happens in the mean vector and covariance matrix of `ModelParamsNormal`.
* When the value of a slot has not been set, a zero-row `tibble` is returned.
* When the value of a slot has scalar attributes, these attributes are added as a column of the `tibble`, whose name is the name of the attribute and whose value is the value of the attribute for every row of the tibble.  Vector attributes will have to be handled on a case-by-case basis.
* `tbl_<className>` is prepended to the class of the tidy `tibble`.

### Exceptions
*  Where a vector slot (or series of vector slots) define a range, then the naming convention described above is not followed.  Instead, columns named `min` and `max` define the extent of the range and a column named `Range` labels the range.
  * Would, say, `left` and `right` be better names to avoid potential name clashes with the built-in `min` and `max` functions? 
  
Unfortunately, `crmPack` classes do not inherit from a common super class (which need not do anything other than identify the class as being part of the package).  Consequently, a single `crpPack`-specific default `tidy` method is not possible.  A separate, class-specific `tidy` method will be needed for each of the main `crmPack` super classes (`Data`, `GeneralModel`, `Increments`, `CohortSize`, `MaxDose`, `Stopping`, `Design`, `Samples`, `Simulations`, etc).  However, the basic functionality is the same regardless of super class: iterate over slots that are not functions, converting each to a tibble.  This common functionality could be propvided by a helper function.  See below. 

### Helper functions
It is likely that `tidy`ing `crmPack` objects of different classes will share common steps.  These common steps are candidates for being handled by helper functions.  Functionality for various helper functions include:

* Conversion of a single slot to a tibble [`h_slot_to_tibble` with signature `c(obj = ANY, slot_name = "character")`]
* Conversion of all slots in an object to tibbles [`h_tidy_all_slots` with signature `c(obj = ANY)`] that simply calls `h_slot_to_tibble` for all slots in the object that are not functions.
* The conversion of scalar attributes to "constant" columns in a tibble [`h_scalar_attr_to_column` with signature `c(data = "tibble", obj = ANY)`]
* The conversion of ranges (as found in, for example, sub-classes `Increments`) to min/max column pairs [`h_range_to_minmax` with signature `c(data = "tibble", obj = ANY)` with additional arguments to allow users to specify the name of the min and max columns, whether the ranges are closed to the left (default) or right and the outer ends of the lowest and highest intervals (with defaults `-Inf` and `Inf` respectively)]
* The class definition of the `tidy` tibble [`h_tidy_class` with signature `c(data = "tibble")]

### Please also read
Please also read [Issue 407](https://github.com/Roche/crmPack/issues/407) regarding inconsistent slot names.

## Implementation
`tidy()` is a generic defined in `broom`.  An end-user of `crmPack` may not have installed `broom`.  Therefore, we have two options:

* Make `crmPack` Depend on `broom`
* On loading `crmPack`, determine if `broom` is an available namespace and, if not, define the appropriate generic

After discussion, we take the first approach and make `crmPack` Depend on `broom`.


### Some helper functions
```{r define-helper-functions}
h_slot_to_tibble <- function(obj, slot_name, col = NULL) {
  if (is.null(col)) {
    col <- slot_name
  }
  tibble::tibble({{ col }} := slot(obj, slot_name))
}

h_tidy_all_slots <- function(obj) {
  lapply(slotNames(obj), \(x) h_slot_to_tibble(obj, x)) %>%
    dplyr::bind_cols()
}

h_tidy_class <- function(d, obj) {
  cls <- class(obj)
  class(d) <- c(paste0("tbl_", cls[1]), class(d))
  d
}

h_range_to_minmax <- function(
    x,
    col,
    min_col = "min",
    max_col = "max",
    range_min = -Inf,
    range_max = Inf) {
  vals <- x %>% dplyr::pull({{ col }})
  tibble(
    {{ min_col }} := c(range_min, vals),
    {{ max_col }} := c(vals, range_max)
  )
}
```

### Simple examples

`CohortSizeConst` is a trivial example and illustrates the default approach for all classes.

```{r}
# tidy-CohortSize ----

#' @rdname tidy
#' @aliases tidy-CohortSize
#' @example examples/CohortSize-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "CohortSize"),
  definition = function(x, ...) {
    h_tidy_all_slots(x) %>% h_tidy_class(x)
  }
)
x <- CohortSizeConst(size = 3) %>% tidy()
x
class(x)
```

`CohortSizeParts` is slightly more complex and requires custom handling because the part index is implicit rather than explicit.

```{r}
# tidy-CohortSizeParts ----

#' @rdname tidy
#' @aliases tidy-CohortSizeParts
#' @example examples/CohortSizeParts-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "CohortSizeParts"),
  definition = function(x, ...) {
    tibble::tibble(
      part = seq_along(x@cohort_sizes),
      cohort_size = x@cohort_sizes
    ) %>%
      h_tidy_class(x)
  }
)

x <- CohortSizeParts(cohort_sizes = c(1, 3)) %>% tidy()
x
class(x)
```

`IncrementsRelative` illustrate how ranges are handled.

```{r}
# tidy-Increments ----

#' @rdname tidy
#' @aliases tidy-Increments
#' @example examples/Increments-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "Increments"),
  definition = function(x, ...) {
    h_tidy_all_slots(x) %>%
      h_tidy_class(x)
  }
)

# tidy-IncrementsRelative ----

#' @rdname tidy
#' @aliases tidy-IncrementsRelative
#' @example examples/IncrementsRelative-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "IncrementsRelative"),
  definition = function(x, ...) {
    callNextMethod() %>%
      h_range_to_minmax(intervals) %>%
      dplyr::filter(max > 0) %>%
      add_column(increment = x@increments)
  }
)

x <- IncrementsRelative(
  intervals = c(0, 20),
  increments = c(1, 0.33)
) %>%
  tidy()
x
class(x)
```

`NextBestNCRM` requires custom handling.  
```{r}
# tidy-NextBest ----

#' @rdname tidy
#' @aliases tidy-NextBest
#' @example examples/NextBest-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "NextBest"),
  definition = function(x, ...) {
    h_tidy_all_slots(x) %>%
      h_tidy_class(x)
  }
)

# tidy-NextBestNCRM ----

#' @rdname tidy
#' @aliases tidy-NextBestNCRM
#' @example examples/NextBestNCRM-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "NextBestNCRM"),
  definition = function(x, ...) {
    callNextMethod() %>%
      h_range_to_minmax(target, range_min = 0, range_max = 1) %>%
      add_column(max_prob = c(NA, NA, x@max_overdose_prob)) %>%
      add_column(Range = c("Underdose", "Target", "Overdose"), .before = 1)
  }
)

x <- NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.35, 1),
  max_overdose_prob = 0.25
) %>% tidy()
x
class(x)
```
In addition, consideration of how to handle the case when the lower end of `overdose` is above the upper end of `target` because `crmPack` does not follow the usual convention of classifying p(Tox) into four categories, namely, "Underdosing", "Target", "Overdosing" and "Toxicity".  The current implementation gives incorrect output:

```{r, error = TRUE}
NextBestNCRM(
  target = c(0.2, 0.35),
  overdose = c(0.6, 1),
  max_overdose_prob = 0.25
) %>% tidy()
```

Should the output be similar to

```{r echo = FALSE}
tibble(
  Range = c("Underdose", "Target", "Overdose"),
  min = c(0, 0.2, 0.6),
  max = c(0.2, 0.35, 1),
  max_prob = c(NA, NA, 0.25)
)
```

or similar to 

```{r echo = FALSE}
tibble(
  Range = c("Underdose", "Target", " ", "Overdose"),
  min = c(0, 0.2, 0.35, 0.6),
  max = c(0.2, 0.35, 0.6, 1),
  max_prob = c(NA, NA, NA, 0.25)
)
```
?

### A more complex example
Various sub-classes of `GeneralModel` demonstrate how `tidy()` handles both slots of different classes and nesting.  Here is `LogisticLogNormal` as an example.

```{r}
# tidy Model ----
# tidy ModelParamsNormal
#' @rdname tidy
#' @aliases tidy ModelParamsNormal
#' @example examples/ModelParamsNormal-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "ModelParamsNormal"),
  definition = function(x, param_names = c("alpha0", "alpha1"), ...) {
    rv <- list(
      "mean" = tibble::tibble(Mean = x@mean),
      "cov" = tibble::as_tibble(x@cov, .name_repair = function(y) param_names),
      "prec" = tibble::as_tibble(x@prec, .name_repair = function(y) param_names)
    )
    if (length(param_names) > 0) {
      rv$mean <- rv$mean %>%
        tibble::add_column(Parameter = param_names, .before = 1)
      rv$cov <- rv$cov %>%
        tibble::add_column(Parameter = param_names, .before = 1)
      rv$prec <- rv$prec %>%
        tibble::add_column(Parameter = param_names, .before = 1)
    }
    class(rv) <- c(paste0("tbl_", class(x)), class(rv))
    return(rv)
  }
)


#' @rdname tidy
#' @aliases tidy-GeneralModel
#' @example examples/GeneralModel-method-tidy.R
#' @export
setMethod(
  f = "tidy",
  signature = signature(x = "GeneralModel"),
  definition = function(x, param_names = NA, ...) {
    rv <- list(
      "params" = x@params %>% tidy(),
      "ref_dose" = tibble::tibble(ref_dose = x@ref_dose),
      "datanames" = tibble::tibble(Parameter = x@datanames),
      "datanames_prior" = tibble::tibble(Parameter = x@datanames_prior),
      "sample" = tibble::tibble(Parameter = x@sample)
    )
    class(rv) <- c(paste0("tbl_", class(x)), class(rv))
    return(rv)
  }
)

x <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 50
)
x %>% tidy()

lapply(slotNames(x), function(z) class(slot(x, z)))
```
