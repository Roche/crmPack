---
title: "Design for grouped single / combo design"
output:
  html_document:
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(crmPack)
library(checkmate)
library(ggplot2)

knitr::opts_chunk$set(echo = TRUE)
```

Note that in this design doc we don't include validation functions yet.

# The data: `DataPartsGrouped`

The idea is that we start from `DataParts` (because we need the 2 parts feature 
due to the safety run-in requirement) and add a slot `group` which is a factor 
with 2 levels of the same length, similar as we add the biomarker `w` in the 
class `DataDual`.

## Definition

```{r DataPartsGrouped-class}
.DataPartsGrouped <- setClass(
  Class = "DataPartsGrouped",
  slots = c(
    group = "factor"
  ),
  prototype = prototype(
    group = factor(levels = c("single", "combo"))
  ),
  contains = "DataParts"
)

DataPartsGrouped <- function(group,
                             ...) {
  d <- DataParts(...)
  .DataPartsGrouped(
    d,
    group = group
  )
}
```

## Methods

Note that for the `plot` method to be able to use the parent method for starting
the plot, we need to make sure additional arguments are passed inside to the
`h_plot_data_df()` function initializing the `ggplot2` data set.

```{r DataPartsGrouped-methods}
setMethod(
  f = "update",
  signature = signature(object = "DataPartsGrouped"),
  definition = function(object, group, ..., check = TRUE) {
    assert_character(group)
    assert_flag(check)

    # Update slots corresponding to `DataParts` class.
    object <- callNextMethod(object = object, ..., check = FALSE)

    # Update the group information.
    group <- factor(group, levels = levels(object@group))
    object@group <- c(object@group, group)

    if (check) {
      validObject(object)
    }

    object
  }
)

setMethod(
  f = "plot",
  signature = signature(x = "DataPartsGrouped", y = "missing"),
  definition = function(x, y, blind = FALSE, ...) {
    assert_flag(blind)

    # Call the superclass method, to get the initial plot layout.
    # Make sure `group` is available.
    p <- callNextMethod(x, blind = blind, legend = FALSE, group = x@group, ...)

    # Now add the faceting by group.
    p + facet_wrap(vars(group), nrow = 2)
  }
)
```

## Example

```{r DataPartsGrouped-example}
my_data <- DataPartsGrouped(
  x = c(0.1, 0.1, 0.5, 0.5, 1.5, 1.5),
  y = c(0, 0, 0, 0, 1, 0),
  group = factor(rep(c("single", "combo"), 3), levels = c("single", "combo")),
  ID = 1:6,
  cohort = rep(1:3, each = 2),
  doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),
  part = rep(1L, 6),
  nextPart = 1L,
  part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10)
)

plot(my_data)
my_data_2 <- update(my_data, x = 3, y = c(0, 0), group = c("single", "combo"))
plot(my_data_2)
```

# The model: `LogisticLogNormalGrouped`

We can inherit from `ModelLogNormal`. Compared to `LogisticLogNormal` etc.
we have an additional parameter `theta[3]` which is then also exponentiated to 
obtain `alpha2`.

## Definition

Note that this can easily be extended later (either with a flag or with another
class) to not use log dose but dose instead (divided by reference dose).

```{r LogisticLogNormalGrouped-class}
.LogisticLogNormalGrouped <- setClass(
  Class = "LogisticLogNormalGrouped",
  contains = "ModelLogNormal"
)

LogisticLogNormalGrouped <- function(mean, cov, ref_dose = 1) {
  params <- ModelParamsNormal(mean, cov)
  .LogisticLogNormalGrouped(
    params = params,
    ref_dose = crmPack:::positive_number(ref_dose),
    priormodel = function() {
      theta ~ dmnorm(mean, prec)
      alpha0 <- theta[1]
      alpha1 <- exp(theta[2])
      alpha2 <- exp(theta[3])
    },
    datamodel = function() {
      for (i in 1:nObs) {
        logit(p[i]) <- alpha0 + (alpha1 + is_combo[i] * alpha2) * log(x[i] / ref_dose)
        y[i] ~ dbern(p[i])
      }
    },
    modelspecs = function(group, from_prior) {
      ms <- list(
        mean = params@mean, 
        prec = params@prec,
        is_combo = as.integer(group == "combo")
      )
      if (!from_prior) {
        ms$ref_dose <- ref_dose
      }
      ms
    },
    init = function() {
      list(theta = c(0, 1, 1))
    },
    datanames = c("nObs", "y", "x"),
    sample = c("alpha0", "alpha1", "alpha2")
  )
}
```

## Methods

```{r LogisticLogNormalGrouped-methods}
setMethod(
  f = "prob",
  signature = signature(
    dose = "numeric",
    model = "LogisticLogNormalGrouped",
    samples = "Samples"
  ),
  definition = function(dose, model, samples, group) {
    assert_numeric(dose, lower = 0L, any.missing = FALSE, min.len = 1L)
    assert_subset(c("alpha0", "alpha1", "alpha2"), names(samples))
    assert_length(dose, len = size(samples))
    assert_factor(group, len = length(dose), levels = c("single", "combo"))

    alpha0 <- samples@data$alpha0
    alpha1 <- samples@data$alpha1
    alpha2 <- samples@data$alpha2
    ref_dose <- as.numeric(model@ref_dose)
    is_combo <- as.integer(group == "combo")
    plogis(alpha0 + (alpha1 + is_combo * alpha2) * log(dose / ref_dose))
  }
)

setMethod(
  f = "dose",
  signature = signature(
    x = "numeric",
    model = "LogisticLogNormalGrouped",
    samples = "Samples"
  ),
  definition = function(x, model, samples, group) {
    assert_probabilities(x)
    assert_subset(c("alpha0", "alpha1", "alpha2"), names(samples))
    assert_length(x, len = size(samples))
    assert_factor(group, len = length(x), levels = c("single", "combo"))
    
    alpha0 <- samples@data$alpha0
    alpha1 <- samples@data$alpha1
    alpha2 <- samples@data$alpha2
    ref_dose <- as.numeric(model@ref_dose)
    is_combo <- as.integer(group == "combo")
    exp((logit(x) - alpha0) / (alpha1 + is_combo * alpha2)) * ref_dose
  }
)
```

Note that for the `fit` method we need to make sure that the `...` are passed down to `prob`,
such that we can pass down the `group` argument.

TODO: Add tests for this in this PR already.

## Example

```{r LogisticLogNormalGrouped-example}
my_model <- LogisticLogNormalGrouped(mean = rep(0, 3), cov = diag(rep(1, 3)), ref_dose = 1)

my_options <- McmcOptions()
my_samples <- mcmc(my_data, my_model, my_options)
str(my_samples)

mean(my_samples@data$alpha2)
mean(prob(dose = 5, my_model, my_samples, factor("single", levels = c("single", "combo"))))
mean(prob(dose = 5, my_model, my_samples, factor("combo", levels = c("single", "combo"))))

one_sample <- Samples(
  data = list(alpha0 = -0.5, alpha1 = 0.3, alpha2 = 0.5),
  options = McmcOptions(samples = 1L)
)

td50_single <- dose(x = 0.5, my_model, one_sample, factor("single", levels = c("single", "combo")))
td50_combo <- dose(x = 0.5, my_model, one_sample, factor("combo", levels = c("single", "combo")))

prob(dose = td50_single, my_model, one_sample, factor("single", levels = c("single", "combo")))
prob(dose = td50_combo, my_model, one_sample, factor("combo", levels = c("single", "combo")))

fit_single <- fit(one_sample, my_model, my_data, group = factor("single", levels = c("single", "combo")))
fit_combo <- fit(one_sample, my_model, my_data, group = factor("combo", levels = c("single", "combo")))
matplot(x = fit_single$dose, y = cbind(fit_single$middle, fit_combo$middle), type = "l")
```



