---
title: "Design for grouped single / combo design"
output:
  html_document:
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(crmPack)
library(checkmate)
library(ggplot2)

knitr::opts_chunk$set(echo = TRUE)
```

Note that in this design doc we don't include validation functions yet.

# The data: `DataPartsGrouped`

The idea is that we start from `DataParts` (because we need the 2 parts feature 
due to the safety run-in requirement) and add a slot `group` which is a factor 
with 2 levels of the same length, similar as we add the biomarker `w` in the 
class `DataDual`.

## Definition

```{r DataPartsGrouped-class}
.DataPartsGrouped <- setClass(
  Class = "DataPartsGrouped",
  slots = c(
    group = "factor"
  ),
  prototype = prototype(
    group = factor(levels = c("single", "combo"))
  ),
  contains = "DataParts"
)

DataPartsGrouped <- function(group,
                             ...) {
  d <- DataParts(...)
  .DataPartsGrouped(
    d,
    group = group
  )
}
```

## Methods

Note that for the `plot` method to be able to use the parent method for starting
the plot, we need to make sure additional arguments are passed inside to the
`h_plot_data_df()` function initializing the `ggplot2` data set.

```{r DataPartsGrouped-methods}
setMethod(
  f = "update",
  signature = signature(object = "DataPartsGrouped"),
  definition = function(object, group, ..., check = TRUE) {
    assert_character(group)
    assert_flag(check)

    # Update slots corresponding to `DataParts` class.
    object <- callNextMethod(object = object, ..., check = FALSE)

    # Update the group information.
    group <- factor(group, levels = levels(object@group))
    object@group <- c(object@group, group)

    if (check) {
      validObject(object)
    }

    object
  }
)

setMethod(
  f = "plot",
  signature = signature(x = "DataPartsGrouped", y = "missing"),
  definition = function(x, y, blind = FALSE, ...) {
    assert_flag(blind)

    # Call the superclass method, to get the initial plot layout.
    # Make sure `group` is available.
    p <- callNextMethod(x, blind = blind, legend = FALSE, group = x@group, ...)

    # Now add the faceting by group.
    p + facet_wrap(vars(group), nrow = 2)
  }
)
```

## Example

```{r DataPartsGrouped-example}
my_data <- DataPartsGrouped(
  x = c(0.1, 0.1, 0.5, 0.5, 1.5, 1.5),
  y = c(0, 0, 0, 0, 1, 0),
  group = factor(rep(c("single", "combo"), 3), levels = c("single", "combo")),
  ID = 1:6,
  cohort = rep(1:3, each = 2),
  doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),
  part = rep(1L, 6),
  nextPart = 1L,
  part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10)
)

plot(my_data)
my_data_2 <- update(my_data, x = 3, y = c(0, 0), group = c("single", "combo"))
plot(my_data_2)
```

# The model: `LogisticLogNormalGroup`

We can inherit from `ModelLogNormal`. Compared to `LogisticLogNormal` etc.
we have an additional parameter `theta[3]` which is then also exponentiated to 
obtain `alpha2`.

## Definition

```{r LogisticLogNormalGroup-class}

```




