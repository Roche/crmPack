---
title: "Design how to save atomic stopping rule results in simulations and report them"
output: 
  html_document:
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo = F, message = F, warning = F}
devtools::load_all()
```

## Objective 

Currently there is no information returned about stopping rules / frequency during scenario simulation. We would like to add a counting feature and a reporting feature for individual and complex / combined stopping rules. 
We need to count instances in which a stopping rule is TRUE. In case we have combined (BOOLEAN logic) stopping rules we would like to summarize (concatenate) before outputting to the console.   
Additionally differentiate between first hit and "all other" (otherwise might add up to more than 100 %).

## Implementation suggestion

* How to get the name of a stopping rule, i.e. get the class name (might not be well readable) or should we have a slot in stopping rule classes (would require manual adjustment of all stopping rule classes) - requires to be present in all classes otherwise will throw errors

For option one we would have to add a slot to the rule class, so that we can refer to the name slot later.
```{r class.source = 'fold-hide',message = F, warning = F, results='hide'}

.StoppingMinCohorts <-
    setClass(Class="StoppingMinCohorts",
             representation(nCohorts="integer",
                            name = "character"),
             prototype(nCohorts=3L, name = "minimum required number of cohorts"),
             contains="Stopping",
             validity=function(object){
                 o <- Validate()

                 o$check((object@nCohorts > 0L) && is.scalar(object@nCohorts),
                         "nCohorts must be positive scalar")

                 o$result()
             })
#validObject(.StoppingMinCohorts())


StoppingMinCohorts <- function(nCohorts, name)
{
    .StoppingMinCohorts(nCohorts=safeInteger(nCohorts))
}

```


The two options we have to print the stopping rule name later: 
```{r}

myStopping1 <- StoppingMinCohorts(nCohorts=3)

myStopping1@name

class(myStopping1)
```



### Unpack combined stopping rules

Now, let's assume we have a combination of stopping rules. I'll go with class() for now so that I don't have to adjust all the stopping rule classes. How would we access all the names? 


```{r}
myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),
                                     prob=0.5)
myStopping3 <- StoppingMinPatients(nPatients=20)

myStopping_combined <- (myStopping1 & myStopping2) | myStopping3

```


This is the current implementation, I have tested it with multiple combinations 
 
* (Stopping_Rule1  | Stopping_Rule2 | Stopping_Rule3  | Stopping_Rule4  | Stopping_Rule5)
* ((Stopping_Rule1  & Stopping_Rule2) | Stopping_Rule3  | Stopping_Rule4  | Stopping_Rule5)
* Stopping_Rules_Combined3 <- (Stopping_Rule1  | Stopping_Rule2 | Stopping_Rule3  | (Stopping_Rule4  & Stopping_Rule5))
* (Stopping_Rule1  | (Stopping_Rule2 & Stopping_Rule3  & Stopping_Rule4)  | Stopping_Rule5)
* Stopping_Rules_Combined5 <- (Stopping_Rule1  |Stopping_Rule2) & (Stopping_Rule3  | Stopping_Rule4)

and it worked fine for all of them. 
```{r}
k = 1
max = 0
number = list()
names = list()
ind = 1
stopping_objects <- myStopping_combined@stopList



for ( i in stopping_objects) {

  t <- try(slot(i, name = "stopList"), silent = T)

    if("try-error" %in% class(t)){   # only one rule


    if ( max >= k){
      number[ind] <- as.character(max+1)
      #names [ind] <- slot(stopping_objects[[ind]], "name")
      names [ind] <- class(stopping_objects[[ind]])
      max <- max + 1
    } else {
    number[ind] <- as.character(k)
    #names [ind] <- slot(stopping_objects[[ind]], "name")
    names [ind] <- class(stopping_objects[[ind]])
    }

    k = k+1
    ind = ind + 1
  } else { # multiple combined rules 

    max = k + length(i@stopList) - 1
   
   number[ind] <- paste(k : max, collapse = " & ")
   #names[ind] <- paste(sapply(stopping_objects[[ind]]@stopList, slot, "name"), collapse = " and ")
   names[ind]  <- paste(sapply(stopping_objects[[ind]]@stopList, class), collapse = " and ")
   ind = ind + 1
   k = k + length(k:max)
  }

}

names
number

```

### Count number of hits across all iterations and calculate return measures

So, this is how we can get the order and names of the stopping rules for reporting later on. To count the frequency we have to get the information per iteration from the simulation method: 

```{r, eval = F}
stopLength <-length(object@stopping@stopList)
                stop_sum <- matrix(nrow=1,ncol=stopLength)
                for (i in 1: stopLength){
                  stop_sum[,i]<- stopTrial(stopping=object@stopping@stopList[[i]],
                                           dose=thisDose,
                                           samples=thisSamples,
                                           model=object@model,
                                           data=thisData)
                  
                }

```
As a result we would get a matrix for each iteration that looks like this: 


```{r}
output_it1 <- matrix(nrow= 1, ncol = 2)
output_it2 <- matrix(nrow= 1, ncol = 2)
output_it3 <- matrix(nrow= 1, ncol = 2)
output_it4 <- matrix(nrow= 1, ncol = 2)
output_it1[1, ] <- c(TRUE, FALSE)
output_it2[1, ] <- c(FALSE, TRUE)
output_it3[1, ] <- c(TRUE, FALSE)
output_it4[1, ] <- c(TRUE, TRUE)

output <- list(output_it1, output_it2, output_it3, output_it4)
output
```

Based on this we calculate the measure we're interested in: stopping reasons for all stopping rules and the first hit per iteration (that would happen in the summary method):
```{r}
stopReasonsUnique <- sapply(output,colSums)
stopReasonsUnique
stopReasonsUniquePercent<- (rowSums(stopReasonsUnique)/length(stopReasonsUnique[1,]))*100
stopReasonsUniquePercent
              

## %trials each stopping rule fired first based on the order of the stopping rule defined in the design
stopReasonsFirstHit<-apply(stopReasonsUnique,2,function(x){min(which(x == "1"))})
stopReasonsFirstHitFreq<-table(stopReasonsFirstHit)

stopReasonsFirstHit              
stopReasonsFirstHitFreq              
              
if (dim(stopReasonsFirstHitFreq)<=length(output[[1]])){
          frame<-as.data.frame(stopReasonsFirstHitFreq)
          framefull<-data.frame(stopReasonsFirstHit=1:length(output[[1]]))
          frame1 <- merge(x=framefull ,y= frame, by="stopReasonsFirstHit", all.x = TRUE)
          frame1$Freq[is.na(frame1$Freq)] = 0
          stopReasonsFirstHitFreq <- as.numeric(frame1$Freq)
              }
              
## percentage of different values of the freq
stopReasonsFirstHitFreqPercent <- (stopReasonsFirstHitFreq/sum(stopReasonsFirstHitFreq))*100
stopReasonsFirstHitFreqPercent              
```

If we put everything together, the output can then for example look like this: 

>>Stops (individual) for reason 1 & 2 StoppingMinCohorts and StoppingTargetProb : 75 %  
>>Stops (individual) for reason 3 StoppingMinPatients : 50 %  

>>Stops (first hit) for reason 1 & 2 SStoppingMinCohorts and StoppingTargetProb : 75 %  
>>Stops (first hit) for reason 3 StoppingMinPatients : 25 %  



### Class and Method functions affected 

* method "simulate"
* class "Simulations"
* class "Summary"
* method "summary
* method "show"
