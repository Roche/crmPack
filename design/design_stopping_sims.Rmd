---
title: "Design how to save atomic stopping rule results in simulations and report them"
output: 
  html_document:
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, echo = F, message = F, warning = F}
devtools::load_all()
```

## Objective 

Currently there is no information (summarries i.e. counts and percentages) reported for stopping rules used as part of the study design, 
and triggered during scenario simulations. 

We would like to add a feature that counts the instnaces a stopping rule is triggered during simulation.
This feature would ideally work for a user defined stopping rule that would consist of either a single crm-Pack stoping rule class 
for example 
    # Total sample size for next dose is already >= 9.
      Stopping_Rule5 <- StoppingPatientsNearDose(nPatients = 9,percentage = 0)
or a combination (BOOLEAN logic) of mulptiple single crm-Pack stoping rule classes. 

Additionally we would like to report :
- How many times each individual stopping rule is triggered during the simulation (add up to more than 100 %).
- Assuming the stopping rules used for the study simulation follow a pre-defined order of importance and assuming that multple stopping rules can be trigered at the
   end of each simulation for example: 
     Stopping_Rules_Combined <- (Stopping_Rule1 | Stopping_Rule2 | Stopping_Rule3  | Stopping_Rule4  | Stopping_Rule5)
   only the most import of those trigered is coutned in each simulation run (add to 100 %).
   
## Implementation suggestion

# A. stopping rule naming for reporting
  How to get the name of a stopping rule?
  1. get the class name (might not be well readable)
  2. should we have a slot in stopping rule classes (would require manual adjustment of all stopping rule classes) - 
      requires to be present in all classes otherwise will throw errors.

For option one we would have to add a slot to the rule class, so that we can refer to the name slot later.
```{r class.source = 'fold-hide',message = F, warning = F, results='hide'}

.StoppingMinCohorts <-
    setClass(Class="StoppingMinCohorts",
             representation(nCohorts="integer",
                            name = "character"),
             prototype(nCohorts=3L, name = "minimum required number of cohorts"),
             contains="Stopping",
             validity=function(object){
                 o <- Validate()

                 o$check((object@nCohorts > 0L) && is.scalar(object@nCohorts),
                         "nCohorts must be positive scalar")

                 o$result()
             })
#validObject(.StoppingMinCohorts())


StoppingMinCohorts <- function(nCohorts, name)
{
    .StoppingMinCohorts(nCohorts=safeInteger(nCohorts))
}

```


The two options we have to print the stopping rule name later: 
```{r}

myStopping1 <- StoppingMinCohorts(nCohorts=3)

myStopping1@name

class(myStopping1)
```

# B. Unpack combined stopping rules

Now, let's assume we have a combination of stopping rules. I'll go with class() for now so that I don't have to adjust all the stopping rule classes. How would we access all the names? 

```{r}
myStopping2 <- StoppingTargetProb(target=c(0.2, 0.35),
                                     prob=0.5)
myStopping3 <- StoppingMinPatients(nPatients=20)

myStopping_combined <- (myStopping1 & myStopping2) | myStopping3

```


This is the current implementation, I have tested it with multiple combinations 
 
* (Stopping_Rule1  | Stopping_Rule2 | Stopping_Rule3  | Stopping_Rule4  | Stopping_Rule5)
* ((Stopping_Rule1  & Stopping_Rule2) | Stopping_Rule3  | Stopping_Rule4  | Stopping_Rule5)
* Stopping_Rules_Combined3 <- (Stopping_Rule1  | Stopping_Rule2 | Stopping_Rule3  | (Stopping_Rule4  & Stopping_Rule5))
* (Stopping_Rule1  | (Stopping_Rule2 & Stopping_Rule3  & Stopping_Rule4)  | Stopping_Rule5)
* Stopping_Rules_Combined5 <- (Stopping_Rule1  |Stopping_Rule2) & (Stopping_Rule3  | Stopping_Rule4)

and it worked fine for all of them. 
```{r}
k = 1
max = 0
number = list()
names = list()
ind = 1
stopping_objects <- myStopping_combined@stopList



for ( i in stopping_objects) {

  t <- try(slot(i, name = "stopList"), silent = T)

    if("try-error" %in% class(t)){   # only one rule


    if ( max >= k){
      number[ind] <- as.character(max+1)
      #names [ind] <- slot(stopping_objects[[ind]], "name")
      names [ind] <- class(stopping_objects[[ind]])
      max <- max + 1
    } else {
    number[ind] <- as.character(k)
    #names [ind] <- slot(stopping_objects[[ind]], "name")
    names [ind] <- class(stopping_objects[[ind]])
    }

    k = k+1
    ind = ind + 1
  } else { # multiple combined rules 

    max = k + length(i@stopList) - 1
   
   number[ind] <- paste(k : max, collapse = " & ")
   #names[ind] <- paste(sapply(stopping_objects[[ind]]@stopList, slot, "name"), collapse = " and ")
   names[ind]  <- paste(sapply(stopping_objects[[ind]]@stopList, class), collapse = " and ")
   ind = ind + 1
   k = k + length(k:max)
  }

}

names
number

```

# C. Count number of hits across all iterations and calculate return measures

So, this is how we can get the order and names of the stopping rules for reporting later on. To count the frequency we have to get the information per iteration from the simulation method: 

```{r, eval = F}
stopLength <-length(object@stopping@stopList)
                stop_sum <- matrix(nrow=1,ncol=stopLength)
                for (i in 1: stopLength){
                  stop_sum[,i]<- stopTrial(stopping=object@stopping@stopList[[i]],
                                           dose=thisDose,
                                           samples=thisSamples,
                                           model=object@model,
                                           data=thisData)
                  
                }

```
As a result we would get a matrix for each iteration that looks like this: 


```{r}
output_it1 <- matrix(nrow= 1, ncol = 2)
output_it2 <- matrix(nrow= 1, ncol = 2)
output_it3 <- matrix(nrow= 1, ncol = 2)
output_it4 <- matrix(nrow= 1, ncol = 2)
output_it1[1, ] <- c(TRUE, FALSE)
output_it2[1, ] <- c(FALSE, TRUE)
output_it3[1, ] <- c(TRUE, FALSE)
output_it4[1, ] <- c(TRUE, TRUE)

output <- list(output_it1, output_it2, output_it3, output_it4)
output
```

Based on this we calculate the measure we're interested in: stopping reasons for all stopping rules and the first hit per iteration (that would happen in the summary method):
```{r}
stopReasonsUnique <- sapply(output,colSums)
stopReasonsUnique
stopReasonsUniquePercent<- (rowSums(stopReasonsUnique)/length(stopReasonsUnique[1,]))*100
stopReasonsUniquePercent
              

## %trials each stopping rule fired first based on the order of the stopping rule defined in the design
stopReasonsFirstHit<-apply(stopReasonsUnique,2,function(x){min(which(x == "1"))})
stopReasonsFirstHitFreq<-table(stopReasonsFirstHit)

stopReasonsFirstHit              
stopReasonsFirstHitFreq              
              
if (dim(stopReasonsFirstHitFreq)<=length(output[[1]])){
          frame<-as.data.frame(stopReasonsFirstHitFreq)
          framefull<-data.frame(stopReasonsFirstHit=1:length(output[[1]]))
          frame1 <- merge(x=framefull ,y= frame, by="stopReasonsFirstHit", all.x = TRUE)
          frame1$Freq[is.na(frame1$Freq)] = 0
          stopReasonsFirstHitFreq <- as.numeric(frame1$Freq)
              }
              
## percentage of different values of the freq
stopReasonsFirstHitFreqPercent <- (stopReasonsFirstHitFreq/sum(stopReasonsFirstHitFreq))*100
stopReasonsFirstHitFreqPercent              
```

If we put everything together, the output can then for example look like this: 

>>Stops (individual) for reason 1 & 2 StoppingMinCohorts and StoppingTargetProb : 75 %  
>>Stops (individual) for reason 3 StoppingMinPatients : 50 %  

>>Stops (first hit) for reason 1 & 2 SStoppingMinCohorts and StoppingTargetProb : 75 %  
>>Stops (first hit) for reason 3 StoppingMinPatients : 25 %  



## Class and Method functions affected 

* method "simulate"
* class "Simulations"
* class "Summary"
* method "summary
* method "show"
